{"pages":[{"title":"安安，你好。","text":"翁慧倪 @huini_ong 狀態：緩慢但持續前進的烏龜 🐢 欸欸 我想成為聰明的人 📍&nbsp;&nbsp;TW. 🏠&nbsp;&nbsp;MY. 🎈&nbsp;June 9, 1998 前端菜雞 ( 2021 年 2 月開始自學前端開發 ) 正在尋找前端相關的工作 相信變強的最快方法是進去被電爆 我家猫会后空翻，我會寫程式。 我還會做小東西。 React | 📺 Netflix Clone React | 🎞️ Movie App React | ⌨️ Speed Test App React | 😂 Meme Generator React | ✔️ Todo App Vanilla JS | 🟡 Pacman Game Vanilla JS | 🐍 Snake Game Vanilla JS | 😜 Joke Generator Vanilla JS | 🎲 Dice Game 也會發廢文。 清大中文系畢業，喜歡寫字，沒想到後來也喜歡寫程式 摘星星的人，即使徒勞無功，亦不致於一手污泥 不笑時臉看起來很臭，但真的沒有心情不好 喜歡清心的多多綠微糖微冰加珍珠 都想做不同的事、玩不同的東西 馬來文、粵語、台語也會一些 寫程式和寫字都很浪漫 偶爾是廢文產生器 火鍋愛好者 我沒有貓 雖然我沒有貓，但還是要跟我聊天呀。 12//其實很討厭點了 email icon 就跳出寄信郵箱，所以這裡附上 emailwinnieong0609@gmail.com","link":"/about/index.html"}],"posts":[{"title":"【實作記錄】 玻璃擬態登入頁面 | Vanilla Js","text":"live DemoGithubCode Pen 簡介這是接觸網頁前端三巨頭時練習的第一個小作品。尚未學習RWD之觀念，因此畫面在手機觀看會爆掉QAQ。頁面呈現玻璃擬態(Glassmorphism)效果。 功能 CSS : 用戶輸入的部分設置了Placeholder CSS : 每一個預設可以點擊之按鈕都設置了hover效果 JS : 用戶點擊Sign in 按鈕後，先前輸入的資料會淨空 JS : 設置了用戶輸入提醒，若缺少用戶名/密碼將會跳出警告 JS : 用戶名與密碼藉有輸入將會跳出”username, Welcome!”之字樣 小筆記記錄一些CSS小筆記，作往後回顧之用。 Glassmorphism效果12345678910111213.loginSec{ padding: 42px 22px; border-radius: 10px; background-color: rgba(255, 255, 255, 0.10); border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); box-shadow: 0 0.9px 8.5px -9px rgba(0, 0, 0, 0.041), 0 2.4px 23.5px -9px rgba(0, 0, 0, 0.069), 0 5.7px 56.7px -9px rgba(0, 0, 0, 0.098), 0 19px 188px -9px rgba(0, 0, 0, 0.16) ;} Hover底線效果1234567891011121314#forgetBtn::after{ content: ''; display: block; border-bottom: solid 1.3px #ffffff; height: 1.3px; transform: scaleX(0); transform-origin: 0% 100%; transition: transform .3s;}#forgetBtn:hover:after{ transform: scaleX(1); transition: transform .3s;} 背景圖縮放不影響比例1234567body{ background-image: url(&quot;https://i.postimg.cc/3rv5HhSL/login-page-background.png&quot;); background-repeat: no-repeat; background-size: cover; background-position: center center; background-attachment: fixed;} 小結這個畫面可以改進的地方有很多，但由於是第一次練習，因此沒有特別修改，想留下一些 黑歷史 記錄。這篇筆記為個人學習記錄，若有錯誤或是可以更好改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/03/0303-login/"},{"title":"【實作記錄】Snake Game | Vaniila JS","text":"Live DemoGithubCodePen 簡介這是一款復古風的貪吃蛇遊戲。點擊開始 ᐅ ，蛇便會開始往前移動，通過鍵盤上下左右鍵操控蛇的方向。蛇往前的邏輯是碰到果實，碰到的格子會移除、蛇的最後會增加一格。果實和障礙物則隨機產生。在碰到障礙物、墻壁以及自己的身體時，遊戲便會結束，同時顯示蛇身長度以及分數。點擊 restart 可以重啟遊戲。 功能 隨機產生果實(藍色)與障礙物(block) 可通過 WASD 鍵 / ↑ ↓ ← → 鍵移動蛇 蛇的長度會隨著吃的果實而增加 吃的果實越多，移動速度就越快 碰到障礙物、墻壁、自己遊戲便會結束 提供建議遊戲規則 吃果實、碰到障礙物有音效 音效可以透過 “Volume icon” 關閉 遊戲結束後會顯示分數以及蛇的長度 小筆記增加音效的方法Audio for Web games 1234var myAudio = document.createElement(&quot;audio&quot;);myAudio.src = &quot;mysprite.mp3&quot;;myAudio.play();myAudio.pause(); 使用鍵盤操控1234567891011121314151617181920document.addEventListener(&quot;keyup&quot;, control)function control(e) { if (e.keyCode === 39 || e.keyCode === 68) { console.log(&quot;right pressed&quot;) direction = 1 } else if (e.keyCode === 38 || e.keyCode === 87) { console.log(&quot;up pressed&quot;) direction = -width } else if (e.keyCode === 37 || e.keyCode === 65) { console.log(&quot;left pressed&quot;) direction = -1 } else if (e.keyCode === 40 || e.keyCode === 83) { console.log(&quot;down pressed&quot;) direction = +width }} 小結這是為了練習 JS 邏輯而製作的一款小遊戲。之後會想要增加遊戲難度或是關卡、果實和障礙物出現的位置、蛇移動的靈活度也可以再調整。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/15/0315-snake-game/"},{"title":"【實作記錄】The Dice Game | Vanilla JS","text":"live DemoGithub 簡介這是使用純 JS 寫的小小擲骰子遊戲，主要用來練習使用 JS 操控 DOM. 功能 點擊按鈕擲骰子，點數直接加到分數板，贏家為先獲得 20 分的隊伍 兩隊玩家各有兩個角色可以選擇 玩家可以輸入名字 輪到藍隊玩家時，其角色會出現藍色框框；粉隊玩家則為粉色框框 點數更換成骰子的 icon 小筆記 inner.HTML : 可以直接加入 html tag 123characterPlayer1_first.addEventListener(&quot;click&quot;, function(){ document.querySelector(&quot;.border1&quot;).innerHTML='&lt;img class=&quot;img1&quot; src=&quot;./img/robot-1.png&quot; alt=&quot;player one&quot;&gt;'}) 圖片重疊 : 使用 position:absolute 進行定位 小結這不是一個複雜的遊戲，基本擲骰子積計分的功能蠻快就做出來了。反而花最多時間的地方在玩家回合的粉色和藍色框框，原本框框設置成照片的 border, 但在換角色時候，框框就無法顯示。最後才想到把框框獨立出來就好了(༎ຶ⌑༎ຶ) 其他部分則沒有遇到太大的問題。之後有機會要再改良的話，應該會從兩隊勝率不均這個部分下手。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/12/0312-dice-game/"},{"title":"【實作記錄】Pacman Game | Vanilla JS","text":"Live DemoGithubCodePen 簡介這是一款使用 JavaScript 製作的小精靈遊戲。玩家將所有點點吃完便會獲勝、被精靈吃掉遊戲便結束。點點分數為 1 分、大點點 (power pallet) 為 10 分、吃掉害怕狀態的精靈增加 100 分。其中也添加了音效，默認為關閉，可點擊右上的 “volume icon” 打開。 功能 使用上下左右鍵移動 Pacman 吃了 Power Pallet 便可以吃掉顏色為橘色的精靈 每個動作都有音效，可以透過右上的 “volume icon” 關閉 吃完點點便會宣佈獲勝 被精靈吃掉，遊戲便結束 小筆記Pacman 的移動Pacman 的上下移動邏輯使用 switch 處理。判斷 pacman 在移動的時候是否碰到墻壁，若沒有碰到墻壁/沒有碰到精靈則可以往按鍵的方向行動。 判斷是否碰到墻壁：如果要往下的那個沒有 “wall” 這個 class ，表示沒有 判斷是否碰到精靈：如果要往下的那個沒有 “ghost” 這個 class ，表示沒有 keycode 移動方式 判斷方式 40 往下鍵 pacman 所在的位置 + width 判斷是否已經到最底層：如果 pacman 所在 index 加上 width 小於整個 layout 的最大 index， 表示沒有超出邊界 38 往上鍵 pacman 所在的位置 - width 判斷是否已經到最上層：如果 pacman 所在 index 減掉 width 小於整個 0， 表示沒有超出邊界 37 往左鍵 pacman 所在的位置 -1 判斷是否已經到最左邊：如果 pacman 所在 index 除 width 的餘數不等於 0， 表示沒有超出邊界 38 往由鍵 pacman 所在的位置 +1 判斷是否已經到最左邊：如果 pacman 所在 index 除 width 的餘數小於 width - 1， 表示沒有超出邊界 1234567891011switch(e.keyCode) { case 40 : console.log(&quot;pressed down&quot;) if ( pacmanCurrentIndex + width &lt; width * width &amp;&amp; !squares[pacmanCurrentIndex + width].classList.contains(&quot;wall&quot;)&amp;&amp; !squares[pacmanCurrentIndex + width].classList.contains(&quot;ghost-liar&quot;) ) pacmanCurrentIndex += width break 精靈的 class由於 4 個精靈是一組的，都有 className 、起始位置、移動速度、當下位置、是否為害怕狀態、計時器，因此使用 class 來處理。需要每一隻精靈執行共同的程式碼就使用 for Each. 12345678910111213141516171819class Ghost{ constructor(className, startIndex, speed){ this.className = className this.startIndex = startIndex this.speed = speed this.currentIndex = startIndex this.isScared = false this.timerId = NaN }}//傳入需要的參數：classname, 起始位置，速度const ghosts = [ new Ghost(&quot;blinky&quot; , 347, 250), new Ghost(&quot;pinky&quot; , 376, 400), new Ghost(&quot;inky&quot; , 352, 300), new Ghost(&quot;clyde&quot; , 379, 500),] 把精靈畫進 grid 裡123ghosts.forEach (ghost =&gt; { squares[ghost.currentIndex].classList.add(ghost.className) squares[ghost.currentIndex].classList.add(&quot;ghost&quot;) 精靈移動 使用 Math.random() 決定精靈移動的方向，因此方向是沒有邏輯的 12const directions = [-1 , +1 , -width , +width]let direction= directions[Math.floor(Math.random() * directions.length)] 沒有碰到碰到精靈或墻壁，就可以往隨機選出來的方向前進一格 1234567891011if ( !squares[ghost.currentIndex + direction].classList.contains(&quot;wall&quot;) &amp;&amp; !squares[ghost.currentIndex + direction].classList.contains(&quot;ghost&quot;) ){ squares[ghost.currentIndex].classList.remove(ghost.className) squares[ghost.currentIndex].classList.remove(&quot;ghost&quot;, &quot;scared-ghost&quot;) ghost.currentIndex += direction squares[ghost.currentIndex].classList.add(ghost.className) squares[ghost.currentIndex].classList.add(&quot;ghost&quot;)} 在吃了 power pallet 之後，精靈會轉為 scared 狀態，就可以被吃 this.isScared = true 會轉為橘色123456789if ( ghost.isScared &amp;&amp; squares[ghost.currentIndex].classList.contains(&quot;pacman&quot;)){ squares[ghost.currentIndex].classList.remove(ghost.className,&quot;scared-ghost&quot;) ghost.currentIndex = ghost.startIndex score += 100 squares[ghost.currentIndex].classList.add(ghost.className , &quot;ghost&quot;) eatGhostSound()} 遊戲結束 碰到精靈遊戲便會結束 計時器會被清除，按鍵被移除，game over 字樣出現123456789if ( !ghost.isScared &amp;&amp; squares[ghost.currentIndex].classList.contains(&quot;pacman&quot;)){ ghosts.forEach(ghost =&gt; clearInterval(ghost.timerId)) document.removeEventListener(&quot;keydown&quot;, control) gameOver.style.display = &quot;block&quot; overlay.style.display=&quot;block&quot; deathSound()} 玩家贏了 吃完所有點點就宣佈獲勝1234567891011let dot = 305function win(){ if( dot === 0){ ghosts.forEach(ghost =&gt; clearInterval(ghost.timerId)) document.removeEventListener(&quot;keydown&quot;, control) gameWin.style.display = &quot;block&quot; overlay.style.display=&quot;block&quot; winSound() }} 小結這個小遊戲中練習了 class 以及 switch. 這裡沒有處理精靈移動的邏輯，原本應該追著 / 包抄 pacman， 但因為是使用隨機方向，因此精靈們看起來很笨（扶額）。這個部分等我找到比較好的方式再來看看怎麼讓他們聰明一些。畫地圖是使用 excel 先畫一遍，再把他們轉為 index，才填上顏色。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/26/0326-pacman-game/"},{"title":"【學習筆記】 useEffect | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 useEffect 小栗子 可運作 side effect （可以影響其他 component 且在 render 期間無法完成的），如 fetch 資料、訂閱、或手動改變 DOM。 useEffect 包含了 componentDidMount ，componentDidUpdate ，以及 componentWillUnmount 的功能 每一次render都會執行useEffect，因此要設定在某個條件下才會觸發這個 function 計數器例子 12345678910111213141516171819202122import React, { useState, useEffect } from 'react'; //引入useEffectfunction Example() { const [count, setCount] = useState(0); // 與 componentDidMount 和 componentDidUpdate 類似： useEffect(() =&gt; { // 使用瀏覽器 API 更新文件標題 document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );}export default Example 計數器+random color例子 123456789101112131415161718192021222324252627282930import React, {useState, useEffect} from &quot;react&quot;import randomcolor from &quot;randomcolor&quot; //這引入了別的libraryfunction App() { const [count, setCount] = useState(0) const [color, setColor] = useState(&quot;&quot;) function increment() { setCount(prevCount =&gt; prevCount + 1) } function decrement() { setCount(prevCount =&gt; prevCount - 1) } useEffect(() =&gt; { setColor(randomcolor()) }, [count]) //執行條件設為當count改變時 return ( &lt;div&gt; &lt;h1 style={{color: color}}&gt;{count}&lt;/h1&gt; &lt;button onClick={increment}&gt;Increment&lt;/button&gt; &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt; &lt;/div&gt; )}export default App 注意 因為每一次render，都會重新呼叫useEffect這個function，所以要設定條件。12345//這樣寫會導致這個function一直被呼叫useEffect(() =&gt; { setColor(randomcolor())}) ==BUG== ==預設情況== 清除 effect 這裡指的 effect 就是我們傳進 useEffect 的 fucntion 每個 effect 都可以回傳一個會在它之後執行清除的 function 一個在執行之後需要清除的 function，可以在新增 function 後回傳一個需要清除的 function 其他不需要清除的就不需要回傳 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :)","link":"/2021/04/10/0411-note-useeffect/"},{"title":"【實作記錄】Joke Generator App | Vaniila JS","text":"Live DemoGithubCodePen 簡介這是為了練習連接 API 所設計的小遊戲，使用原生 JS 製作，界面模擬聊天機器人跟使用者互動。由於沒有設計真的的聊天機器人，所以使用了看起來笨笨的方法（延遲執行的方法）來操作。 功能 第一個聊天室可以進入 點擊 “ Tell me a Joke “ 就會出現笑話 提供簡單回復按鈕：Tell me the answer、LOL😂 暫時僅適用於Android和桌面用戶 小筆記 API : https://official-joke-api.appspot.com/jokes/programming/random 使用 async/ await 的方式 fetch API 使用 setTimeOut， 讓用戶在點擊按鈕 1 秒後才出現結果 小結簡簡單單的練習 fetch API，並沒有什麼太大的問題，反而在刻畫面上有比較大的問題，使用 Apple Device 瀏覽畫面就會直接爆掉。嗯，之後再來修好了，現在要繼續前進啦。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/04/02/0402-joke-generator/"},{"title":"【學習筆記】 useState | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 Function Component function component 長這樣 12345678910//function componentimport React from &quot;react&quot;function App() { return ( &lt;div&gt; &lt;h1&gt;Is state important to know? Yes&lt;/h1&gt; &lt;/div&gt; )} 123456789101112131415//例子import React, {useState} from &quot;react&quot; //引入useStatefunction App() { //這裡的state不一定要是object const [answer] = useState(&quot;Yes&quot;) const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: 'Learn Hooks' }])//這裡可以宣告多個變數 return ( &lt;div&gt; &lt;h1&gt;Is state important to know? {answer}&lt;/h1&gt; &lt;/div&gt; )} 宣告一個 state 變數 1const [目前 state 數值, function] = useState(initial value) useState 回傳一組數值：目前 state 數值和一個可以讓你更新 state 的 function 與 class component 不同，state 不一定要是object 與 class component this.state({name: value, name: value}) 相似，它可以宣告多個變數 計數器例子 12345import React, { useState } from 'react';function Example() { // 宣告一個新的 state 變數，稱為「count」 const [count, setCount] = useState(0);//不一定要是object useState 宣告了一個變數，這個變數會被保存起來 傳入 useState 的是這個變數的起始值，這個起始值可以不需要是 object，這裡因為計數器需要所以傳入 num 起始值只在第一次 render 的時候會使用到 讀取 State 與 class component 讀取 state 的方式不同 &lt;p&gt; {this.state.count} &lt;/p&gt; ，function component 可以直接讀取變數{count} 1&lt;h1&gt; {count} &lt;/h1&gt; 更新 state 可以直接用 setCount 和 count 直接更新123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; 總結 第 1 行 : 引入 useState 第 5 行 : 在 App component 裡，呼叫 useState Hook 宣告了一個新的 state 變數，成為 count ( 作計數用 )。將起始值設為 0 並傳入 useState 當作唯一參數。第二個回傳的值是個可以更新 count 的 function，命名為 setCount。 第 18 , 19 行：當使用者點擊，就呼叫 increment/ decrement function , setcount 更新 count 的值。 12345678910111213141516171819202122import React, {useState} from &quot;react&quot;function App() { // 宣告一個新的 state 變數，稱為 count const [count, setCount] = useState(0) function increment() { setCount(prevCount =&gt; prevCount + 1) } function decrement() { setCount(prevCount =&gt; prevCount - 1) } return ( &lt;div&gt; &lt;h1&gt; {count} &lt;/h1&gt; &lt;button onClick = {increment} &gt;Increment&lt;/button&gt; &lt;button onClick = {decrement} &gt;Decrement&lt;/button&gt; &lt;/div&gt; )} 綜合例子123456789101112131415161718192021222324252627282930313233343536373839404142import React, {useState} from &quot;react&quot;function App() { const [inputData, setInputData] = useState({firstName: &quot;&quot;, lastName: &quot;&quot;}) const [contactsData, setContactsData] = useState([]) function handleChange(event) { const {name, value} = event.target setInputData(prevInputData =&gt; ({...prevInputData, [name]: value})) } function handleSubmit(event) { event.preventDefault() setContactsData(prevContacts =&gt; [...prevContacts, inputData]) } const contacts = contactsData.map(contact =&gt; &lt;h2 key={contact.firstName + contact.lastName}&gt;{contact.firstName} {contact.lastName}&lt;/h2&gt;) return ( &lt;&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;input placeholder=&quot;First Name&quot; name=&quot;firstName&quot; value={inputData.firstName} onChange={handleChange} /&gt; &lt;input placeholder=&quot;Last Name&quot; name=&quot;lastName&quot; value={inputData.lastName} onChange={handleChange} /&gt; &lt;br /&gt; &lt;button&gt;Add contact&lt;/button&gt; &lt;/form&gt; {contacts} &lt;/&gt; )}export default App 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :) 參考資料 使用 State Hook 【React.js入門 - 20】 useEffect - 在function component用生命週期","link":"/2021/04/10/0410-note-usestate/"},{"title":"【學習筆記】 表單 | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 Controlled ComponentReact 創建表單的方式有兩種：Controlled Component 以及 Uncontrolled Component。前者的表單的資料是被 React component 所處理；後者表單的資料則由 DOM 本身處理。多數情況下建議使用 controlled component. Text在 React 中，可變的 state 通常是被維持在 component 中的 state property，並只能以 setState() 來更新。State 在用戶每次輸入的時候都會更新，如果將用戶輸入的資訊都印出來，字會隨著用戶輸入的一個一個字出現（結尾有示範影片）。 建立react component 在render()中設定需要的input 在this.state中初始化firstName/lastName的值 12345678class APP extends Component{ constructor(){ super() this.state = { firstName : &quot;&quot;, lastName : &quot;&quot; } } 設定 onChange 的function(handleChange)為了抓取用戶說輸入的資訊再更新 State，因此要在 input 中加入onChange，將其指向更新 function (這裡指向 handleChange function)。每次用戶輸入時，state 都會更新。與此同時綁定 function 以及 state. 在 handleChange function 中為 fisrtName / lastName 重新賦值。 1this.handleChange = this.handleChange.bind(this) 為了避免重新賦值時有錯誤，因此要為 input 個別設定 name（在input 中加入name）。在 handleChange function 中就可以直接指向 input 的 name. 無論是哪一種 input 都應該使用這樣的方式去更新資料。 123456handleChange(event){ this.setState({ //不直接寫firstName : event.target.value [event.target.name] : event.target.value }) } 為input添加value attribute讓 this.state 的 value 等於用戶輸入的樣子。 完整程式碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, { Component } from &quot;react&quot;class APP extends Component{ constructor(){ super() this.state = { //初始化 firstName : &quot;&quot;, lastName : &quot;&quot; } this.handleChange = this.handleChange.bind(this) //綁定 } //可以簡化成這樣 handleChange(event){ const {name, value} = event.target this.setState({ [name] : value } ) } render(){ return( &lt;form&gt; &lt;label&gt;First Name &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;firstName&quot; value={this.state.firstName} onChange={this.handleChange} /&gt; &lt;br/&gt; &lt;label&gt;Last Name &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot; value={this.state.lastName} onChange={this.handleChange} /&gt; &lt;p&gt;{this.state.firstName}{this.state.lastName}&lt;/p&gt; //印出來 &lt;/form&gt; ) }}export default APP TextArea跟原 HTML 的寫法有些不同，在 HTML 中，一個 textarea 的 element 是經由它的 children 來定義它的文字。React 中的則是使用 value attribute。 1&lt;textarea value={&quot;Some default value&quot;}/&gt; Checkboxcheckbox 中的 checked attribute 是 boolean，可在 this.state 中設定它的值。checkbox 可以讓用戶勾選/不勾選，因此需要設定 onChange 讓 checked 變成可改變的。 12345&lt;input type=&quot;checkbox&quot; checked={boolean} onChange={function}/&gt; Radioradio 跟 checkbox 的寫法很類似。同一組的 radio button 要設置相同的名字，這樣才會被認為是一組，才能從中擇一。 12345678910111213141516171819&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked={this.state.gender === &quot;male&quot;} onChange={} /&gt; Male&lt;/label&gt;&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; checked={this.state.gender === &quot;female&quot;} onChange={} /&gt; Female&lt;/label&gt; Selectselect 的下拉式選單中，預設被選定的值與 HTML 中寫的不同，React使用 value 這個 attribute 來選定預設的值，範例中預設被選定的是 ‘blue’ 。 123456789101112&lt;label&gt;Favorite Color: &lt;/label&gt; &lt;select value={&quot;blue&quot;} //預設值 onChange={this.handleChange} name=&quot;favColor&quot; &gt; &lt;option value=&quot;blue&quot;&gt;Blue&lt;/option&gt; &lt;option value=&quot;green&quot;&gt;Green&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;Red&lt;/option&gt; &lt;option value=&quot;orange&quot;&gt;Orange&lt;/option&gt; &lt;option value=&quot;yellow&quot;&gt;Yellow&lt;/option&gt; &lt;/select&gt; 範例Travel form 實作一個簡單的 Travel form，使用了&lt; text &gt; &lt; textarea &gt; &lt; checkbox &gt; &lt; radio &gt; 以及 &lt; select &gt;。 表單內容包括： First Name/ Last Name : text Age : number Gender : radio Destination : select Dietary restrictions: checkbox 解法 首先建立 react component 以及需要的 input。 創建操縱每個 input 改變的function + binding 為了讓 input 的值得以改變 12345function handleChange(event){ this.state({ xxx })} First Name/ Last Name/ Age : text 為了收到用戶的輸入以及及時改變 state，input 內需要onchange 以及 value 兩個attribute ( 其他 type 亦然 ) onchange: 當用戶輸入時，就會立刻執行指向的 function，立即更新 state value : 會指向 function 更新完後的 value 123456handleChange(event){ const {name, value} = event.target this.setState({ [name] : value //event.target.name選中的是input裡的'name' }) } 1234567&lt;input type=&quot;text&quot; name=&quot;firstName&quot; placeholder=&quot;First Name&quot; value={this.state.firstName} onChange={this.handleChange}/&gt; Gender : radio input 內加上 onchange（ 指向 handleChange function ） &amp; value 跟 checkbox 的原理相似，擇一的功能需要依賴 check 12345678&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; //當state是female時，就可以選到 checked={this.state.gender === &quot;female&quot;} onChange={this.handleChange}/&gt;Female Destination : select input 內加上 onchange（ 指向 handleChange function ） &amp; value 選項默認會是第一個，但這個選項不會被取得，需要切換到第二個選項再切回來才會被選中 1234567891011&lt;select value={this.state.destination} name=&quot;destination&quot; onChange={this.handleChange} &gt; &lt;option value=&quot;&quot;&gt;---Please choose a planet---&lt;/option&gt; &lt;option value=&quot;🪐Tatooine&quot;&gt;🪐Tatooine&lt;/option&gt; &lt;option value=&quot;🌖Alderaan&quot;&gt;🌖Alderaan&lt;/option&gt; &lt;option value=&quot;☀️Hoth&quot;&gt;☀️Hoth&lt;/option&gt; &lt;option value=&quot;⭐Bespin&quot;&gt;⭐Bespin&lt;/option&gt;&lt;/select&gt; Dietary restrictions: checkbox 設定每一個初始值為 false 使用checked來改變 function funtion 調整 這幾種 input 會分成兩種狀況：適用於 checkbox 的以及 checkbox 以外的。因為只分為兩種狀況，因此可以使用 if type 等於 checkbox 就執行冒號前的，不等於 checkbox 則執行冒號後的 結果顯示Yes / No 1234567//先設定每一個選項的 booleanthis.state = { isFish: false, isBread : false, isMilk : false,} 12345678//input的checked&lt;input type=&quot;checkbox&quot; name=&quot;isFish&quot; checked={this.state.isFish} onChange={this.handleChange} /&gt;Colo Claw Fish 12345678910111213//function調整handleChange(event){ const {name, value, type, checked} = event.target type === &quot;checkbox&quot; ? this.setState({ [name] : checked //checkbox的情況 }) : this.setState({ //其他的的情況 [name] : value, }) } 12//結果顯示&lt;p&gt;Colo Claw Fish : {this.state.isFish ? &quot;Yes&quot;:&quot;No&quot;}&lt;/p&gt; 小結直接刻表單程式碼會落落長的，所以可以分好 Component 讓程式碼比較好維護. 另外也有 Formik 這個工具，主打無痛創造 React 表單，但這個還沒仔細研究過。（坑待補） 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :) 參考資料 React Forms Presentational and Container Components","link":"/2021/04/09/0409-form-note/"},{"title":"【實作記錄】Todo List | React","text":"Live DemoGithub 簡介這是一個有基本功能的 todo list 練習，為了練習語法以及邏輯，所以參考了教學影片，文末附上教學影片之連結。這裡練習了各個 Component 之間的傳遞、React Hook 也認識了之前沒有用過的幾個 CSS 小方法。下面詳細記錄了自己的學習步驟。 功能 增加 task 刪除 task 完成的 task : 打√, 劃掉的線 可以 filter 完成/未完成/所有的 task 前置作業簡單劃分需要的功能以及元件。除了 index.js 外，主要的操作都在 App.js.其餘的 Component 集中放到 components 的 file 中。 index.js App.js Form.js TodoList.js Todo.js 步驟基本設置整個Todo list 是由兩個部分組成的：form 以及 list。 form : 設置讓用戶輸入的 form , 包含輸入的框框 (input) &amp; 添加按鈕 (button) &amp; filter (select) 。Filter 裡有三個 option : All/ completed / uncompleted。 list : 用戶在增加 task 之後，該 task 會出現在 list 裡。只要設置一個 unorder list，增加的部分之後會處理。 index.js1234567891011import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';ReactDOM.render( &lt;div className=&quot;container&quot;&gt; &lt;App /&gt; &lt;/div&gt;, document.getElementById('root')); Form.js123456789101112131415161718192021222324252627import React from &quot;react&quot;import '../index.css'; //引入外部cssconst Form = () =&gt; { return( &lt;form&gt; &lt;div className=&quot;input-option&quot;&gt; &lt;select dir=&quot;rtl&quot;&gt; &lt;option class=&quot;options&quot; value=&quot;all&quot;&gt;All&lt;/option&gt; &lt;option class=&quot;options&quot; value=&quot;completed&quot;&gt;Completed&lt;/option&gt; &lt;option class=&quot;options&quot; value=&quot;uncompleted&quot;&gt;Uncompleted &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div className=&quot;input-text&quot;&gt; &lt;input className=&quot;text&quot; type=&quot;text&quot; placeholder=&quot;Add a task...&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;&lt;i class=&quot;fas fa-times add&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; )}export default Form Form.js123456789101112import React from &quot;react&quot;import '../index.css';const TodoList = () =&gt; { return( &lt;div className=&quot;todo-container&quot;&gt; &lt;ul className=&quot;todo-list&quot;&gt;&lt;/ul&gt; &lt;/div&gt; )}export default TodoList 處理用戶輸入的input在 App.js 使用 useState 設定 value 的初始值。因為需要處理的 input在 Form.js 中，因此要把這兩個參數往下傳，之後才能在 Form.js 中引入。 App.js123const [inputText, setInputText] = useState(&quot;&quot;)//初始值為空字串&lt;Form inputText={inputText} setInputText={setInputText}/&gt; 接著處理用戶輸入的資訊。在 input 中設定 onchange 以及 value. input 改變時，onChange 會被觸發，因而執行設定好的 function. 創造一個處理更新的 function : handlechange.使用 setTnputText 更新input 的 value.用戶每輸入一個字，就會觸發 onchange, 所以會出現下面的結果。 const Form = ({ setInputText }) 相等於 const Form = ({props}) 的寫法，前者是直接把 setInput 這個參數傳進來，所以在使用 setInputText 的時候不用加上 props. 後者在使用時要寫 props.setInputText ，直接把參數傳進來的寫法會比較簡潔。 Form.js123456789101112const Form = ({ inputText ,setInputText }) =&gt; { //這是App.js中傳進來的參數 function handlechange(event){ setInputText(event.target.value) //更新inputText的值 console.log(event.target.value) //下面有log出來的效果 }&lt;input className=&quot;text&quot; type=&quot;text&quot; placeholder=&quot;Add a task...&quot; value={inputText} onChange={handlechange}/&gt; 結果會是這個樣子： 把用戶輸入的東西存進 todo list 裡運作邏輯：用戶輸入 task &gt; 按 summit button &gt; task 被加到 list 裡 增加 button onclick function. 在按下 button 之後，用戶輸入的值加到 todo list 裡，可以創造一個新的 hook 將 todo list 存進 array 裡。因此創造了const [todos, setTodos] = useState([])，初始值為空 array.與input一樣，這個功能會在 Form.js 裡完成，因此也要將參數往下傳。 App.js12345678const [todos, setTodos] = useState([])&lt;Form inputText={inputText} setInputText={setInputText} todos={todos} setTodos={setTodos} /&gt; 接著處理用戶輸入的資料。在把 todos, setTodos 傳進 Form.js 後，增加button 的 onclick，觸發 function 設為 submitHandleChange function. 這個 function 會更新 todos 這個 state，首先將原本就存在在 task 存進來，再增加用戶新輸入的 task. 用戶輸入的 task 會以 object 的形式傳進去，包括了 tasks 的名字 (text) 、是否完成 (completed:boolean)、id (使用亂數產生)。 Form.js1234567function submitHandleChange(e) { e.preventDefault() //移除默認 refresh 頁面 setTodos([ ...todos, {text: inputText, completed: false, id: Math.floor(Math.random()*100)} ]) setInputText(&quot;&quot;) //輸入完成後，框框上的字拿掉 } 可以使用 react debugger 來看 todos 這個 state 的變化。在輸入 task 後按下 submit button, state 就會立刻更新。 把輸入的 tasks ( 更新後的 state ) 渲染到瀏覽器上用戶輸入的 tasks 要加到 todo list 裡，這個部分要在 TodoList.js 進行。在 App.js 中把 todos 這個參數往下傳。 App.js1&lt; TodoList todos={todos}/&gt; 在 TodoList.js 裡，todos state 每一次更新，都要把資料往下傳到 todo.js 裡渲染。因此這裡使用 map() 遍歷 todos 裡的每一個 element ，除了輸入的 task 外，也要加上 key ，才不會報錯。 TodoList.js123456789101112const TodoList = ({todos}) =&gt; { console.log(todos) return( &lt;div className=&quot;todo-container&quot;&gt; &lt;ul className=&quot;todo-list&quot;&gt; {todos.map((todo) =&gt; ( &lt;Todo key={todo.id} text={todo.text}/&gt; ))} &lt;/ul&gt; &lt;/div&gt; )} 資料往下傳到 Todo.js 後，就會按照設定好的樣式傳染到瀏覽器上。 Todo.js123456789function Todo({text}) { return( &lt;div className=&quot;todo&quot;&gt; &lt;button className=&quot;check-btn&quot;&gt;&lt;i className=&quot;fas fa-check fa-xs&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;li className=&quot;todo-item&quot;&gt;{text}&lt;/li&gt; &lt;button className=&quot;trash-btn fa-xs&quot;&gt;&lt;i className=&quot;fas fa-times &quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; )} 增加刪除功能有關 task 本 task 的處理，都在 Todo.js裡處理。刪除功能是直接操作 todos state, 因此會調用到 todos 以及 setTodos. 這兩個參數要從要從最頂層的 App.js 往下傳到 TodoList.js ，然後再往下傳到 Todo.js 中. 創造新的 function , 使用filter()來過濾掉不符合條件的 element. 這裡的條件設定為：todos state 中的 element 與 被點擊的 element 之 id 如果不相同就會被留下，相同就表示那是是用戶要刪掉的 element，因為不符合條件所以就被過濾掉了。 Todo.js123function deleteHandleChange(){ setTodos(todos.filter((el) =&gt; el.id !== todo.id)) } 增加 task completed 功能創造新的 function , 使用 map() 遍歷 todos state, 如果 element id 等於被點擊的 item 的 id，就將該 element 的 completed 的 boolean 改成相反的。最後再返回該item. Todo.js1234567891011function CompleteHandleChange(){ setTodos(todos.map((item =&gt;{ if(item.id === todo.id){ return{ ...item, completed: !item.completed } } return item } ))) } 接著處理 UI 的部分，完成後會顯示打打勾、一槓、灰色字。可以用 todo.complete 來判斷是否要加入某個className. Todo.js1234567891011121314151617181920212223//打勾勾//todo.complete 為false時，打勾設定與背景同顏色//todo.complete 為true時，加入&quot;completed-checkbox&quot;，打勾更改為黑色&lt; i className={`fas fa-check fa-xs ${todo.completed? &quot;completed-checkbox&quot; : &quot;&quot;}`}&gt;&lt;/i&gt;//CSS//背景為灰色，打勾也是灰色.check-btn{ display: block; font-weight: 100; padding: .1em .25em; margin-left: 1em; border: none; border-radius: 7px; background-color: #DFDFDF; color: #DFDFDF;}//完成後，打勾顏色更改為黑色.completed-checkbox{ color:black} Todo.js12345678//一槓、灰色字&lt;li className={`todo-item ${todo.completed? &quot;completed &quot; : &quot;&quot;}`}&gt;{text}&lt;/li&gt;//CSS.completed { text-decoration: line-through; opacity: 0.5;} 製作 filter 功能 (All / Complete / Uncomplete)先創造一個 status state 來儲存點擊 option 後的結果。這個 state 會在 Form 中處理，因此要把參數往下傳。 App.js12345678910//把setStatus往下傳，會在 form.js 處理const [status, setStatus] = useState(&quot;all&quot;)//默認為all&lt;Form todos={todos} setTodos={setTodos} inputText={inputText} setInputText={setInputText} setStatus={setStatus} /&gt; 因為選單在 Form.js 裡，因此在 Form.js 處理。設定選單改變時要執行的 function : 更新 setStatus 成點選的選項。選擇 complete的話，這裡 setStatus 就會更新為 completed. Form.js123function statusHandleChange(event){ setStatus(event.target.value)} 再創造一個 filtered state 來儲存被加進來的 task。創造一個新的 state 是為了不要影響到原本用來儲存 tasks 的 todos state. 過濾後的tasks 會被儲存在這個 state. App.js12345678//會在 Todolish.js 中處理const [filteredTodo, setFilteredTodo] = useState([])&lt;TodoList setTodos={setTodos} todos={todos} setFilteredTodo={setFilteredTodo}/&gt; 接著設定 filter 的條件，這裡使用 switch() 來處理 All/completed/uncompleted 的情況。 App.js1234567891011121314151617function filterHandlerChange(){ switch(status){ //這個status的值是 : 點擊 option 後更新的值 //在 &lt;option value=&quot;completed&quot; 的狀況下&gt; case &quot;completed&quot; : //如果是 complete 就過濾出 completed 為 true 的 tasks setFilteredTodos(todos.filter((todo) =&gt; todo.completed === true)) break case &quot;uncompleted&quot; : setFilteredTodos(todos.filter((todo) =&gt; todo.completed === false)) break default: setFilteredTodos(todos) break } } FilteredTodos 會在 tasks 存進 todos state 以及 option 被選擇的時候更新。使用 useEffect 來設定當上述兩種情況發生時，FilteredTodos 執行 function filterHandlerChange。 App.js123useEffect(() =&gt; { filterHandlerChange() }, [todos,status]) 小結到這裡，基本的增、刪、過濾功能就已經完成了。當中遇到無法成功渲染的多數原因為，沒有將參數往下傳到各個 Component 中，在這次的練習中深刻體現要了解自己寫的每一行程式碼的意思，出錯了才有辦法找到 bug 在哪裡。經過這次練習，對拆分的 component 間要如何傳遞以及 React 的寫法都比較熟悉了一些。希望下一個練習可以挑戰更複雜的（堅定臉。 由於主要目的是熟悉 React 的寫法，界面就沒有弄得很 fancy ，就讓他陽春陽春的XD如果有任何不對的地方/有更好的寫法，再麻煩各位大大指教！ :) 參考資料Build A Todo App With REACT | React Project For Beginners (FULL).","link":"/2021/04/13/0413-todo/"},{"title":"【實作記錄】 Movie Search App | React","text":"GithubLive Demo 簡介這個為了練習使用 React 的邏輯以及編寫方式所刻的頁面。這裡練習了如何使用 TMDB 提供的 API 來獲取需要的資料、使用 useState 以及 useEffect來更新資料、拆分 component、使用 styled component 的方法。下面記錄了搜尋頁面 fetch API 的詳細步驟，其他頁面則只是記錄重點功能。參考資料附在文末。 另外，因為專案一直在添加新的功能，因此檔案名字以及 Code 都會有調整，並不完全跟筆記的一樣。 功能 首頁有即將上映之電影 &amp; 熱門電影/電視劇 (可通過點擊按鈕切換) 電影的呈現方式使用橫軸的滾動條 電影頁則是以卡片的形式呈現，點擊卡片會出現電影資訊 彈出的 Modal 內含有電影預告的網址，導致外部鏈接 搜尋到的電影可以加入 favourite list 裡，同時也會加到 local storage 裡 已經儲存的電影可點擊菜單列的愛心查看 無法顯示的照片使用默認照片顯示 前置作業 需要使用的 API : The Movie Database API 先到 TMDB 網站申請賬號，再根據 官方文件 申請網站的 API key .文件上都有清楚的申請步驟，申請成功後，把 key 以及 Access Token 保存下來。 Modal 以及 Pagination 使用 meterial ui1$ npm install @material-ui/lab 步驟搜尋頁面設置基本結構以及樣式簡單設置需要使用到的 class component ，在內添加 JRX 以及引入外部 CSS file 用以測試文件是否能夠渲染到瀏覽器上。 1234567891011121314151617mport React from 'react';import ReactDOM from 'react-dom';import './index.css';class Main extends React.Component{ render() { return ( &lt;div className=&quot;container&quot;&gt; &lt;header&gt; &lt;h1 className=&quot;title&quot;&gt; Search a movie.&lt;/h1&gt; &lt;/header&gt; &lt;/div&gt; ) }}ReactDOM.render(&lt;Main /&gt;,document.getElementById('root')); 創造一個 component使用 form 創造一個 searchMovie component ，裡面需要有 input, label 以及 submit button. 在文件的結尾 export 後，再於 index.js file 中引入 App.js. 12345678910111213function Search(){ return ( &lt;form className=&quot;form&quot;&gt; &lt;label htmlFor=&quot;query&quot;&gt;Movie name&lt;/label&gt; &lt;input type = &quot;text&quot; name = &quot;query&quot; placeholder = &quot;Goziila vs Kong...&quot; /&gt; &lt;button className=&quot;submitBtn&quot; type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ) } 透過 API 抓取需要的資料首先創造 searchMovies function，在 button 添加 onSubmit attribute 指向剛才創造的function. 這個 function 要先將原本 onSubmit 預設的動作清除 (preventDefault) 加上我們想要的操作。在加上需要執行的代碼前，可以先簡單測試是否成功將預設的動作清除。 1234567//簡單測試const searchMovies = (e) =&gt;{ e.preventDefault() console.log(&quot;submitting&quot;) }&gt;&gt; submitting //如果成功清除會log出設定的字樣 使用 fetch 獲取資料的方法有兩種 : 使用 promise (.then .catch) &amp; async / await . 這裡使用 async / await 的方式來操作。 API的組成如下，當中的搜索方式，TMDB 提供了了三種：search / discover /find，各有不同的功能，詳細的可以查看官方文件。 除了成功取得資料外，亦要考慮無法獲得資料的情況。因此可以使用 try catch 來做 error handling.在還沒獲取用戶輸入的資料前，可以先設置query來測試 API 是否運作順利。 123456789101112131415161718const API_KEY = process.env.REACT_APP_API_KEYconst searchMovies = async (e) =&gt;{ e.preventDefault() console.log(&quot;submitting&quot;) const query = &quot;Jurassic Park&quot; //測試用，query應是用戶輸入的資料 const url = `https://api.themoviedb.org/3/search/movie/?api_key=${API_KEY}&amp;language=en-US&amp;query=${query}` try{ //成功的情況 const res = await fetch(url) const data = await res.json() console.log(data) }catch(err){ //失敗的情況 console.error(err) } } 成功獲得資料的結果如下，搜尋 “Jurassic Park” 會出現15筆資料。我們需要的資料存在 results 裡。 使用 useState 更新 query在 input 內添加 value , value 為 {query}，即是用戶輸入的資訊。使用 useState 和useEffect 來更新 value 的值。const [query, setQuery] = useState(&quot;&quot;) query 為value 變數；setQuery 用來更新 query 的值；useState 內的則是query的初始值。在 input 中添加 onChange，使用 setQuery 更新 value 。 123456789const [query, setQuery] = useState(&quot;&quot;);&lt;input type = &quot;text&quot; name = &quot;query&quot; placeholder = &quot;Goziila vs Kong...&quot; value = {query} //添加value onChange ={(e) =&gt; setQuery(e.target.value)} //更新value/&gt; 使用 useState, useEffect 更新 movie (顯示給用戶的資料)獲得搜尋資料之後，需要將這些資料渲染到瀏覽器，因此需要一個 array 來存取這些資料。一樣先使用 useState 要設置 movies array，再用 useEffect 更新。把 movies array 更新成搜尋後獲得的資料。 1234567891011const [movies, setMovies] = useState([]) //movies是個arraytry{ const res = await fetch(url) const data = await res.json() setMovies(data.results) //把 movies array 更新成搜尋後獲得的資料 }catch(err){ console.error(err) }} 把搜尋結果呈現在畫面上 需要顯示在畫面上的資訊有：海報（poster_path），發行日期（release_date），電影簡介（overview），評分（vote_average）。可以用 movies array（裡面有剛才存進去的資料） 中調用我們需要的資料。使用 map 遍歷每一個搜尋結果，調用需要的資訊。 12345678910&lt;div className=&quot;card-list&quot;&gt; {movies.map(movie =&gt; ( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; //使用map都要加上key &lt;h3&gt;{movie.title}&lt;/h3&gt; //標題 &lt;p&gt;Release date: {movie.release_date}&lt;/p&gt; //發行日期 &lt;p&gt;OverView: {movie.overview}&lt;/p&gt; //簡介 &lt;p&gt;Rating: {movie.vote_average}&lt;/p&gt; //評分 &lt;/div&gt; ))}&lt;/div&gt; 海報照片有固定的 url 格式，改變的只有結尾的 poster_path ，因此只要更換最後這個部分就可以獲得海報連接。某些原本就沒有海報照片的電影會無法顯示，可以使用兩種方法解決這個狀況：直接篩掉沒有海報的電影或是顯示代替圖案。 1https://image.tmdb.org/t/p/[width size]/[poster_path] 方法1 : 直接篩掉沒有海報的電影 (.fliter) 12345678910&lt;div className=&quot;card-list&quot;&gt;//使用 .filter 只抓取 poster_path 為 true 的電影{movies.filter(movie =&gt; movie.poster_path).map(movie =&gt;( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title}/&gt; &lt;/div&gt; ))}&lt;/div&gt; 方法2 : 顯示代替圖案 (onError) 123456789101112&lt;div className=&quot;card-list&quot;&gt; {movies.map(movie =&gt; ( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title} //當url為null時，使用替代圖片 onError={(e)=&gt;{e.target.onerror = null; e.target.src=&quot;https://i.postimg.cc/3RpfrHDh/photo.png&quot;}} /&gt; &lt;/div&gt; ))}&lt;/div&gt; 多個頁面Movies 頁面抓取 10頁 Top rated 的電影。這裡頁面切換使用 material ui 的 Pagination 製作。在抓取需要的資料後，設置 page 的 state，默認為 1，即抓取第一頁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, {useState, useEffect} from 'react'import { Container, MovieCard } from &quot;../AllMovies/AllMovie_styles&quot;import CustomPagination from &quot;./CustomPagination&quot;import ContentModal from '../ContentModal/ContentModal'function AllMovies(){ const [ AllMovies, setAllMovies ] = useState([]) const [ page, setPage ] = useState(1) const API_KEY = process.env.REACT_APP_API_KEY const API_URL = &quot;https://api.themoviedb.org/3&quot; const all_movie_url = `${API_URL}/movie/top_rated?api_key=${API_KEY}&amp;language=en-US&amp;page=${page}` async function fetchAllMovies() { const res = await fetch(all_movie_url) const data = await res.json() setAllMovies(data) console.log(AllMovies.results) } useEffect(() =&gt; { fetchAllMovies() window.scroll(0,0) //回到最頂端 }, [page]) return( &lt;&gt; &lt;Container&gt; &lt;h2&gt;What to watch&lt;/h2&gt; {AllMovies.results &amp;&amp; AllMovies.results.map((movie) =&gt; ( //顯示的資料 &lt;MovieCard&gt; . . . &lt;/MovieCard&gt; ))} //傳入 CustomPagination component &lt;CustomPagination setPage={setPage}/&gt; &lt;/Container&gt; &lt;/&gt; )}export default AllMovies 在 Pagination component 裡處理頁面更新 page 的 state，將 page 更換成點擊的頁數，資料便會根據該頁數抓取那頁的資料。 CustomPagination.js12345678910111213141516171819202122import React from &quot;react&quot;import Pagination from &quot;@material-ui/lab/Pagination&quot;import styled from &quot;styled-components&quot;function CustomPagination({ setPage, numberOfPages = 10 }){ const handlePageChange = (page) =&gt; { setPage(page) window.scroll(0,0) } return( &lt;Pagination onChange={(e) =&gt; handlePageChange(e.target.textContent)} count={numberOfPages} //會顯示幾頁 shape=&quot;rounded&quot; hideNextButton hidePrevButton /&gt; )}export default CustomPagination 小結Search 頁面是第一個做的頁面，因此記錄得比較詳細，其他部分只記錄了一些沒有用過的功能。Live Demo 中無法點擊的部分是還沒做好的功能，裡面也還有 bug 還沒修好。 由於個別頁面和功能都是獨立做的，因此相似的功能會重複寫，架構也不是那麼清楚。之後有時間會把它再重新整理一下，筆記也會再同步更新。若有錯誤或是可以寫得更好的地方再麻煩各位大大指點 :) 參考資料Learn React in 1 Hour by Building a Movie Search AppMaterial UI Pagination","link":"/2021/04/17/0417-movie/"},{"title":"【實作記錄】Typing Speed Test | React","text":"Live DemoGithub 簡介Typing Speed Test App 有基本的倒數計算字數的功能。運用了 React Hook 的 useState, useEffect 以及 useRef. 最後把 hook 獨立出來，讓程式碼易讀性更高。完整的程式碼附在文末。 功能 點擊按鈕開始計時，開始後無法再點擊按鈕 倒數結束，textarea 無法再輸入 字數與單個字數隨著用戶輸入不停更新 步驟基本設置設置基本樣式，包含輸入的地方 (textarea)、倒數器、每分鐘打了幾個字、每分鐘輸入了幾個字母、開始按鈕 (button). 增加 state 為 textarea 增加 state 用戶在輸入的時候，textarea 的 value 產生改變 App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, { useState } from &quot;react&quot;import './App.css';import &quot;./index.css&quot;//增加 statefunction App() { const [text, setText] = useState(&quot;&quot;) function handleChange(e){ const {value} = e.target setText(value) } return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;head&quot;&gt; &lt;header&gt; &lt;p className=&quot;subtile&quot;&gt;TYPING SPEED TEST&lt;/p&gt; &lt;h1&gt;How &lt;span&gt;fast&lt;/span&gt; do you type?&lt;/h1&gt; &lt;/header&gt; &lt;div className=&quot;result&quot;&gt; &lt;div className=&quot;time&quot;&gt; &lt;p className=&quot;num&quot;&gt;60&lt;/p&gt; &lt;p&gt;seconds&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;words&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;0&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;words/min&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;chars&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;0&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;chars/min&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;textarea className=&quot;area&quot; value={text} type=&quot;text&quot; name=&quot;typingArea&quot; onChange={handleChange} placeholder={&quot;Tales from the Galaxy’s Edge put players in the role of a droid-repair technician who crash landed on Batuu following a pirate attack.} /&gt; &lt;button type=&quot;submit&quot;&gt;Start&lt;/button&gt; &lt;p&gt;{text}&lt;/p&gt; //測試是否有成功增加 &lt;/div&gt; );}export default App; 算字數和單個字母 以空格分開，把輸入的字存進 array 裡，最後返回 array 的長度 字母同理 App.js12345678function wordsCount(keyInText){ const wordsArr = text.trim().split(&quot; &quot;) if (text !== &quot;&quot;){ return wordsArr.length }else{ return 0 }} 倒數計時器 使用 useEffect 搭配 setTimeout 處理 倒數開始：按下 start button 後 &amp; 當秒數大於 0 時 倒數結束：isTimeRunning state 要回到 false App.js123456789101112131415const [seconds, setSeconds] = useState(10)const [isTimeRunning, setisTimeRunning] = useState(false)useEffect(() =&gt; { if (isTimeRunning &amp;&amp;seconds &gt; 0){ setTimeout(() =&gt; { setSeconds(prevsec =&gt; prevsec - 1) }, 1000) }else if (seconds === 0){ setisTimeRunning(false) } },[seconds, isTimeRunning]) &lt;button onClick={() =&gt; setisTimeRunning(() =&gt; true)}&gt;Start&lt;/button&gt; Result 同步更新 用戶一遍輸入，result 一遍更新 App.js123456789const [word, setWord] = useState(0)const [char, setChar] = useState(0)function countingWords(){ setWord(wordsCount(text)) setChar(charsCount(text)) }useEffect(countingWords,[text]) 遊戲開始/進行時 StartGame() : 遊戲開始時初始化所有東西 useRef : 可以在不重新 Render 的狀況下更新值 遊戲開始時，自動 focus textarea, 用戶不用點擊就能開始打字 因為在 textarea 中設定了計時器尚開始前，處在 disabled 的狀態 所以如果只寫 textboxRef.current.focus()，其實是 focus 在 disabled 的狀態，點擊開始時不會自動 focus textarea 可以加上一行 textboxRef.current.disabled = false 解決這個問題 App.js123456789const STARTING_TIME = 60function startGame(){ setSeconds(STARTING_TIME) setIsTimeRunning(true) setText(&quot;&quot;) textboxRef.current.disabled = false textboxRef.current.focus() } button disabled : 遊戲進行時(計時器開始後)，button 無法點擊 App.js1&lt;button onClick={startGame} disabled={isTimeRunning}&gt;Start&lt;/button&gt; textarea disabled : 遊戲結束時(計時器結束時)， textarea 不能再輸入 App.js12345678&lt;textarea className=&quot;area&quot; value={text} type=&quot;text&quot; name=&quot;typingArea&quot; onChange={handleChange} disabled={!isTimeRunning} ref={textboxRef}/&gt; custom hook首先把原本在 App.js 建立好的各個 function 拆出放到另一個檔案（useWordGame.js），在這個檔案中要定義 custom hook. （參考下面完整的程式碼）把其他 component 需要用到的值或是 function 回傳。 useWordGame.js1return {seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame} App.js 中需要使用到的值以及 function 就可以使用剛剛定義好的 hooks, 就跟使用其他 hooks 一樣，接著就可以運用這些值 / function 了。 App.js1const { seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame } = useWordGame() 總結有好幾個需要的功能還沒放進去，先在這裡留個記錄，之後有機會再回來補。但經過這個小練習，也更熟悉 hook 的基本用法，希望之後可以挑戰更難得耶耶。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬 參考資料Hooks API Reference : useRef【Day 24】 useRef 完整程式碼App.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React from &quot;react&quot;import useWordGame from &quot;./useWordGame&quot; import &quot;./index.css&quot;function App() { const { seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame } = useWordGame() const article = &quot;Tales from the Galaxy’s Edge put players in the role of a droid-repair technician who crash landed on Batuu following a pirate attack. Upon entering a cantina owned by Seezelslak (played by Saturday Night Live’s and Star Wars Resistance’s Bobby Moynihan), players were swept up into an adventure that found them exploring Batuu and interacting with Star Wars characters new and classic. Part II looks to expand on that, starting with Dok-Ondar.&quot; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;head&quot;&gt; &lt;header&gt; &lt;p className=&quot;subtile&quot;&gt;TYPING SPEED TEST&lt;/p&gt; &lt;h1&gt;How &lt;span&gt;fast&lt;/span&gt; do you type?&lt;/h1&gt; &lt;/header&gt; &lt;hr/&gt; &lt;div className=&quot;result&quot;&gt; &lt;div className=&quot;time&quot;&gt; &lt;p className=&quot;num&quot;&gt;{seconds}&lt;/p&gt; &lt;p&gt;seconds&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;words&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;{word}&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;words/min&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;chars&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;{char}&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;chars/min&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;p className=&quot;article&quot;&gt;{article}&lt;/p&gt; &lt;textarea className=&quot;area&quot; value={text} type=&quot;text&quot; name=&quot;typingArea&quot; onChange={handleChange} disabled={!isTimeRunning} ref={textboxRef} placeholder={&quot;Start your test now!&quot;} /&gt; &lt;button onClick={startGame} disabled={isTimeRunning} &gt; Start &lt;/button&gt; &lt;/div&gt; );}export default App; useWordGame.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import { useState, useEffect, useRef } from &quot;react&quot;function useWordGame(){ const STARTING_TIME = 60 const [text, setText] = useState(&quot;&quot;) const [seconds, setSeconds] = useState(STARTING_TIME) const [isTimeRunning, setIsTimeRunning] = useState(false) const [word, setWord] = useState(0) const [char, setChar] = useState(0) const textboxRef = useRef(null) //input 改變 function handleChange(e){ const {value} = e.target setText(value) } //計算word function wordsCount(keyInText){ const wordsArr = text.trim().split(&quot; &quot;) if (text !== &quot;&quot;){ return wordsArr.length }else{ return 0 } } //計算character function charsCount(keyInText){ const charsArr = text.trim().split(&quot;&quot;) if (text !== &quot;&quot;){ return charsArr.length }else{ return 0 } } //遊戲開始 function startGame(){ setSeconds(STARTING_TIME) setIsTimeRunning(true) setText(&quot;&quot;) textboxRef.current.disabled = false textboxRef.current.focus() } function countingWords(){ setWord(wordsCount(text)) setChar(charsCount(text)) } //倒數 useEffect(() =&gt; { if (isTimeRunning &amp;&amp;seconds &gt; 0){ setTimeout(() =&gt; { setSeconds(prevsec =&gt; prevsec - 1) }, 1000) } else if (seconds === 0){ setIsTimeRunning(false) } },[seconds, isTimeRunning]) useEffect(countingWords,[text]) return {seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame}}export default useWordGame","link":"/2021/04/24/0424-typing-speed-test/"},{"title":"【學習筆記】 Context | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 簡介React 中的 component 傳遞是由上往下的，無法在同級的 component 間 / 在其他的分支間傳遞。如果要在同級間傳遞，就要將 state 提升到上一層 component，如果在不同分支，就要一直往上提升到兩個 component 間都有共用的為止。往上提升後，再把 props 一層一層往下傳，傳到天荒地老。 Context 可以解決這種狀況。提供資料的稱為 Provider ，使用資料的為 Consumer。把需要共用的資料包在 Provider 裡，需要調用資料的用 Comsumer 包起來。Consumer 不用通過中間一層一層的傳遞，就可以直接使用 Provider 中的資料。除了 Data , Method 也可以通過這個方法傳遞，如果當某個 components 更新後，需要同時將共用這個 method 的 component 一併更新也可以做到。 使用方式用 Provider 把 包起來123456//創造 contextconst Context名字 = React.createContext() &lt;Context名字.Provider value={&quot;dark&quot;}&gt; //value 是必要的 &lt;App /&gt;&lt;/Context名字.Provider&gt; Consumer 調用 dataclass component 方法一 : 在component 外引用1234需要引用資料的 component.contextType = 被創造的 provider//例子Button.contextType = ThemeContext 方法二 : 在 conponent 內引用 ( render() 前)1234static contextType = 被創造的 provider//例子static contextType = ThemeContext function component 123&lt;Context名字.Consumer&gt; function&lt;/Context名字.Consumer&gt; 使用 &lt;Context名字.Consumer&gt; 包起來，裡面必須要是 function 是 render props pattern 🌰 栗子 : 使用 context 處理點擊 button 後轉換主題的效果 基本的 context 架構123456789101112131415161718// filename : App.js// 引入 Header 以及 Button import React from &quot;react&quot;import Header from &quot;./Header&quot;import Button from &quot;./Button&quot;function App() { return ( &lt;div&gt; &lt;Header /&gt; &lt;Button /&gt; &lt;/div&gt; )}export default App 123456// filename : ThemeContext.js// 創造 contextimport React from &quot;react&quot;const ThemeContext = React.createContext()export default ThemeContext 1234567891011121314151617// filename : index.js// 使用 context providerimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import ThemeContext from &quot;./ThemeContext&quot;ReactDOM.render( //使用theme context 的 method, Provider 沒有自己的component //後續會提到怎麼處理 &lt;ThemeContext.Provider value={&quot;dark&quot;}&gt; &lt;App /&gt; &lt;/ThemeContext.Provider&gt;, document.getElementById('root')) 1234567891011121314151617// filename : Button.js// 使用 context consumer + 簡單的判斷處理import React from &quot;react&quot;import ThemeContext from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;button className={`${theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContext.Consumer&gt; ) }export default Button 12345678910111213141516171819// filename : Header.js// 使用 context consumer + 簡單的判斷處理import React from &quot;react&quot;import ThemeContext from &quot;./ThemeContext&quot;function Header (){ return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;header className={`${theme}-theme`}&gt; &lt;h2&gt;{theme === &quot;light&quot; ? &quot;Light&quot; : &quot;Dark&quot;} Theme&lt;/h2&gt; &lt;/header&gt; )} &lt;/ThemeContext.Consumer&gt; )} export default Header 截至這裡，效果如下。如果將 &lt;ThemeContext.Provider value={&quot;dark&quot;}&gt; 更換成 “light” 就會是 Light Theme. 現在要添加 switch button 切換主題的功能。如果要實現這個功能，需要使用到 state ，但現在 Context Provider 沒有自己的 component，因此要處理這個部分。 把 Context Provider 移到自己的 component現在要把 Context Provider 移到自己的 component，後續才能在該 component 裡處理 state. 123456// 原本的// filename : ThemeContext.jsimport React from &quot;react&quot;const ThemeContext = React.createContext()export default ThemeContext 1234567891011121314151617// 調整後// filename : ThemeContext.jsimport React, { Component } from &quot;react&quot;const {Provider, Consumer} = React.createContext()class ThemeContextProvider extends Component { render() { return ( &lt;Provider value={&quot;light&quot;}&gt; {this.props.children} &lt;/Provider&gt; ) }}export {ThemeContextProvider, Consumer as ThemeContextConsumer} 第 7 行 : 創造 ThemeContextProvider component, 這個 component 是之後要在 index.js 中被引用的。index.js 中引入的是 &lt;ThemeContext.Provider&gt; , 所以才這個 component 中要放入 &lt;ThemeContext.Provider&gt;. 第 11 行 : 確保所有 children 都會被 render. 第 5 行 : ThemeContext 本身就帶有 ThemeContext.Provider 以及 ThemeContext.Consumer，因此可以寫成 {Provider, Consumer}, 第 10 行 : 同時 return 內的 &lt;ThemeContext.Provider&gt; 就可以只寫成 &lt; Provider &gt;. 第 12 行 : 要把 ThemeContextProvider export 出去，但不能只寫 export default ThemeContextProvider , 這樣只會 export 這個 component. Header.js &amp; Button.js 會用到 ThemeContext，因此要把兩個都 export 出去。 第 17 行 : 在export 時，除了 ThemeContextProvider , Consumer 會以 ThemeContextConsumer export 出去。 由於 ThemeContext.js 中 export 出去的東西改變了，因此其他文件中也要修改。修改完後，結果會與上面的一樣。 1234567891011121314151617//filename : Button.js//Header.js &amp; index.js 同理import React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContextConsumer&gt; {theme =&gt; ( &lt;button className={`${theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContextConsumer&gt; ) }export default Button 修改 context : 增加 state 在 ThemeContext.js 中增加 state 以及轉換 theme 的 function 123456789101112131415161718192021222324252627282930//filename : ThemeContext.jsimport React, { Component } from &quot;react&quot;const {Provider, Consumer} = React.createContext()class ThemeContextProvider extends Component { //增加 state state = { theme : &quot;light&quot; } //增加轉換的 function toggleTheme = () =&gt;{ this.setState(prevstate =&gt;{ return{ theme : prevstate.theme === &quot;light&quot; ? &quot;dark&quot;:&quot;light&quot; } }) } render() { return ( &lt;Provider value={{theme: this.state.theme, toggleTheme: this.toggleTheme}}&gt; //value 可以傳 object {this.props.children} &lt;/Provider&gt; ) }}export {ThemeContextProvider, Consumer as ThemeContextConsumer} 把 state 和 function toggleTheme 連接到 Button.js, Header.js 中 1234567891011121314151617//filename : Button.jsimport React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContextConsumer&gt; {context =&gt; ( &lt;button onClick={context.toggleTheme} className={`${context.theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContextConsumer&gt; ) }export default Button 12345678910111213141516171819//filename : Header.jsimport React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Header (){ return ( &lt;ThemeContextConsumer&gt; {context =&gt; ( &lt;header className={`${context.theme}-theme`}&gt; &lt;h2&gt;{context.theme === &quot;light&quot; ? &quot;Light&quot; : &quot;Dark&quot;} Theme&lt;/h2&gt; &lt;/header&gt; )} &lt;/ThemeContextConsumer&gt; )} export default Header 🌰 另一個栗子 : 使用 context 處理讓用戶更換 username 基本的 context 架構123456//filename : UserContext.jsimport React from &quot;react&quot;//創造 contextconst UserContext = React.createContext()export default UserContext 123456789101112131415//filename : index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &quot;./index.css&quot;import App from &quot;./App&quot;import UserContext from &quot;./userContext&quot;ReactDOM.render(//把 &lt;App/&gt; 包起來 &lt;UserContext.Provider value={&quot;Luke Skywalker&quot;}&gt; &lt;App /&gt; &lt;/UserContext.Provider&gt;, document.getElementById(&quot;root&quot;)) 123456789101112131415161718192021222324252627//filename : App.js//class componentimport React from &quot;react&quot;import Header from &quot;./Header&quot;import UserContext from &quot;./userContext&quot;class App extends React.Component { //引用 static contextType = UserContext render() { // 調用 this.context // this.context 是 index.js &lt;ThemeContext.Provider&gt;傳進來的 value const username = this.context return ( &lt;div&gt; &lt;Header /&gt; &lt;main&gt; &lt;p className=&quot;main&quot;&gt;No new notifications, {username}! 🎉&lt;/p&gt; &lt;/main&gt; &lt;/div&gt; ) }}export default App 12345678910111213141516171819//filename : Header.js//function componentimport React, {Component} from &quot;react&quot;import UserContext from &quot;./userContext&quot;function Header(props){ //傳進 props return( &lt;UserContext.Consumer&gt; //裡面要包 function {username =&gt; ( &lt;header&gt; &lt;p&gt;Welcome, {username}!&lt;/p&gt; &lt;/header&gt; )} &lt;/UserContext.Consumer&gt; )} export default Header 增加功能123456789101112131415//filename :index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &quot;./index.css&quot;import App from &quot;./App&quot;import {UserContextProvider} from &quot;./userContext&quot;ReactDOM.render( &lt;UserContextProvider&gt; &lt;App /&gt; &lt;/UserContextProvider&gt;, document.getElementById(&quot;root&quot;)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344//filename : App.jsimport React from &quot;react&quot;import Header from &quot;./Header&quot;import {UserContextConsumer} from &quot;./userContext&quot;class App extends React.Component { state = { newUsername: &quot;&quot; } handleChange = (e) =&gt; { const {name, value} = e.target this.setState({[name]: value}) } render() { return ( &lt;div&gt; &lt;Header /&gt; &lt;UserContextConsumer&gt; {({username, changeUsername}) =&gt; ( &lt;main&gt; &lt;p className=&quot;main&quot;&gt;No new notifications, {username}! 🎉&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;newUsername&quot; placeholder=&quot;New username&quot; value={this.state.newUsername} onChange={this.handleChange} /&gt; &lt;br/&gt; &lt;button onClick={() =&gt; changeUsername(this.state.newUsername)}&gt;Change Username&lt;/button&gt; &lt;/main&gt; )} &lt;/UserContextConsumer&gt; &lt;/div&gt; ) }}export default App 1234567891011121314151617181920212223242526//filename : userContext.jsimport React, { Component } from &quot;react&quot;const { Provider, Consumer } = React.createContext()class UserContextProvider extends Component { state = { username: &quot;Luke Skywalker&quot; } changeUsername = (username) =&gt; { this.setState({username}) } render () { const {username} = this.state return ( &lt;Provider value={{username, changeUsername : this.changeUsername}}&gt; {this.props.children} &lt;/Provider&gt; ) }}export { UserContextProvider, Consumer as UserContextConsumer } 1234567891011121314151617//filename : Header.jsimport React from &quot;react&quot;import {UserContextConsumer} from &quot;./userContext&quot;function Header(){ return ( &lt;header&gt; &lt;UserContextConsumer&gt; {({username}) =&gt; ( &lt;p&gt;Welcome, {username}!&lt;/p&gt; )} &lt;/UserContextConsumer&gt; &lt;/header&gt; ) } export default Header 特別情況小栗子 🌰 相同的 component 一個受 Provider 影響，另一個不 不在該 component 本身處理 context 可以在引入該 component 的地方做 123456789101112131415161718192021222324252627//filename : App.jsimport React from &quot;react&quot;import Header from &quot;./Header&quot;import Button from &quot;./Button&quot;import ThemeContext from &quot;./ThemeContext&quot;function App() { return ( &lt;div&gt; &lt;Header /&gt; //這個 button 引用 Provider 資料 &lt;ThemeContext.Consumer&gt; {theme =&gt;( &lt;Button theme={theme}/&gt; )} &lt;/ThemeContext.Consumer&gt; // 這個 button 不引用 &lt;Button theme=&quot;light&quot;/&gt; &lt;/div&gt; )}export default App 123456789101112131415161718192021//filename : button.jsimport React from &quot;react&quot;import PropTypes from &quot;prop-types&quot;import ThemeContext from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;button className={`${props.theme}-theme`}&gt;Switch Theme&lt;/button&gt; ) }Button.propTypes = { //用來限定傳入的 value 局限於這兩個選擇 theme: PropTypes.oneOf([&quot;light&quot;, &quot;dark&quot;])}Button.defaultProps = { theme: &quot;light&quot;}export default Button 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬 參考資料上下文(Context)聊一聊我对 React Context 的理解以及应用","link":"/2021/04/23/0423-note-context/"},{"title":"【實作記錄】Netflix Clone | React","text":"Live DemoGithub 簡介這是一個模仿 netlfix 製成的網站，還原的部分有首頁、登入頁、選擇用戶、系列列表、分類列表、每張卡片的詳細資訊。 底下附上每一個 part 的製作過程， style 部分則不會全部記在筆記裡，主要記錄架構以及邏輯。 使用到的技術 使用 Coumpound Component 以及 Styled Component 使用 Firebase 儲存電影資料以及驗證用戶登入 使用 Fuse.js 出裡搜索功能 功能 頁面 : Home, sign in, sign up , browser Home : 訂閱 bar、簡介、常見問題 Sign in / Sign up : 使用 firebase 驗證登入 Browser : 進入電影列表前可以選擇用戶 Browser : 可以選擇 Series/ Films 兩個頁面 Browser : Series / Films 各有 4-5 個類別 Browser : 類別裡的卡片可以點擊，會出現該影片的詳細資訊以及播放按鈕 Browser : 點擊播放按鈕會出現播放器 Browser : 有搜尋功能 前置作業 下載 react-router-dom 1$ npm install --save react-router-dom styled-components 1$ npm i styled-components fuse.js 1$ npm install --save fuse.js 基本設置這個專案會使用到 compound component 以及 styled component.首先創建需要的資料夾以及基本文件設置。 App.js 中設置 router ，作換頁用 需要 4 個頁面 : 主頁、sign in 、sign up 、browser App.js 中的 routes 最後有更動 App.js1234567891011121314151617181920212223242526272829import React from 'react'import { Switch, Route } from 'react-router-dom'import Home from &quot;./pages/Home&quot;function App() { return ( &lt;Switch&gt; &lt;Route path=&quot;/signin&quot;&gt; &lt;p&gt;Sign in page&lt;/p&gt; &lt;/Route&gt; &lt;Route path=&quot;/signup&quot;&gt; &lt;p&gt;Sign up page&lt;/p&gt; &lt;/Route&gt; &lt;Route path=&quot;/browse&quot;&gt; &lt;p&gt;browse page&lt;/p&gt; &lt;/Route&gt; &lt;Route path=&quot;/&quot;&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; 步驟Netflix Clone : 首頁首頁由 5 個部分組成：Header 首頁大圖、Jumbotron 資訊塊、Accordion 常見問題、Otp form 訂閱表單、Footer 頁尾。每一塊都為單獨的component，組合起來後才渲染到瀏覽器。每一個 component 的創建邏輯相似：創建需要的元件 &gt; 創建組裝元件的 container，把需要的元件排進去 &gt; 添加樣式。 分開創建 component 除了便於維護外，最大的功能在於可以重複使用，就如 part 4 的 Opt form 在 part 5 的 header 中可以直接套用。 Netflix Clone : 用戶登入頁用戶登入包括了 sign in 和 sign up 兩個頁面。都使用了 firebase 的 auth 功能處理。Firebase 會幫忙驗證 email 和 password 的合法性。最後也會處理只有登入的用戶才能瀏覽 browser 頁的功能。真的是 hen 方便。 Netflix Clone : Browser 頁Browser 頁處理的東西比較多：用戶 Profile 選擇、首頁大圖、每列分類以及卡片、卡片詳細資訊、播放器、搜尋功能、sign out 功能。series 以及 films 的資料都存在 firestore 裡，之後有餘力會再多增加幾筆資料做換頁效果。 Netflix Clone : 最後整理最後是用戶登入的 auth 以及網頁的路徑。在用戶尚未登入前不能瀏覽 browser 頁面。 總結這個專案的過程都有詳細記錄下來，是希望之後如果需要類似的功能可以回來看看，希望到時候還記得寫了什麼東西（有多金魚腦）。這次小專案還是參考教學影片做的，但還是會吃力唉唉，像是在處理 firebase 的時候都要多花時間去看，但感覺還是沒那麼熟悉，下次再找專案玩玩看。從中學到了很多沒有學過的東西，也對 react 的邏輯和寫法更熟練了一些，但要說完全透徹還說不上。 第一次碰到 compound component 和 styled component, 是一個 all in JS 的寫法。這樣的寫法在多頁式的網頁中很方便，component 都可以互相使用，需要額外的功能就再往上加就可以了。Styled component 頗方便的地方在可以傳入變數和可以在 JS 裡設定樣式，selector 也還算容易理解。資料的處理則是存放在 firestore 裡，需要的時候再調用。 每一個地方都有小小相似和不相似的地方，怎麼去融會貫通和運用類似的概念也有好好練習了。再來是 Google 的能力，文件/技術更換得很快除了看文件外，下對關鍵字也很重要（淚），相似的問題可能其他人也遇過。 東西對我而言都是新的，參數傳來傳去，這裡加來加去、套來套去有時候找不到 bug 會很阿雜，但找到後/完成一個功能成就感會爆棚。完整這個專案可以補充一天半份的開心。最後，文章內有觀念不對或是其他錯誤，請各位大大指教，謝謝！（鞠躬 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/02/0502-netflix-clone-1/"},{"title":"【實作記錄】Netflix Clone：最後整理","text":"Live DemoGithub 簡介最後是用戶登入的 auth 以及網頁的路徑。在用戶尚未登入前不能瀏覽 browser 頁面。 經過前面幾個 part，component 以及基本的功能都處理完畢。最後就可以收尾啦。 Custom Auth Listener Hook use-auth-listener (hooks) >folded12345678910111213141516171819202122232425import { useState, useEffect, useContext } from &quot;react&quot;import { FirebaseContext } from &quot;../context/firebase&quot;function useAuthListener() { const [user, setUser] = useState() const { firebase } = useContext(FirebaseContext) useEffect(() =&gt; { const listener = firebase.auth().onAuthStateChanged((authUser) =&gt; { if (authUser) { localStorage.setItem(&quot;authUser&quot;, JSON.stringify(authUser)) setUser(authUser) } else { localStorage.removeItem('authUser') setUser(null) } }) return () =&gt; listener() }, []) return { user }}export default useAuthListener App.js >folded123456789101112131415161718192021222324252627282930313233import React from 'react'import { Switch, Route } from 'react-router-dom'import * as ROUTES from './constants/routes';import { Home, Signin, Signup, Browse } from &quot;./pages&quot;import { useAuthListener } from &quot;./hooks&quot;function App() { const { user } = useAuthListener() return ( &lt;Switch&gt; &lt;Route path={ROUTES.SIGN_IN}&gt; &lt;Signin /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.SIGN_UP}&gt; &lt;Signup /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.BROWSE}&gt; &lt;Browse /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; Modifying Our App Routes to Be Protected確保用戶在登陸之後才能瀏覽頁面，如果直接跳到 browse 頁面，會將用戶導回 sign in page. routes.js (helpers) >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';import { Route, Redirect } from 'react-router-dom';export function IsUserRedirect({ user, loggedInPath, children, ...restProps }) { return ( &lt;Route {...restProps} render={() =&gt; { if (!user) { return children; } if (user) { return ( &lt;Redirect //to 後面要接 2 個括號 to={ pathname: loggedInPath, } /&gt; ) } return null }} /&gt; )}export function ProtectedRoute({ user, children, ...restProps }) { return ( &lt;Route {...restProps} render={({ location }) =&gt; { if (user) { return children; } if (!user) { return ( &lt;Redirect//to 後面要接 2 個括號 to={ pathname: 'signin', state: { from: location }, } /&gt; ) } return null }} /&gt; )} App.js >folded1234567891011121314&lt;Switch&gt; &lt;IsUserRedirect user={user} loggedInPath={ROUTES.BROWSE} path={ROUTES.SIGN_IN}&gt; &lt;Signin /&gt; &lt;/IsUserRedirect&gt; &lt;IsUserRedirect user={user} loggedInPath={ROUTES.BROWSE} path={ROUTES.SIGN_UP}&gt; &lt;Signup /&gt; &lt;/IsUserRedirect&gt; &lt;ProtectedRoute user={user} path={ROUTES.BROWSE}&gt; &lt;Browse /&gt; &lt;/ProtectedRoute&gt; &lt;IsUserRedirect user={user} loggedInPath={ROUTES.BROWSE} path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/IsUserRedirect&gt;&lt;/Switch&gt; 參考資料設置身份驗證狀態觀察器並獲取用戶數據 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/11/0511-netflix-clone-5/"},{"title":"【實作記錄】Netflix Clone：首頁","text":"Live DemoGithub 簡介首頁由 5 個部分組成：Header 首頁大圖、Jumbotron 資訊塊、Accordion 常見問題、Otp form 訂閱表單、Footer 頁尾。每一塊都為單獨的component，組合起來後才渲染到瀏覽器。每一個 component 的創建邏輯相似：創建需要的元件 &gt; 創建組裝元件的 container，把需要的元件排進去 &gt; 添加樣式。 分開創建 component 除了便於維護外，最大的功能在於可以重複使用，就如 part 4 的 Opt form 在 part 5 的 header 中可以直接套用。 Part 1 : Jumbotron 資訊塊 + Global style 在首頁裡一共有 3 個 Jumbotron，其組成有：照片、標題、副標題。會先創需要的元件，再將他們放進 container 裡，最後進行樣式調整。 樣式部分不會全部都放在筆記裡，主要記下架構邏輯的部分。 創建基本檔案 components &gt; jumbotron &gt; index.js : 處理 Jumbotron components &gt; jumbotron &gt; styles &gt; jumbotron.js : 引入 styled ，在裡面處理 styled component Home.js : 首頁大圖會出現的地方 containers &gt; jumbotron.js index.js 中創立 jumbotron 需要的所有元件：container, title, subtitle, Image 和後來添加的 pane. index.js (Component > Jumbotron) >folded1234567891011121314151617181920212223242526272829303132import React from &quot;react&quot;import { Item, Inner, Container, Title, Subtitle } from &quot;./styles/Jumbotron&quot;function Jumbotron({ children, direction = &quot;row&quot;, ...restProps }){ return ( &lt;Item {...restProps}&gt; &lt;Inner direction={direction}&gt;{children}&lt;/Inner&gt; &lt;/Item&gt; )}Jumbotron.Container = function JumbotronContainer({ children, ...restProps }){ return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; }Jumbotron.Title = function JumbotronTitle({ children, ...restProps }){ return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt; }Jumbotron.SubTitle = function JumbotronSubTitle({ children, ...restProps }){ return &lt;Subtitle {...restProps}&gt;{children}&lt;/Subtitle&gt; }Jumbotron.Pane = function JumbotronPane({ children, ...restProps }){ return &lt;Pane {...restProps}&gt;{children}&lt;/Pane&gt; }Jumbotron.Image = function JumbotronSubTitle({ ...restProps }){ return &lt;Image {...restProps}/&gt;}export default Jumbotron 第 4 行 : 引入 Jumbotron.js 中設定的每個區塊 第 6 行 : 創建一個會傳入 children , direction (jumbo.json中有出現的) 以及剩餘的 props 參數的 function. 第 7 -12 行 : 這個 function 會返回一個 &lt; Item&gt;, 他的 children 是 &lt; Inner&gt;， &lt; Inner &gt; 的 children 可以是下面的 container/ title/ subtitle 第 14 行 : 創造新的變數，這個變數是一個 function，傳入的參數為 children 以及剩餘的 props. 後返回一個 &lt; Container &gt; element. 第 15 行 : &lt; Container &gt; element 傳入的參數說所有的 props, children 為 children 應該會是字串，顯示在熒幕上的字等等的 比如說 Home.js 中的 &lt; Jumbotron.Title &gt; 包的東西就是 &lt; Title &gt; 的children Home.js (Pages) >folded12345678910111213// filename : Home.js (Pages)import React from 'react'import Jumbotron from '../components/jumbotron'export default function Home() { return ( &lt;Jumbotron.Container&gt; &lt;Jumbotron.Title&gt;Hello&lt;/Jumbotron.Title&gt; &lt;Jumbotron.SubTitle&gt;Huala&lt;/Jumbotron.SubTitle&gt; &lt;/Jumbotron.Container&gt; )} 第 4 行 : 引入上面建立好的 Jumbotron 第 8 行 : 可以直接使用 index.js 中創造好的變數 把首頁需要的資訊渲染到畫面上 把在 Home.js 中的 container component 移到另一個檔案 : Jumbotron.js ( container &gt; Jumbotron.js），再引入 Home.js 中 jumbotron.js (Containers > jumbotron.js) >folded12345678910111213141516171819202122232425262728// filename : jumbotron.js (Containers &gt; jumbotron.js)import React from &quot;react&quot;import Jumbotron from &quot;../components/jumbotron&quot;import jumboData from &quot;../fixtures/jumbo.json&quot;function JumbotronContainer(){ return( &lt;Jumbotron.Container&gt; {jumboData.map((item) =&gt; ( // 會使用 index.js 中的 Jumbotron function 作為模板，title/subtitle這類的會變成children &lt;Jumbotron key={item.id} direction={item.direction}&gt; &lt;Jumbotron.Pane&gt; //style component 需要的，為標題和照片增加padding &lt;Jumbotron.Title &gt;{item.title}&lt;/Jumbotron.Title&gt; &lt;Jumbotron.SubTitle&gt;{item.subTitle}&lt;/Jumbotron.SubTitle&gt; &lt;/Jumbotron.Pane&gt; &lt;Jumbotron.Pane&gt; &lt;Jumbotron.Image src={item.image} alt={item.name}&gt;&lt;/Jumbotron.Image&gt; &lt;/Jumbotron.Pane&gt; &lt;/Jumbotron&gt; ))} &lt;/Jumbotron.Container&gt; )}export { JumbotronContainer } jumbo.json ( fixtures > jumbo.json ) >folded1234567891011// filename : jumbo.json ( fixtures &gt; jumbo.json )//裡面共有三筆資料，每筆資料長這樣 { &quot;id&quot;: 1, &quot;title&quot;: &quot;Enjoy on your TV.&quot;, &quot;subTitle&quot;: &quot;Watch on smart TVs, PlayStation, Xbox, Chromecast, Apple TV, Blu-ray players and more.&quot;, &quot;image&quot;: &quot;/images/misc/home-tv.png&quot;, &quot;alt&quot;: &quot;Tiger King on Netflix&quot;, &quot;direction&quot;: &quot;row&quot; //styled &gt; jumbotron.js 中會用到} 設計首頁每一個 Jumbotron 需要 title、Subtitle、Image Jumbotron.js (Component > Jumbotron > styles) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// filename : Jumbotron.js (Component &gt; Jumbotron &gt; styles)// 處理 styled component，順便設置不同裝置熒幕尺寸import styled from 'styled-components'export const Inner = styled.div` display: flex; align-items: center; justify-content: space-between; flex-direction: ${({ direction }) =&gt; direction}; //根據jumbo.json 裡的 direction 改變 max-width: 1100px; margin: auto; width: 100%; @media(max-width: 1000px) { flex-direction: column; }`//標題和圖片間增加 paddingexport const Pane = styled.div` width : 50%; @media (max-width: 1000px) { width:100%; padding: 0 45px; text-alighn: center; }`export const Item = styled.div` display: flex; border-bottom: 8px solid #222; padding: 50px 5%; color: white; overflow: hidden;`//手機裝置最後一個 jumbotron 會太靠近底部，增加bottomexport const Container = styled.section` background-color: black; @media (max-width: 1000px) { ${Item}:last-of-type h2 { margin-bottom: 50px; } text-align: center; }`export const Title = styled.h1` font-size: 50px; line-height: 1.1; margin-bottom: 8px; @media (max-width: 600px) { font-size: 35px; }`export const SubTitle = styled.h2` font-size: 26px; font-weight: normal; line-height: normal; @media (max-width: 600px) { font-size: 18px; }`export const Image = styled.img` max-width: 100%; height: auto;` 整理 Component Library &amp; Implementing Global Styles With Styled Components Component Library 之後會有很多 component 要加進來，如果每次都單獨 import 檔案進來看起來就會冗冗的 在 index.js (Component) 把路徑設成 {Jumbotron} 之後要引用這個路徑就可以直接寫 Jumbotron 更改 jumbotron.js (containers) 的路徑 index.js (Component) >folded1export { default as Jumbotron } from './jumbotron'; jumbotron.js (containers) >folded1234// filename : jumbotron.js (containers)//原本的 : import Jumbotron from &quot;../components/jumbotron&quot;import { Jumbotron } from &quot;../components&quot; Global Styles 使用 styled component 會難以估計每個元件預設的值是多少 可以創建一個新的 conponent 來儲存 global 的樣式 這個 component 要加在最根部，進行渲染的那一頁 (index.js) filename : global-style.js >folded123456789101112131415// filename : &quot;global-style.js&quot;import { createGlobalStyle } from 'styled-components';export const GlobalStyles = createGlobalStyle` html, body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; background-color: #000000; color: #333333; font-size: 16px; margin: 0; }`; index.js >folded12345678910111213141516171819//filename : index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import { BrowserRouter } from &quot;react-router-dom&quot;import { GlobalStyles } from &quot;./global-style&quot; import &quot;./index.css&quot;import App from &quot;./App&quot;ReactDOM.render( &lt;&gt; &lt;GlobalStyles/&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/&gt;, document.getElementById('root')); Part 2 : Footer 頁尾 Footer 一共有 4 欄，其排版會使用 gird 來進行。在縮小的時候會先變成 3 欄 ，再變為兩欄。 創建基本檔案 components &gt; footer &gt; index.js : footer 會在裡面處理 components &gt; footer &gt; styles &gt; footer.js : 引入 styled ，在裡面處理 styled component containers &gt; footer.js 在 index.js (components 的) 添加 export { default as Footer } from './footer'; , 會在 footer.js (containers) 中引入 Home.js 中增加 footer container 建立需要的元件index.js 中創立 footer 需要的所有元件：container, row, column, title, link 和 break. index.js (conponents > footer) >folded12345678910111213141516171819202122232425262728293031323334//filename : index.js (conponents &gt; footer)import React from &quot;react&quot;import { Container, Row, Column, Link, Title, Break, Text } from &quot;./styles/footer&quot;function Footer({ children, ...restProps }) { return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt;}Footer.Row = function FooterRow({ children, ...restProps }) { return &lt;Row {...restProps}&gt;{children}&lt;/Row&gt;}Footer.Column = function FooterColumn ({ children, ...restProps }) { return &lt;Column {...restProps}&gt;{children}&lt;/Column&gt;} Footer.Link = function FooterLink({ children, ...restProps }) { return &lt;Link {...restProps}&gt;{children}&lt;/Link&gt;}Footer.Title = function FooterTitle({ children, ...restProps }) { return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Footer.Text = function FooterText({ children, ...restProps }) { return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}Footer.Break = function FooterBreak ({ ...restProps }) { return &lt;Break {...restProps}/&gt;} export { FooterContainer } 第 4 行 : 引入 styled component 第 6 行 : 設置 Footer container, children 是下面的一大串 (row, column…) 第 10 行 : 設置 Row function ,會傳入 children 和其他 props, return &lt; Row &gt;，其他的同理 第 30 行 : 排版的時候會用到空行，所以這裡設置 break component，排版的時候就可以用 處理 footer links把每一個需要的鏈接都放在 container 裡. 因為使用 grid 所以需要 Column 和 Row. footer.js (containers > footer.js) >folded12345678910111213141516171819202122232425262728293031// filename : footer.js (containers &gt; footer.js)// 處理 footer links 的部分import React from &quot;react&quot;import { Footer } from &quot;../components&quot;//這裡在 index.js (components) 處理過了function FooterContainer() { return ( &lt;Footer&gt; &lt;Footer.Title&gt;Question?Contact us.&lt;/Footer.Title&gt; &lt;Footer.Break /&gt; &lt;Footer.Row&gt; &lt;Footer.Column&gt; &lt;Footer.Link href=&quot;#&quot;&gt;FAQs&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Investor Relations&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Ways to watch&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Corparate Informations&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Netflix Originals&lt;/Footer.Link&gt; &lt;/Footer.Column&gt; · · · &lt;/Footer.Column&gt; &lt;/Footer.Row&gt; &lt;Footer.Break/&gt; &lt;/Footer&gt; )}export default FooterContainer Part 3: Accordion 常見問題 常見問題的部分會使用手風琴式選單來製作（可以點開收起）。其中需要的元件有標題、問題、內容(回答)、點擊按鈕。 常見問題 (FAQ) 與 Jumbotron 製作的方式類似，都有幾筆類型相同、格式也相同的資料，因此渲染到畫面上的方法是一樣的。 創建基本檔案 components &gt; Accordion &gt; index.js : Accordion 會在裡面處理 components &gt; Accordion &gt; styles &gt; accordion .js : 引入 styled ，在裡面處理 styled component containers &gt; faq.js 在 index.js (components 的) 添加 export { default as Accordion } from './accordion'; , 會在 accordion .js (containers) 中引入 Home.js 中增加 Accordion container 建立需要的元件 + 把需要的資料渲染到瀏覽器上 （直到這裡的步驟都與 jumbotron 的相同） 建立 index.js (之後會詳細處理 state 的部分，這裡不放程式碼) ，創建基本的架構 建立 accordion.js (component &gt; accrodion &gt; styles)，確保index.js 中需要的元件都有在 accordion.js 中出現，避免報錯 FAQ 資料保存在 faqs.json (fixtures) 中，一共有4筆。資料形態如下： faqs.json >folded1234567// filename : faqs.json{ &quot;id&quot;: 1, &quot;header&quot;: &quot;What is Netflix?&quot;, &quot;body&quot;: &quot;Netflix is a streaming service that offers a wide variety of award-winning TV programmes, films, anime, documentaries and more – on thousands of internet-connected devices.\\n\\nYou can watch as much as you want, whenever you want, without a single advert – all for one low monthly price. There's always something new to discover, and new TV programmes and films are added every week!&quot;}, faqs.js (containers) >folded1234567891011121314151617181920212223// filename : faqs.js (containers)import React from &quot;react&quot;import { Accordion } from &quot;../components&quot;import faqsData from &quot;../fixtures/faqs.json&quot;function FaqsContainer(){ return( &lt;Accordion &gt; &lt;Accordion.Title&gt;Frequently Asked Questions&lt;/Accordion.Title&gt; &lt;Accordion.Frame&gt; //這是用來補充 margin 的 {faqsData.map((item) =&gt; ( &lt;Accordion.Item key={item.id}&gt; &lt;Accordion.Header&gt;{item.header}&lt;/Accordion.Header&gt; &lt;Accordion.Body&gt;{item.body}&lt;/Accordion.Body&gt; &lt;/Accordion.Item&gt; ))} &lt;/Accordion.Frame&gt; &lt;/Accordion&gt; )}export { FaqsContainer} Part 4 : Otp form 訂閱表單 + Router 處理 提供用戶訂閱的 Opt Form 會放在 FAQs 那一個部分裡，因此只需要創建 Opt Form 的 component，不需要將其 container 獨立出來。 另外文末也會進行 Router 處理。 創建基本檔案 components &gt; Opt-Form &gt; index.js : opt-form 會在裡面處理 components &gt; Opt-Form &gt; styles &gt; opt-form .js : 引入 styled ，在裡面處理 styled component 在 index.js (components 的) 添加 export { default as Accordion } from ‘./Opt-Form’; index.js (components > opt-form) >folded12345678910111213141516171819202122232425262728293031//filename : index.js (components &gt; opt-form )import React from 'react';import { Container, Input, Break , Button, Text } from './styles/opt-form';function OptForm({ children, ...restProps }) { return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt;}OptForm.Input = function OptFormInput({ ...restProps }) { return &lt;Input {...restProps} /&gt;}OptForm.Button = function OptFormButton({ children, ...restProps }) { return ( &lt;Button {...restProps}&gt; {children} &lt;i className=&quot;fas fa-chevron-right&quot;&gt; &lt;/i&gt; &lt;/Button&gt; )}OptForm.Break = function OptBreak({ ...restProps }) { return &lt;Break {...restProps} /&gt;;}OptForm.Text = function OptFormText({ children, ...restProps }) { return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}export default OptForm 處理 components (pages) 的 router 如果之後要更換路徑，只要更新一個地方就可以了，比較容易維護 創建好之後就可以更換 App.js 中的路徑 Routes.js (constants) >folded123456// filename :Routes.js (constants)export const HOME = '/'export const BROWSE = '/browse'export const SIGN_UP = '/signup'export const SIGN_IN = '/signin' App.js >folded1234567891011121314151617181920212223242526272829303132//filename : App.jsimport React from 'react'import { Switch, Route } from 'react-router-dom'import * as ROUTES from './constants/routes'; //引入import Home from &quot;./pages/Home&quot;function App() { return ( &lt;Switch&gt; &lt;Route path={ROUTES.SIGN_IN}&gt; //這樣使用 &lt;p&gt;Sign in page&lt;/p&gt; &lt;/Route&gt; &lt;Route path={ROUTES.SIGN_UP}&gt; &lt;p&gt;Sign up page&lt;/p&gt; &lt;/Route&gt; &lt;Route path={ROUTES.BROWSE}&gt; &lt;p&gt;browse page&lt;/p&gt; &lt;/Route&gt; &lt;Route path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; Part 5 : Header 首頁大圖 創建基本檔案 components &gt; header &gt; index.js : header 會在裡面處理 components &gt; header &gt; styles &gt; header .js : 引入 styled ，在裡面處理 styled component containers &gt; header.js 在 index.js (components 的) 添加 export { default as Header } from ‘./header’; , 會在 header .js (containers) 中引入 Home.js 中增加 header container 建構需要的元件頁首需要的元件：背景, Logo, Sign In button, opt form . Logo 和 Sign In button 點擊後會跳往指定的頁。Opt form 上一個部分已經做了，所以可以直接使用。 index.js (containers > header) >folded1234567&lt;p&gt;//filename : index.js (containers &amp;gt; header)&lt;/p&gt;&lt;p&gt;import React from “react”&lt;br&gt;import { Link as ReachRouterLink } from “react-router-dom”&lt;br&gt;import { Background, Container, Logo, ButtonLink } from “./styles/header”&lt;/p&gt;&lt;p&gt;function Header({ bg= true, children, …restProps }){&lt;br&gt; return bg ? &amp;lt;Background {…restProps}&amp;gt;{children}&lt;/Background&gt; : children&lt;br&gt;}&lt;/p&gt;&lt;p&gt;Header.Frame = function HeaderFrame({ children, …restProps }) {&lt;br&gt; return &amp;lt;Container {…restProps}&amp;gt;{children}&lt;/Container&gt;&lt;br&gt;}&lt;/p&gt;&lt;p&gt;Header.Logo = function HeaderLogo({ to, …restProps }){&lt;br&gt; return(&lt;br&gt; &lt;ReachRouterLink to={to}&gt;&lt;br&gt; &amp;lt;Logo {…restProps} /&amp;gt;&lt;br&gt; &lt;/ReachRouterLink&gt;&lt;br&gt; )&lt;br&gt;}&lt;/p&gt;&lt;p&gt;Header.ButtonLink = function HeaderButtonLink({ children, …restProps }){&lt;br&gt; return &amp;lt;ButtonLink {…restProps}&amp;gt;{children}&lt;/ButtonLink&gt;&lt;br&gt;}&lt;/p&gt;&lt;p&gt;export default Header&lt;/p&gt; 第 4 行 : logo &amp; signin button 需要使用 Link 第 7 行 : bg 為 true ，會顯示背景圖片 第 11 行 : Header.Frame 會返回 Container 第 15 行 : 使用 Link 把 Logo 包起來，讓他變成點擊後會跳轉的 第 23 行 : Header.ButtonLink 是 for sign in button 的 把需要的元件排進 container 裡header.js (components > header) >folded1234&lt;p&gt;//filename : header.js (components &amp;gt; header)&lt;/p&gt;&lt;p&gt;import React from “react”&lt;br&gt;import { Header } from “../components”&lt;br&gt;import * as ROUTES from “../constants/routes”;&lt;/p&gt;&lt;p&gt;function HeaderContainer({ children }){&lt;br&gt; return(&lt;br&gt; &lt;Header&gt;&lt;br&gt; &amp;lt;Header.Frame&amp;gt;&lt;br&gt; &amp;lt;Header.Logo&lt;br&gt; to={ROUTES.HOME}&lt;br&gt; src=”/images/misc/logo.png”&lt;br&gt; alt=”Netflix”&lt;br&gt; /&amp;gt;&lt;br&gt; &amp;lt;Header.ButtonLink to={ROUTES.SIGN_IN}&amp;gt;Sign In&amp;lt;/Header.ButtonLink&amp;gt;&lt;br&gt; &amp;lt;/Header.Frame&amp;gt;&lt;br&gt; {children}&lt;br&gt; &lt;/Header&gt;&lt;br&gt; )&lt;br&gt;}&lt;/p&gt;&lt;p&gt;export default HeaderContainer&lt;/p&gt; 第 5 行 : 引入 route.js，為 logo &amp; sign in button 加上 Link 第 11 行 : Header.Logo 是個 Link 所以需要 to 第 16 行 : 與第 11 行 同理 加入 Opt Form會有 title, subtitle, form. 為了方便，title, subtitle 會另外創一個 container 來裝。 跟上面的步驟一樣，在 containers 中創建 feature. feature 中創建 index.js 以及 styles, styles 中創建 feature.js. index.js (components > feature) >folded123456789101112131415161718//filename : index.js (components &gt; feature)import React from &quot;react&quot;import { Container, Title, SubTitle } from &quot;./styles/feature&quot;function Feature({ children, ...restProps }){ return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt;}Feature.Title = function FeatureTitle({ children, ...restProps }){ return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Feature.SubTitle = function FeatureSubTitle({ children, ...restProps }){ return &lt;SubTitle {...restProps}&gt;{children}&lt;/SubTitle&gt;}export default Feature Home.js >folded1234567891011121314151617181920212223242526272829303132//filename : Home.jsimport React from 'react'import { Feature, OptForm } from &quot;../components&quot;import { FaqsContainer } from &quot;../containers/faqs&quot;import { JumbotronContainer } from &quot;../containers/jumbotron&quot;import { FooterContainer } from &quot;../containers/footer&quot;import { HeaderContainer } from &quot;../containers/header&quot;export default function Home() { return ( &lt;&gt; &lt;HeaderContainer&gt; &lt;Feature&gt; &lt;Feature.Title&gt;Unlimited films, TV programmes and more.&lt;/Feature.Title&gt; &lt;Feature.SubTitle&gt;Watch anywhere. Cancel at any time.&lt;/Feature.SubTitle&gt; &lt;OptForm&gt; &lt;OptForm.Input placeholder=&quot;Email Address&quot; /&gt; &lt;OptForm.Button&gt;Try it now&lt;/OptForm.Button&gt; &lt;OptForm.Break /&gt; &lt;OptForm.Text&gt;Ready to watch? Enter your email to create or restart your membership.&lt;/OptForm.Text&gt; &lt;/OptForm&gt; &lt;/Feature&gt; &lt;/HeaderContainer&gt; &lt;JumbotronContainer /&gt; &lt;FaqsContainer /&gt; &lt;FooterContainer /&gt; &lt;/&gt; )} 第 4 行 : 把 feature component 傳進來 第 14 行 : 把中間整塊視為 feature, 所以用 feature component 把整塊包起來 第 15,16 行 : 傳進 title 和 subtitle 第 17 行 : 把上一個 part 做好的 Opt Form 整個傳進來 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/05/0505-netflix-clone-2/"},{"title":"【實作記錄】Netflix Clone：用戶登入頁","text":"Live DemoGithub 簡介用戶登入包括了 sign in 和 sign up 兩個頁面。都使用了 firebase 的 auth 功能處理。Firebase 會幫忙驗證 email 和 password 的合法性。最後也會處理只有登入的用戶才能瀏覽 browser 頁的功能。真的是 hen 方便。 Part 1 : Sign in Page + Sign up Page Form 分為兩個部分：已經是用戶在 sign in page, 非用戶會導到 sign up page. Sign in Page components &gt; form &gt; index.js : 處理 Form components &gt; form &gt; styles &gt; form.js : 引入 styled ，在裡面處理 styled component Signin.js : 表單會出現的地方 在 App.js 中加入這個 component 首先創造 Form container，需要form, title, input, submit button, error message, sign up. index.js (components > form >index.js) >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React from &quot;react&quot;import { Container, Base, Title, Text, TextSmall, Error, Input, Submit, Link} from &quot;./styles/form&quot;function Form({ children, ...restProps }){ return( &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; )}//整個 formForm.Base = function FormBase({children, ...restProps}) { return &lt;Base {...restProps}&gt;{children}&lt;/Base&gt;}//標題Form.Title= function FormTitle({children, ...restProps}) { return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}//sign up guideForm.Text = function FormText({children, ...restProps}) { return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}//noteForm.TextSmall = function FormTextSmall({children, ...restProps}) { return &lt;TextSmall {...restProps}&gt;{children}&lt;/TextSmall&gt;}//gsign up linkForm.Link = function FormLink({children, ...restProps}) { return &lt;Link {...restProps}&gt;{children}&lt;/Link&gt;}Form.Error = function FormErrMessage({children, ...restProps}) { return &lt;Error {...restProps}&gt;{children}&lt;/Error&gt;}//email, passwordForm.Input = function FormInput({children, ...restProps}) { return &lt;Input {...restProps}&gt;{children}&lt;/Input&gt;}//Submit ButtonForm.Submit = function FormSubmit({children, ...restProps}) { return &lt;Submit {...restProps}&gt;{children}&lt;/Submit&gt;}export default Form 整理 pages 路徑index.js (pages) >folded12345// filename: index.js (pages)export { default as Home } from &quot;./Home&quot;export { default as Signin } from &quot;./Signin&quot; 在 Signin.js 中設置 form在 signin.js 中處理了以下功能: error 的出現依賴 state 來處理 點擊 submit button, email, password 的改變使用 state 處理 email/ password 其中一個沒有輸入 button 就會 disabled 加入 footer Signin.js >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// filename : Signin.jsimport React, { useState } from 'react'import { Form } from '../components'import { HeaderContainer } from '../containers/header'import { FooterContainer } from '../containers/footer'function Signin() { const [ error, setError ] = useState(&quot;&quot;) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const isInvalid = password === '' | emailAddress === '' const handleSignin = (event) =&gt; { event.preventDefault() } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign In&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.Error&gt;{error}&lt;/Form.Error&gt;} //包著 email 和 password &lt;Form.Base onSubmit={handleSignin} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign In &lt;/Form.Submit&gt; &lt;Form.Text &gt; New to Netflix? &lt;Form.Link to=&quot;/signup&quot;&gt;Sign up now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signin 第 20 行 : 引入 header container，包著所有原件 第 26 行 : 需要接收 submit 的資料，method 為 POST 第 30, 38 行 : 更新 email value 第 13, 41 行 : 設定 button disabled 條件 第 46 行 : 添加 Link , 連接到 sign up page 第 56 行 : 添加 footer Sign up PageSign up page 的配置與 sign in 的差不多：FirstName, email, password, submit. 因為引用與 sign in 同一個 styled component，所以不需要再另外設置。 Signup.js (pages) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import React, { useState } from &quot;react&quot;import { HeaderContainer } from '../containers/header'import { Form } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;import { FooterContainer } from &quot;../containers/footer&quot;function Signup({ children, ...RestProps }){ const [ firstName, setFirstName ] = useState(&quot;&quot;) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const [ error, setError ] = useState(&quot;&quot;) const isInvalid = firstName === &quot;&quot; || emailAddress === &quot;&quot; || password === &quot;&quot; const handleSignup = (event) =&gt; { event.preventDefault() } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign Up&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.error&gt;{error}&lt;/Form.error&gt;} &lt;Form.Base onSubmit={handleSignup} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;First Name&quot; value={firstName} onChange = {({ target })=&gt; setFirstName(target.value)} /&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign Up &lt;/Form.Submit&gt; &lt;Form.Text&gt; Already a user? &lt;Form.Link to=&quot;/signin&quot;&gt;Sign in now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signup Part 2 : 用戶選擇 Profile select 創建基本檔案 pages &gt; browse.js 在 index.js (pages 的) 增加 export { default as Browse } from &quot;./Browse&quot; components &gt; profiles &gt; index.js components &gt; profilesr &gt; styles &gt; profiles .js containers &gt; brwoser.js containers &gt; SelectProfileContainer.js 在 App.js 中引入 browse.js App.js >folded123456789101112131415161718192021222324252627282930import React from 'react'import { Switch, Route } from 'react-router-dom'import * as ROUTES from './constants/routes';import { Home, Signin, Signup, Browse } from &quot;./pages&quot;function App() { return ( &lt;Switch&gt; &lt;Route path={ROUTES.SIGN_IN}&gt; &lt;Signin /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.SIGN_UP}&gt; &lt;Signup /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.BROWSE}&gt; &lt;Browse /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; browse.js 中需要引入的東西： header component (頁首) route.js (跳轉頁面) firebase context (film 資料) select profile container (進入 film 列表前的用戶選擇) footer container (頁腳) 用戶選擇登入成功後，在進入 film 列表前有選擇用戶的區塊 (select profile container) 。在 browse.js 中創造用戶 profile，為一個 object，內有 display name 和 photo url. 選擇用戶區塊是否顯示是根據 display name 是否存在，如果存在則顯示設定好的 browser 畫面，不存在則顯示選擇用戶頁面. Profile 使用 state 來更新其狀態。 browse.js (containers) >folded123456789101112131415161718192021222324252627import React, {useState} from &quot;react&quot;import { Header } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;import { FirebaseContext } from &quot;../context/firebase&quot;import { SelectProfileContainer } from &quot;./profiles&quot;import { FooterContainer } from &quot;./footer&quot;function BrowseContainer() { const [ profile, setProfile ] = useState({}) const user = { displayName: 'Karl', photoURL:&quot;1&quot; } return profile.displayName ? ( &lt;p&gt; &lt;p&gt;Browse Container&lt;/p&gt; &lt;FooterContainer/&gt; &lt;/p&gt;): ( &lt;SelectProfileContainer user={user} setProfile={ setProfile}/&gt; //參數要往下傳, selectProfileContainer 才能使用 user 等 )}export { BrowseContainer } 接著設置 Profiles.js (containers), select profile container 會在這裡處理。需要引入： header component (Logo, 撐開 logo 的 frame, 不要背景 ) ROUTES (Logo 跳轉頁面) profile component 在 profiles component (index.js)裡創造需要的元件：Title, User, List, Picture, Name. index.js (components > profiles ) >folded12345678910111213141516171819202122232425262728293031import React from &quot;react&quot;import { Container, Title, List, User, Name, Picture } from &quot;./styles/profiles&quot;function Profiles({ children, ...restProps }) { return( &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; )}Profiles.Title = function ProfilesTitle({ children, ...restProps }) { return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Profiles.List = function ProfilesList({ children, ...restProps }) { return &lt;List {...restProps}&gt;{children}&lt;/List&gt;}Profiles.User = function ProfilesUser({ children, ...restProps }) { return &lt;User {...restProps}&gt;{children}&lt;/User&gt;}Profiles.Name = function ProfilesName({ children, ...restProps }) { return &lt;Name {...restProps}&gt;{children}&lt;/Name&gt;}//注意照片傳進來的參數 : 沒有children，傳進 srcProfiles.Picture= function ProfilesPicture({src, ...restProps }) { return &lt;Picture {...restProps} src={src? 照片鏈接:照片鏈接}} //在瀏覽器還沒把照片load出來前顯示loading gifexport default Profiles 在 profles container (Profiles.js) 中排版，設置頁面需要的東西。Profiles.users 在點擊之後會更新 profile 的 state，用來跳轉畫面。 profiles.js (containers) >folded1234567891011121314151617181920212223242526272829303132333435import React from &quot;react&quot;import { Header, Profiles } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;function SelectProfileContainer({ user, setProfile }) { return( &lt;&gt; &lt;Header bg={false}&gt; &lt;Header.Frame&gt; &lt;Header.Logo src=&quot;/images/misc/logo.png&quot; to={ROUTES.HOME} alt=&quot;Netflix&quot;/&gt; &lt;/Header.Frame&gt; &lt;/Header&gt; &lt;Profiles&gt; &lt;Profiles.Title&gt;Who is Watching?&lt;/Profiles.Title&gt; &lt;Profiles.List&gt; &lt;Profiles.User onClick={() =&gt; setProfile({ displayName: user.displayName, photoURL: user.photoURL })} &gt; &lt;Profiles.Picture src={user.photoURL}/&gt; &lt;Profiles.Name&gt;{user.displayName}&lt;/Profiles.Name&gt; &lt;/Profiles.User&gt; &lt;/Profiles.List&gt; &lt;/Profiles&gt; &lt;/&gt; )}export { SelectProfileContainer } Part 3 : 連接 FireBase + 用戶 Auth 參考資料用 Firebase Authentication 做一套簡易會員系統 – 電子郵件 密碼 連接 Firebase + firestore 在 context file 裡創建 firebase.js firebase.js (context) >folded12import { createContext } from &quot;react&quot;export const FirebaseContext = createContext(null) 在 index.html 中加入以下程式碼 index.html >folded12&lt;script src=&quot;https://www.gstatic.com/firebasejs/8.4.3/firebase-app.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://www.gstatic.com/firebasejs/8.4.3/firebase-firestore.js&quot;&gt;&lt;/script&gt; 在 firebase 創建新的項目，跟著指示網下走 創建新的資料庫，點擊 firestore &gt; 創建資料庫 &gt;選擇生產者模式 選擇資料存放地區 回到專案頁面 &gt; 點擊”網頁” &gt; 添加名字 &gt; 點擊註冊應用 &gt; 跳出一個這個數據庫的資料 舊版本會有 database url，這個版本不需要 index.js 中加入 剛才創建的 firebase.js index.js (src) >folded1234567891011121314151617181920212223242526272829import React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import { BrowserRouter } from &quot;react-router-dom&quot;import { GlobalStyles } from &quot;./global-style&quot; import { FirebaseContext } from &quot;./context/firebase&quot; import App from &quot;./App&quot;const Config = { apiKey: &quot;-----------------&quot;, authDomain: &quot;-----------------&quot;, projectId: &quot;-----------------&quot;, storageBucket: &quot;-----------------&quot;, messagingSenderId: &quot;-----------------&quot;, appId: &quot;-----------------&quot;}//firebase context 中以把 value 設為 {firebase: window.firebase}, 以 props 的方式傳進去ReactDOM.render( &lt;&gt; &lt;FirebaseContext.Provider value={}&gt; &lt;GlobalStyles/&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/FirebaseContext.Provider&gt; &lt;/&gt;, document.getElementById('root')); Firebase Authendication進入專案 &gt; 點擊 Authendication &gt; Sign in method (依照個人需求) &gt; email/password 打開 &gt; 在 html 中加入一段 auth 的程式碼 CustomPagination.js >folded1&lt;script src=&quot;https://www.gstatic.com/firebasejs/8.0.1/firebase-auth.js&quot;&gt;&lt;/script&gt; 為 Sign up Page 加上 Authentication在 index.js initializ firebaseindex.js >folded12//filename :index.js const firebase = window.firebase.initializeApp(config) 在 signup.js 處理 authenation讓用戶註冊賬號，如果註冊不成功便會出現錯誤信息，密碼少於6碼或是賬號已經被使用過等錯誤會被印出來。如果註冊成功會直接導到 profile select 那一頁，這個部分可以使用 useHistory 處理，不用重整畫面就可以做到跳轉頁面的效果。 這是一個 promise，所以使用 then() 以及 catch()來操作. Signup.js (pages) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import React, { useState, useContext } from &quot;react&quot;import { useHistory } from 'react-router-dom';import { HeaderContainer } from '../containers/header'import { FooterContainer } from &quot;../containers/footer&quot;import { FirebaseContext } from &quot;../context/firebase&quot;import { Form } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;function Signup({ children, ...RestProps }){ const history = useHistory() const { firebase } = useContext(FirebaseContext) const [ firstName, setFirstName ] = useState(&quot;&quot;) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const [ error, setError ] = useState(&quot;&quot;) const isInvalid = firstName === &quot;&quot; || emailAddress === &quot;&quot; || password === &quot;&quot; const handleSignup = (event) =&gt; { event.preventDefault() firebase .auth() .createUserWithEmailAndPassword(emailAddress, password) .then((result) =&gt; result.user .updateProfile({ displayName: firstName, photoURL: Math.floor(Math.random() * 4 ) + 1 }) .then(() =&gt; { setEmailAddress(&quot;&quot;) setPassword(&quot;&quot;) setError(&quot;&quot;) history.push(ROUTES.BROWSE) }) ).catch((error) =&gt; setError(error.message)) } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign Up&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.Error&gt;{error}&lt;/Form.Error&gt;} &lt;Form.Base onSubmit={handleSignup} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;First Name&quot; value={firstName} onChange = {({ target })=&gt; setFirstName(target.value)} /&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign Up &lt;/Form.Submit&gt; &lt;Form.Text&gt; Already a user? &lt;Form.Link to=&quot;/signin&quot;&gt;Sign in now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signup 由於需要用到 firebase context 來操作 firebase 第 6 行 : 引入 { firebaseContext } 第 12 行 : 使用 useContext 調用 第 24 行 : 使用 firebase 的 method, 本身為一個 promise 處理點擊 sign up 後的動作 第 25, 26 行 : 使用 firebase 的 method 第 27 行 : 成功註冊後更新 profile 第 31 行 : photoURL 使用隨機號碼當做 url (image文件夾裡有 4 張照片，檔名為1, 2, 3, 4) 第 33 行 : 成功註冊後清除輸入欄 第 37 行 : 使用 useHistory 把網頁導到 browser 那頁 第 39 行 : 註冊失敗會出現錯誤信息 為 Sign in Page 加上 AuthenticationSign in page 的操作步驟與 sign up 的差不多，差別只在點擊 sign in button 後的處理。 Signup.js (pages) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, { useState, useContext } from 'react'import { useHistory } from &quot;react-router-dom&quot;import { Form } from '../components'import { HeaderContainer } from '../containers/header'import { FooterContainer } from '../containers/footer'import { FirebaseContext } from &quot;../context/firebase&quot;import * as ROUTES from &quot;../constants/routes&quot;function Signin() { const history = useHistory() const { firebase } = useContext(FirebaseContext) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const [ error, setError ] = useState(&quot;&quot;) const isInvalid = password === '' | emailAddress === '' const handleSignin = (event) =&gt; { event.preventDefault() firebase .auth() .signInWithEmailAndPassword ( emailAddress, password ) .then( setEmailAddress(&quot;&quot;), setPassword(&quot;&quot;), setError(&quot;&quot;), history.push(ROUTES.BROWSE) ) } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign In&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.Error&gt;{error}&lt;/Form.Error&gt;} &lt;Form.Base onSubmit={handleSignin} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign In &lt;/Form.Submit&gt; &lt;Form.Text &gt; New to Netflix? &lt;Form.Link to=&quot;/signup&quot;&gt;Sign up now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signin 寫入資料在寫入資料前，要先把 rules 改成 true，但這個設定會讓所有人都有權限把資料寫進去。 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/07/0507-netflix-clone-3/"},{"title":"【實作記錄】Netflix Clone：Browser頁","text":"Live DemoGithub 簡介Browser 頁處理的東西比較多：用戶 Profile 選擇、首頁大圖、每列分類以及卡片、卡片詳細資訊、播放器、搜尋功能、sign out 功能。series 以及 films 的資料都存在 firestore 裡，之後有餘力會再多增加幾筆資料做換頁效果。 Part 1: 頁頭功能 Browser header Brower header 分為三個部分處理 ： 右側功能、左側功能、以及首頁大圖。 Browser 右側功能browser 右側 有 Logo, Catagory link, Series Link ，以及一個 container: Group. 可以使用之前創造好的 header component，但缺少的元件要回去 header (index.js) 裡補上。 browse.js (containers) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, { useState, useContext } from &quot;react&quot;import { Header } from &quot;../components&quot;import { FirebaseContext } from &quot;../context/firebase&quot;import { FooterContainer } from &quot;./footer&quot;import { SelectProfileContainer } from &quot;./profiles&quot;import * as ROUTES from &quot;../constants/routes&quot;function BrowseContainer(){ const [ profile, setProfile ] = useState({}) const [ category, setCategory ] = useState(&quot;series&quot;) const [ loading, setLoading ] = useState(true) const { firebase } = useContext(FirebaseContext) const user = { displayName: 'Karl', photoURL:&quot;1&quot; } return profile.displayName ? ( &lt;&gt; &lt;Header src=&quot;joker1&quot; dontShowOnSmallViewPort&gt; &lt;Header.Frame&gt; &lt;Header.Group&gt; &lt;Header.Logo to={ROUTES.HOME} src=&quot;images/misc/logo.png&quot; alt=&quot;Netflix&quot;/&gt; &lt;Header.Link active ={category === &quot;series&quot;? &quot;true&quot;:&quot;false&quot;} onClick={() =&gt; setCategory(&quot;series&quot;)} &gt; Series &lt;/Header.Link&gt; &lt;Header.Link active ={category === &quot;films&quot;? &quot;true&quot;:&quot;false&quot;} onClick={() =&gt; setCategory(&quot;films&quot;)} &gt; Film &lt;/Header.Link&gt; &lt;/Header.Group&gt; &lt;/Header.Frame&gt; &lt;/Header&gt; &lt;FooterContainer/&gt; &lt;/&gt; ) : (&lt;SelectProfileContainer user={user} setProfile={ setProfile }/&gt;) }export { BrowseContainer } 第 21 行 : 如果有 display name，就進入 browser ，無則顯示用戶選擇頁第 23 行 : 引入 Header, 傳入首頁大圖，設定小熒幕不呈現 第 25 行 : container 的概念，用來調整樣式第 31, 38 行 : 設定 link, 使用 state 來改變 active的狀態，active 用來調整樣式 index.js (components > header) >folded1234567 Header.Link = function HeaderLink({ children, ...restProps }){ return &lt;Link {...restProps}&gt;{children}&lt;/Link&gt;}Header.Group = function HeaderGroup({ children, ...restProps }) { return &lt;Group {...restProps}&gt;{children}&lt;/Group&gt;} header.js (components > header > styles) >folded1234567891011121314151617181920export const Link = styled.p` color: #fff; text-decoration: none; margin-right: 30px; font-weight: ${({ active }) =&gt; (active === 'true' ? '700' : 'normal')}; cursor: pointer; &amp;:hover { font-weight: bold; } &amp;:last-of-type { margin-right: 0; }`export const Group = styled.div` display: flex; align-items: center;` Browser 首頁大圖Browser 首頁大圖除了電影海報、會加上介紹，Play Button，info button.其中 Play Button 在點擊後會連到電影預告 (Youtube). Header 會再加上 Feature, FeatureCallOut, Text, Span, Play Button, Info Button, 因此 index.js (header) 要增加這幾個元件。 browse.js (containers) >folded12345678910&lt;Header.Feature&gt; //container的概念&lt;Header.FeatureCallOut&gt;Extraction&lt;/Header.FeatureCallOut&gt; &lt;Header.Text&gt; A black-market mercenary who has nothing to lose is hired to rescue the kidnapped son of an imprisoned international crime lord. But in the murky underworld of weapons dealers and drug traffickers, an already deadly mission approaches the impossible. &lt;/Header.Text&gt;&lt;Header.Span&gt; &lt;Header.PlayButton&gt;&lt;/i&gt;more info&lt;/Header.InfoButton&gt;&lt;/Header.Span&gt;&lt;/Header.Feature&gt; index.js (components > header) >folded1234567891011121314151617181920212223Header.Text = function HeaderText({ children, ...restProps }){ return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}Header.Feature = function HeaderFeature({ children, ...restProps }){ return &lt;Feature {...restProps}&gt;{children}&lt;/Feature&gt;}Header.FeatureCallOut = function HeaderFeatureCallOut({ children, ...restProps }){ return &lt;FeatureCallOut {...restProps}&gt;{children}&lt;/FeatureCallOut&gt;}Header.InfoButton = function HeaderInfoButton({ children, ...restProps }){ return &lt;InfoButton {...restProps}&gt;{children}&lt;/InfoButton&gt;}Header.PlayButton = function HeaderPlayButton({ children, ...restProps }){ return &lt;PlayButton {...restProps}&gt;{children}&lt;/PlayButton&gt;}Header.Span = function HeaderSpan({ children, ...restProps }){ return &lt;Span {...restProps}&gt;{children}&lt;/Span&gt;} Browser 左側功能 : search bar點擊 search icon 搜索框就會跳出來，在小於700px的熒幕不提供搜尋功能。跳出來的功能是靠改變 state 來完成的，點擊按鈕 active 變成 true，在sytled component 裡有 active 與不 active 相應的樣式。 browse.js (containers) >folded123&lt;Header.Group&gt; &lt;Header.Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt;&lt;/Header.Group&gt; index.js (components > header) >folded1234567891011121314151617181920//filename:index.js (components &gt; header)Header.Search = function HeaderSearch({ searchTerm, setSearchTerm, ...restProps }){ const [ searchActive, setSearchActive ] = useState(false) return( &lt;Search {...restProps}&gt; &lt;SearchIcon onClick={() =&gt; setSearchActive(!searchActive)}&gt; &lt;i className=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/SearchIcon&gt; &lt;SearchInput value={searchTerm} onChange={({ target }) =&gt; setSearchTerm(target.value)} placeholder=&quot;Search files and series&quot; active={searchActive} /&gt; &lt;/Search&gt; ) } header.js (conponents > header) >folded1234567891011121314// active 時候 input 的設法export const SearchInput = styled.input` background-color: rgba(105, 105, 105, 0.3); color: #000; border: 1px solid #fff; transition: width 0.5s; height: 30px; font-size: 14px; margin-left: ${({ active }) =&gt; (active === true ? '10px' : '0')}; padding: ${({ active }) =&gt; (active === true ? '0 10px' : '0')}; opacity: ${({ active }) =&gt; (active === true ? '1' : '0')}; width: ${({ active }) =&gt; (active === true ? '200px' : '0px')};` Browser 左側功能 : 下拉式選單 + 其他 iconDropdown 選單：Profile，Account, Help center, Sign Out. 並排的 KIDs icon, gift icon, bell icon 暫時沒有功能。Dropdown 功能是 hover 的時候就會出現，因此是在 styled component 中處理，沒有特別使用 state 來做。 browse.js >folded1234567891011121314151617181920212223242526272829303132&lt;Header.Group&gt; &lt;Header.Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt; //其他icon &lt;Header.Span&gt; &lt;Header.Text&gt;KIDS&lt;/Header.Text&gt; &lt;i className=&quot;fas fa-gift&quot; &gt;&lt;/i&gt; &lt;i className=&quot;fas fa-bell&quot; &gt;&lt;/i&gt; &lt;/Header.Span&gt;// 點擊頭像 &lt;Header.Profile&gt; &lt;Header.Picture src={user.photoURL} /&gt;// 下拉式選單 &lt;Header.Dropdown&gt; &lt;Header.Group&gt; &lt;Header.Picture src={user.photoURL}/&gt; &lt;Header.Text&gt;{user.displayName}&lt;/Header.Text&gt; &lt;/Header.Group&gt; &lt;Header.Group&gt;//選單 &lt;Header.Span&gt; &lt;Header.Link &gt;Account&lt;/Header.Link&gt; &lt;Header.Link &gt;Help Center&lt;/Header.Link&gt; &lt;Header.Link onClick={() =&gt; firebase.auth().signOut()}&gt;Sign Out&lt;/Header.Link&gt; &lt;/Header.Span&gt; &lt;/Header.Group&gt; &lt;/Header.Dropdown&gt; &lt;/Header.Profile&gt;&lt;/Header.Group&gt; index.js (components > header) >folded1234567891011Header.Profile = function HeaderProfile({ children, ...restProps }){ return &lt;Profile {...restProps}&gt;{children}&lt;/Profile&gt;}Header.Dropdown = function HeaderDropdown({ children, ...restProps }){ return &lt;Dropdown {...restProps}&gt;{children}&lt;/Dropdown&gt;}Header.Picture = function HeaderPicture({ src, ...restProps }){ return &lt;Picture {...restProps} src={`照片位置`}/&gt;} Part 2: 資料處理 提取 firebase 裡的資料使用下面的方法提取 collection 裡的資料。創造一個 state 來儲存需要的資料；只需要在 firebase 改變的時候獲取一次資料，所以使用 useEffect. 最後可以印出獲取的資料驗證是否有取得需要的資料。 use-content (hooks) >folded12345678910111213141516171819202122232425262728293031import { useContext, useEffect, useState } from &quot;react&quot;import { FirebaseContext } from &quot;../context/firebase&quot;function useContent(target) { const { firebase } = useContext(FirebaseContext) const [ content, setContent ] = useState([])//提取 collection 資料的方式 useEffect(() =&gt; { firebase .firestore() .collection(target) .get() .then((snapshot) =&gt; { const allContent = snapshot.docs.map((contentObj) =&gt; ({ ...contentObj.data(), docID : contentObj.id })) setContent(allContent) }) .catch((error) =&gt; { console.error(error) }) }, []) return { [target] : content }}export default useContent 這裡在 Browse.js 中嘗試印出。 Browse.js (pages) >folded123456789101112131415import React from &quot;react&quot;import { BrowseContainer } from &quot;../containers/browse&quot;import { useContent } from &quot;../hooks&quot;function Browse() { const { series } = useContent('series') const { film } = useContent('film') console.log(series) console.log(film) return &lt;BrowseContainer/&gt;}export default Browse Part 3: 電影、電視列表 film and series list 電影列表會模仿 netflix 的樣式. 暫時會分為 series 和 films 兩頁，用戶可以自由切換頁面。每頁會有 4-5 個清單，每個清單的卡片都可以打開查看資訊，會出現照片、關閉 button, play button, add to my list button. 卡片的資料來源是前一個 part 獲得的 slide 資料。 slide 資料的組成： Slide 的元件 (畫面中有好幾條不同類別的 list )用戶可以切換頁面使用 useState 和 useEffect 來控制，在 category 改變的時候就調用該 category 的資料，點擊 film, state 會更新，提取的資料就更換成 film. 調出每一筆資料則是使用 .map() 遍歷 slide 資料。先遍歷被選中的 categroty 底下的資料, 提取每一個類別的分類 (title), 再遍歷每一筆資料 (data), 調出每一個分類下的影片資訊。 brwose.js (containers) >folded12345678910111213141516171819&lt;Card.Group&gt; {slideRows.map((slideItem) =&gt; ( &lt;Card key={`${category}-${slideItem.title.toLowerCase()}`}&gt; &lt;Card.Title&gt;{slideItem.title}&lt;/Card.Title&gt; &lt;Card.Entities&gt; {slideItem.data.map((item) =&gt; (//src 要加上`` &lt;Card.Item key={item.docid} item={item}&gt; &lt;Card.Img src={/images/${category}/${item.genre}/${item.slug}/small.jpg} /&gt; &lt;Card.Meta&gt; &lt;Card.Subtitle&gt;{item.title}&lt;/Card.Subtitle&gt; &lt;Card.Text&gt;{item.description}&lt;/Card.Text&gt; &lt;/Card.Meta&gt; &lt;/Card.Item&gt; ))} &lt;/Card.Entities&gt; &lt;/Card&gt; ))}&lt;/Card.Group&gt; 建立 card component每張卡片點進去會跳出詳細資訊的區塊稱為 “Feature”. Card component 裡會創造 context 以及 state. 每張 card 是一個 item，這設置兩組 state：一組為點擊 card 就更新 state 為被點擊 card 的資料；另一組為點擊 card 後更新 state 為 true，讓卡片彈跳出來。由於有超過一個地方需要這兩個 state 因此使用 context 包起來。 index.js (components > card) >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React, { useState, useContext, createContext } from &quot;react&quot;import { Container, Group, Title, Item, Entities, Image, Meta, Subtitle, Text, Feature, FeatureTitle, FeatureClose, Maturity, Content,} from &quot;./styles/card&quot;const FeatureContext = createContext()function Card({ children, ...restProps }) { const [showFeature, setShowFeature] = useState(false) const [itemFeature, setitemFeature] = useState(false)//value 的大括號中要再放進大括號 return( &lt;FeatureContext.Provider value={}&gt; &lt;Container {...restProps }&gt;{children}&lt;/Container&gt; &lt;/FeatureContext.Provider&gt; )}Card.Group = function CardGroup({children, ...restProps}){ return &lt;Group {...restProps}&gt;{children}&lt;/Group&gt;}Card.Title = function CardTitle({children, ...restProps}){ return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Card.Subtitle = function CardSubtitle({children, ...restProps}){ return &lt;Subtitle {...restProps}&gt;{children}&lt;/Subtitle&gt;}Card.Text = function CardText({children, ...restProps}){ return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}Card.Entities = function CardEntities({children, ...restProps}){ return &lt;Entities {...restProps}&gt;{children}&lt;/Entities&gt;}Card.Meta = function CardMeta({children, ...restProps}){ return &lt;Meta {...restProps}&gt;{children}&lt;/Meta&gt;}Card.Item = function CardItem({item, children, ...restProps}){ const { setitemFeature, setshowFeature } = useContext(FeatureContext) return ( &lt;Item onClick={() =&gt; { setitemFeature(item) //itemFeature 就是整個 item setshowFeature(true) }} {...restProps}&gt;{children}&lt;/Item&gt; )}Card.Image = function CardEntities({...restProps}){ return &lt;Image {...restProps}/&gt;}Card.Feature = function CardFeature({children, category ,...restProps}){ const { showFeature, setShowFeature, itemFeature } = useContext(FeatureContext) return showFeature ? ( &lt;Feature src={`images/${category}/${itemFeature.genre}/${itemFeature.slug}/large.jpg}`}&gt; &lt;Content&gt; &lt;Feature.Title&gt;{itemFeature.title}&lt;/Feature.Title&gt; &lt;Feature.Text&gt;{itemFeature.description}&lt;/Feature.Text&gt; &lt;Feature.Close onClick={()=&gt;setShowFeature(false)} &gt; &lt;i className=&quot;fas fa-times&quot;&gt;&lt;/i&gt; &lt;/Feature.Close&gt; &lt;Group margin=&quot;30px 0&quot; flexDirection=&quot;row&quot; alignItems=&quot;center&quot;&gt; &lt;Maturity rating={itemFeature.maturity}&gt;{itemFeature.Maturity &lt; &quot;12&quot; ? &quot;PG&quot;: itemFeature.Maturity}&lt;/Maturity&gt; &lt;Feature.Text fontWeight=&quot;bold&quot;&gt;{itemFeature.genre.charAt(0).toUpperCase() + itemFeature.genre.slice(1)}&lt;/Feature.Text&gt; &lt;/Group&gt; &lt;/Content&gt; {children} &lt;/Feature&gt; ) : null}export default Card 第 22 行 : 創造 context 第 25 行 : 創造 state ( feature 是否出現 ) 第 26 行 : 創造 state ( feature 的內容為被點擊的卡片的內容 ) 第 29 行 : 用 provider 包起來，之後就可以 consume 第 59 行 : 會傳進 item, item 是 browse.js 中的item 第 60 行 : 用 useContext 傳進需要的參數 第 65 行 : 點擊後，把 itemFeature 改成被點擊的卡片的內容 第 66 行 : 點擊後，把 showFeature 改成 true, 顯示 feature 框框 第 76 行 : Card.Feature 整組是點擊 card 後跳出來的 feature 框框 第 79 行 : 如果 showFeature 為 true 才顯示 feature 框框 第 80 行 : 背景會壓一張照片 第 84 行 : 點擊後，把 showFeature 改成 false, feature 框框收起來 第 90 行 : 在 style 的時候可以根據參數進行處理 第 91 行 : 如果資料的 maturity 小於 12 就顯示 PG, 若非則顯示 資料上的數字 第 92 行 : genre 首字母為大字母 Part 4 : 搜尋 Live Search參考資料Fuse.jssearch box 提供用戶搜尋的功能。這個功能使用 Fuse.js 這個套件完成。 CustomPagination.js1npm install --save fuse.js 搜尋功能會在 browse.js 中完成, 之前已經在 search component 中加入 search 的 state. 使用 useeffect ，在這個 state 改變的時候就會執行設定好的程式碼。 browse.js >folded12const [searchTerm, setSearchTerm] = useState('')&lt;Header.Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt; browse.js >folded12345678910useEffect(() =&gt; { const fuse = new Fuse(slideRows, { keys: ['data.description', 'data.title', 'data.genre'] }); const results = fuse.search(searchTerm).map(({ item }) =&gt; item); if (slideRows.length &gt; 0 &amp;&amp; searchTerm.length &gt; 3 &amp;&amp; results.length &gt; 0) { setSlideRows(results); } else { setSlideRows(slides[category]); } }, [searchTerm]) 第 4 行 : 設定搜尋條件 第 5 行 : fuse 搜尋功能的寫法 第 7 行 : 設定結果條件 Part 5: 播放器 Player 播放器按鈕會出現在 feature 框框出現，點擊後就會彈出播放器。但資料庫沒有每個卡片的影片，因此這裡僅是示範。最後版本會移除此功能。 播放器按鈕一樣是依賴 state 來操作。這個 state 會在多過一處使用，因此可以使用 useContext 包起來。Video 直接透過 reactDOM 渲染到瀏覽器，不經過 browse container/ 其他 container 渲染。 index.js >folded123456789101112131415161718192021222324252627282930313233343536373839404142import React, { useState, useContext, createContext} from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import { Container, Overlay, Inner, Button } from &quot;./styles/player&quot;export const PlayerContext = createContext()function Player({ children, ...restProps }) { const [showPlayer, setShowPlayer] = useState(false)//value = {showPlayer, setShowPlayer} return( &lt;PlayerContext.Provider value={}&gt; &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; &lt;/PlayerContext.Provider&gt; )}Player.Video = function PlayerVideo({ ...restProps }) { const { showPlayer, setShowPlayer } = useContext(PlayerContext); return showPlayer ? ReactDOM.createPortal( &lt;Overlay onClick={() =&gt; setShowPlayer(false)}&gt; &lt;Inner&gt; &lt;video id=&quot;netflix-player&quot; controls&gt; &lt;source src=&quot;/videos/bunny.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;/video&gt; &lt;/Inner&gt; &lt;/Overlay&gt;, document.body ) : null;}Player.Button = function PlayerButton({ ...restProps }) { const { showPlayer, setShowPlayer } = useContext(PlayerContext); return &lt;Button onClick={() =&gt; setShowPlayer(!showPlayer)}&gt;Play&lt;/Button&gt;;}export default Player 第 13 行 : 使用 Provider 包起來第 20 行 : consume provieder第 23 行 : 使用 createPortal browse.js (containers) >folded1234567&lt;Card.Feature category={category}&gt; &lt;Player&gt; &lt;Player.Button /&gt; &lt;Player.Video /&gt; &lt;/Player&gt;&lt;/Card.Feature&gt; 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/09/0509-netflix-clone-4/"}],"tags":[{"name":"Vannila JS","slug":"Vannila-JS","link":"/tags/Vannila-JS/"},{"name":"學習筆記","slug":"學習筆記","link":"/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Project","slug":"React/Project","link":"/categories/React/Project/"}]}