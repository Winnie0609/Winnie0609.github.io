{"pages":[{"title":"安安，你好。","text":"翁慧倪 @huini_ong 狀態：緩慢但持續前進的烏龜 🐢 欸欸 我想成為聰明的人 📍&nbsp;&nbsp;TW. 🏠&nbsp;&nbsp;MY. 🎈&nbsp;June 9, 1998 前端菜雞 ( 2021 年 2 月開始自學前端開發 ) 正在尋找前端相關的工作 相信變強的最快方法是進去被電爆 我家猫会后空翻，我會寫程式。 我還會做小東西。 React | 📺 Netflix Clone React | 🛒 Ecommerce Website React | 🎞️ Movie Search App React | ⌨️ Speed Test App React | 😂 Meme Generator React | ✔️ Todo List Vanilla JS | 🟡 Pacman Game Vanilla JS | 🐍 Snake Game Vanilla JS | 😜 Joke Generator Vanilla JS | 🎲 Dice Game 也會發廢文。 中文系畢業，喜歡寫字，沒想到後來也喜歡寫程式 摘星星的人，即使徒勞無功，亦不致於一手污泥 不笑時臉看起來很臭，但真的沒有心情不好 喜歡清心的多多綠微糖微冰加珍珠 都想做不同的事、玩不同的東西 馬來文、粵語、台語也會一些 寫程式和寫字都很浪漫 偶爾是廢文產生器 火鍋愛好者 我沒有貓 雖然我沒有貓，但還是要跟我聊天呀。 12//其實很討厭點了 email icon 就跳出寄信郵箱，所以這裡附上 emailwinnieong0609@gmail.com","link":"/about/index.html"}],"posts":[{"title":"【實作記錄】Todo List | React","text":"Github : 點我看原始碼. 簡介這是一個有基本功能的 todo list 練習，為了練習語法以及邏輯，所以參考了教學影片，文末附上教學影片之連結。這裡練習了各個 Component 之間的傳遞、React Hook 也認識了之前沒有用過的幾個 CSS 小方法。下面詳細記錄了自己的學習步驟。 功能 增加 task 刪除 task 完成的 task : 打√, 劃掉的線 可以 filter 完成/未完成/所有的 task 前置作業簡單劃分需要的功能以及元件。除了 index.js 外，主要的操作都在 App.js.其餘的 Component 集中放到 components 的 file 中。 index.js App.js Form.js TodoList.js Todo.js 步驟基本設置整個Todo list 是由兩個部分組成的：form 以及 list。 form : 設置讓用戶輸入的 form , 包含輸入的框框 (input) &amp; 添加按鈕 (button) &amp; filter (select) 。Filter 裡有三個 option : All/ completed / uncompleted。 list : 用戶在增加 task 之後，該 task 會出現在 list 裡。只要設置一個 unorder list，增加的部分之後會處理。 index.js1234567891011import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';ReactDOM.render( &lt;div className=&quot;container&quot;&gt; &lt;App /&gt; &lt;/div&gt;, document.getElementById('root')); Form.js123456789101112131415161718192021222324252627import React from &quot;react&quot;import '../index.css'; //引入外部cssconst Form = () =&gt; { return( &lt;form&gt; &lt;div className=&quot;input-option&quot;&gt; &lt;select dir=&quot;rtl&quot;&gt; &lt;option class=&quot;options&quot; value=&quot;all&quot;&gt;All&lt;/option&gt; &lt;option class=&quot;options&quot; value=&quot;completed&quot;&gt;Completed&lt;/option&gt; &lt;option class=&quot;options&quot; value=&quot;uncompleted&quot;&gt;Uncompleted &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div className=&quot;input-text&quot;&gt; &lt;input className=&quot;text&quot; type=&quot;text&quot; placeholder=&quot;Add a task...&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;&lt;i class=&quot;fas fa-times add&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; )}export default Form Form.js123456789101112import React from &quot;react&quot;import '../index.css';const TodoList = () =&gt; { return( &lt;div className=&quot;todo-container&quot;&gt; &lt;ul className=&quot;todo-list&quot;&gt;&lt;/ul&gt; &lt;/div&gt; )}export default TodoList 處理用戶輸入的input在 App.js 使用 useState 設定 value 的初始值。因為需要處理的 input在 Form.js 中，因此要把這兩個參數往下傳，之後才能在 Form.js 中引入。 App.js123const [inputText, setInputText] = useState(&quot;&quot;)//初始值為空字串&lt;Form inputText={inputText} setInputText={setInputText}/&gt; 接著處理用戶輸入的資訊。在 input 中設定 onchange 以及 value. input 改變時，onChange 會被觸發，因而執行設定好的 function. 創造一個處理更新的 function : handlechange.使用 setTnputText 更新input 的 value.用戶每輸入一個字，就會觸發 onchange, 所以會出現下面的結果。 const Form = ({ setInputText }) 相等於 const Form = ({props}) 的寫法，前者是直接把 setInput 這個參數傳進來，所以在使用 setInputText 的時候不用加上 props. 後者在使用時要寫 props.setInputText ，直接把參數傳進來的寫法會比較簡潔。 Form.js123456789101112const Form = ({ inputText ,setInputText }) =&gt; { //這是App.js中傳進來的參數 function handlechange(event){ setInputText(event.target.value) //更新inputText的值 console.log(event.target.value) //下面有log出來的效果 }&lt;input className=&quot;text&quot; type=&quot;text&quot; placeholder=&quot;Add a task...&quot; value={inputText} onChange={handlechange}/&gt; 結果會是這個樣子： 把用戶輸入的東西存進 todo list 裡運作邏輯：用戶輸入 task &gt; 按 summit button &gt; task 被加到 list 裡 增加 button onclick function. 在按下 button 之後，用戶輸入的值加到 todo list 裡，可以創造一個新的 hook 將 todo list 存進 array 裡。因此創造了const [todos, setTodos] = useState([])，初始值為空 array.與input一樣，這個功能會在 Form.js 裡完成，因此也要將參數往下傳。 App.js12345678const [todos, setTodos] = useState([])&lt;Form inputText={inputText} setInputText={setInputText} todos={todos} setTodos={setTodos} /&gt; 接著處理用戶輸入的資料。在把 todos, setTodos 傳進 Form.js 後，增加button 的 onclick，觸發 function 設為 submitHandleChange function. 這個 function 會更新 todos 這個 state，首先將原本就存在在 task 存進來，再增加用戶新輸入的 task. 用戶輸入的 task 會以 object 的形式傳進去，包括了 tasks 的名字 (text) 、是否完成 (completed:boolean)、id (使用亂數產生)。 Form.js1234567function submitHandleChange(e) { e.preventDefault() //移除默認 refresh 頁面 setTodos([ ...todos, {text: inputText, completed: false, id: Math.floor(Math.random()*100)} ]) setInputText(&quot;&quot;) //輸入完成後，框框上的字拿掉 } 可以使用 react debugger 來看 todos 這個 state 的變化。在輸入 task 後按下 submit button, state 就會立刻更新。 把輸入的 tasks ( 更新後的 state ) 渲染到瀏覽器上用戶輸入的 tasks 要加到 todo list 裡，這個部分要在 TodoList.js 進行。在 App.js 中把 todos 這個參數往下傳。 App.js1&lt; TodoList todos={todos}/&gt; 在 TodoList.js 裡，todos state 每一次更新，都要把資料往下傳到 todo.js 裡渲染。因此這裡使用 map() 遍歷 todos 裡的每一個 element ，除了輸入的 task 外，也要加上 key ，才不會報錯。 TodoList.js123456789101112const TodoList = ({todos}) =&gt; { console.log(todos) return( &lt;div className=&quot;todo-container&quot;&gt; &lt;ul className=&quot;todo-list&quot;&gt; {todos.map((todo) =&gt; ( &lt;Todo key={todo.id} text={todo.text}/&gt; ))} &lt;/ul&gt; &lt;/div&gt; )} 資料往下傳到 Todo.js 後，就會按照設定好的樣式傳染到瀏覽器上。 Todo.js123456789function Todo({text}) { return( &lt;div className=&quot;todo&quot;&gt; &lt;button className=&quot;check-btn&quot;&gt;&lt;i className=&quot;fas fa-check fa-xs&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;li className=&quot;todo-item&quot;&gt;{text}&lt;/li&gt; &lt;button className=&quot;trash-btn fa-xs&quot;&gt;&lt;i className=&quot;fas fa-times &quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; )} 增加刪除功能有關 task 本 task 的處理，都在 Todo.js裡處理。刪除功能是直接操作 todos state, 因此會調用到 todos 以及 setTodos. 這兩個參數要從要從最頂層的 App.js 往下傳到 TodoList.js ，然後再往下傳到 Todo.js 中. 創造新的 function , 使用filter()來過濾掉不符合條件的 element. 這裡的條件設定為：todos state 中的 element 與 被點擊的 element 之 id 如果不相同就會被留下，相同就表示那是是用戶要刪掉的 element，因為不符合條件所以就被過濾掉了。 Todo.js123function deleteHandleChange(){ setTodos(todos.filter((el) =&gt; el.id !== todo.id)) } 增加 task completed 功能創造新的 function , 使用 map() 遍歷 todos state, 如果 element id 等於被點擊的 item 的 id，就將該 element 的 completed 的 boolean 改成相反的。最後再返回該item. Todo.js1234567891011function CompleteHandleChange(){ setTodos(todos.map((item =&gt;{ if(item.id === todo.id){ return{ ...item, completed: !item.completed } } return item } ))) } 接著處理 UI 的部分，完成後會顯示打打勾、一槓、灰色字。可以用 todo.complete 來判斷是否要加入某個className. Todo.js1234567891011121314151617181920212223//打勾勾//todo.complete 為false時，打勾設定與背景同顏色//todo.complete 為true時，加入&quot;completed-checkbox&quot;，打勾更改為黑色&lt; i className={`fas fa-check fa-xs ${todo.completed? &quot;completed-checkbox&quot; : &quot;&quot;}`}&gt;&lt;/i&gt;//CSS//背景為灰色，打勾也是灰色.check-btn{ display: block; font-weight: 100; padding: .1em .25em; margin-left: 1em; border: none; border-radius: 7px; background-color: #DFDFDF; color: #DFDFDF;}//完成後，打勾顏色更改為黑色.completed-checkbox{ color:black} Todo.js12345678//一槓、灰色字&lt;li className={`todo-item ${todo.completed? &quot;completed &quot; : &quot;&quot;}`}&gt;{text}&lt;/li&gt;//CSS.completed { text-decoration: line-through; opacity: 0.5;} 製作 filter 功能 (All / Complete / Uncomplete)先創造一個 status state 來儲存點擊 option 後的結果。這個 state 會在 Form 中處理，因此要把參數往下傳。 App.js12345678910//把setStatus往下傳，會在 form.js 處理const [status, setStatus] = useState(&quot;all&quot;)//默認為all&lt;Form todos={todos} setTodos={setTodos} inputText={inputText} setInputText={setInputText} setStatus={setStatus} /&gt; 因為選單在 Form.js 裡，因此在 Form.js 處理。設定選單改變時要執行的 function : 更新 setStatus 成點選的選項。選擇 complete的話，這裡 setStatus 就會更新為 completed. Form.js123function statusHandleChange(event){ setStatus(event.target.value)} 再創造一個 filtered state 來儲存被加進來的 task。創造一個新的 state 是為了不要影響到原本用來儲存 tasks 的 todos state. 過濾後的tasks 會被儲存在這個 state. App.js12345678//會在 Todolish.js 中處理const [filteredTodo, setFilteredTodo] = useState([])&lt;TodoList setTodos={setTodos} todos={todos} setFilteredTodo={setFilteredTodo}/&gt; 接著設定 filter 的條件，這裡使用 switch() 來處理 All/completed/uncompleted 的情況。 App.js1234567891011121314151617function filterHandlerChange(){ switch(status){ //這個status的值是 : 點擊 option 後更新的值 //在 &lt;option value=&quot;completed&quot; 的狀況下&gt; case &quot;completed&quot; : //如果是 complete 就過濾出 completed 為 true 的 tasks setFilteredTodos(todos.filter((todo) =&gt; todo.completed === true)) break case &quot;uncompleted&quot; : setFilteredTodos(todos.filter((todo) =&gt; todo.completed === false)) break default: setFilteredTodos(todos) break } } FilteredTodos 會在 tasks 存進 todos state 以及 option 被選擇的時候更新。使用 useEffect 來設定當上述兩種情況發生時，FilteredTodos 執行 function filterHandlerChange。 App.js123useEffect(() =&gt; { filterHandlerChange() }, [todos,status]) 小結到這裡，基本的增、刪、過濾功能就已經完成了。當中遇到無法成功渲染的多數原因為，沒有將參數往下傳到各個 Component 中，在這次的練習中深刻體現要了解自己寫的每一行程式碼的意思，出錯了才有辦法找到 bug 在哪裡。經過這次練習，對拆分的 component 間要如何傳遞以及 React 的寫法都比較熟悉了一些。希望下一個練習可以挑戰更複雜的（堅定臉。 由於主要目的是熟悉 React 的寫法，界面就沒有弄得很 fancy ，就讓他陽春陽春的XD如果有任何不對的地方/有更好的寫法，再麻煩各位大大指教！ :) 參考資料Build A Todo App With REACT | React Project For Beginners (FULL).","link":"/2021/04/17/0417-todo/"},{"title":"【實作記錄】 Movie Search App | React","text":"Github : 點我看原始碼. 簡介這個為了練習使用 React 的邏輯以及編寫方式根據教學刻的簡單頁面。這裡練習了如何使用 TMDB 提供的 API 來獲取需要的資料、Hook以及拆分 component 的方法。下面詳細記錄了自己的學習步驟，參考資料附在文末。 功能 輸入關鍵字後按搜尋就可以搜到電影 電影資訊包括海報、名字、簡介、發行日期 無法顯示的照片使用替代照片顯示 前置作業 需要使用的 API : The Movie Database API 先到 TMDB 網站申請賬號，再根據官方文件申請網站的 API key .文件上都有清楚的申請步驟，申請成功後，把 key 以及 Access Token 保存下來。 這裡共建立了3個文件 : index.js App.js index.css MovieCard.js 步驟設置基本結構以及樣式簡單設置需要使用到的 class component ，在內添加 JRX 以及引入外部 CSS file 用以測試文件是否能夠渲染到瀏覽器上。 index.js1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';import './index.css';class Main extends React.Component{ render() { return ( &lt;div className=&quot;container&quot;&gt; &lt;header&gt; &lt;h1 className=&quot;title&quot;&gt; Search a movie.&lt;/h1&gt; &lt;/header&gt; &lt;/div&gt; ) }}ReactDOM.render(&lt;Main /&gt;,document.getElementById('root')); 創造一個 component使用 form 創造一個 searchMovie component ，裡面需要有 input, label 以及 submit button. 在文件的結尾 export 後，再於 index.js file 中引入 App.js. App.js12345678910111213function Search(){ return ( &lt;form className=&quot;form&quot;&gt; &lt;label htmlFor=&quot;query&quot;&gt;Movie name&lt;/label&gt; &lt;input type = &quot;text&quot; name = &quot;query&quot; placeholder = &quot;Goziila vs Kong...&quot; /&gt; &lt;button className=&quot;submitBtn&quot; type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ) } 透過 API 抓取需要的資料首先創造 searchMovies function，在 button 添加 onSubmit attribute 指向剛才創造的function. 這個 function 要先將原本 onSubmit 預設的動作清除 (preventDefault) 加上我們想要的操作。在加上需要執行的程式碼前，可以先簡單測試是否成功將預設的動作清除。 App.js1234567//簡單測試const searchMovies = (e) =&gt;{ e.preventDefault() console.log(&quot;submitting&quot;) }&gt;&gt; submitting //如果成功清除會log出設定的字樣 使用 fetch 獲取資料的方法有兩種 : 使用 promise (.then .catch) &amp; async / await . 這裡使用 async / await 的方式來操作。 API的組成如下，當中的搜索方式，TMDB 提供了了三種：search / discover /find，各有不同的功能，詳細的可以查看官方文件。 除了成功取得資料外，亦要考慮無法獲得資料的情況，因此可以使用 try catch 來做 error handling. 在還沒獲取用戶輸入的資料前，可以先設置 query 來測試 API 是否運作順利。 App.js12345678910111213141516const searchMovies = async (e) =&gt;{ e.preventDefault() console.log(&quot;submitting&quot;) const query = &quot;Jurassic Park&quot; //測試用，query 應是用戶輸入的資料 const url = `https://api.themoviedb.org/3/search/movie/?api_key=039fb05cf43fd8268accfcc0c73bec24&amp;language=en-US&amp;query=${query}` try{ //成功的情況 const res = await fetch(url) const data = await res.json() console.log(data) }catch(err){ //失敗的情況 console.error(err) } } 成功獲得資料的結果如下，搜尋 “Jurassic Park” 會出現15筆資料。我們需要的資料存在 results 裡。 使用 useState, useEffect 更新 query在 input 內添加 value , value 為 {query}，即是用戶輸入的資訊。使用 useState 和useEffect 來更新 value 的值。const [query, setQuery] = useState(&quot;&quot;) query 為value 變數；setQuery 用來更新 query 的值；useState 內的則是query的初始值。在 input 中添加 onChange，使用 setQuery 更新 value 。 App.js123456789const [query, setQuery] = useState(&quot;&quot;);&lt;input type = &quot;text&quot; name = &quot;query&quot; placeholder = &quot;Goziila vs Kong...&quot; value = {query} //添加value onChange ={(e) =&gt; setQuery(e.target.value)} //更新value/&gt; 使用 useState, useEffect 更新 movie (顯示給用戶的資料)獲得搜尋資料之後，需要將這些資料渲染到瀏覽器，因此需要一個 array 來存取這些資料。一樣先使用 useState 要設置 movies array，再用 useEffect 更新。把 movies array 更新成搜尋後獲得的資料。 App.js1234567891011const [movies, setMovies] = useState([]) //movies是個arraytry{ const res = await fetch(url) const data = await res.json() setMovies(data.results) //把 movies array 更新成搜尋後獲得的資料 }catch(err){ console.error(err) }} 把搜尋結果呈現在畫面上 需要顯示在畫面上的資訊有：海報（poster_path），發行日期（release_date），電影簡介（overview），評分（vote_average）。可以用 movies array（裡面有剛才存進去的資料） 中調用我們需要的資料。使用 map 遍歷每一個搜尋結果，調用需要的資訊。 App.js12345678910&lt;div className=&quot;card-list&quot;&gt; {movies.map(movie =&gt; ( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; //使用map都要加上key &lt;h3&gt;{movie.title}&lt;/h3&gt; //標題 &lt;p&gt;Release date: {movie.release_date}&lt;/p&gt; //發行日期 &lt;p&gt;OverView: {movie.overview}&lt;/p&gt; //簡介 &lt;p&gt;Rating: {movie.vote_average}&lt;/p&gt; //評分 &lt;/div&gt; ))}&lt;/div&gt; 海報照片有固定的 url 格式，改變的只有結尾的 poster_path ，因此只要更換最後這個部分就可以獲得海報連接。某些原本就沒有海報照片的電影會無法顯示，可以使用兩種方法解決這個狀況：直接篩掉沒有海報的電影或是顯示代替圖案。 https://image.tmdb.org/t/p/[width size]/[poster_path] 方法1 : 直接篩掉沒有海報的電影 (.fliter) App.js12345678910&lt;div className=&quot;card-list&quot;&gt;//使用 .filter 只抓取 poster_path 為 true 的電影{movies.filter(movie =&gt; movie.poster_path).map(movie =&gt;( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title}/&gt; &lt;/div&gt; ))}&lt;/div&gt; 方法2 : 顯示代替圖案 (onError) App.js123456789101112&lt;div className=&quot;card-list&quot;&gt; {movies.map(movie =&gt; ( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title} //當url為null時，使用替代圖片 onError={(e)=&gt;{e.target.onerror = null; e.target.src=&quot;https://i.postimg.cc/3RpfrHDh/photo.png&quot;}} /&gt; &lt;/div&gt; ))}&lt;/div&gt; 把電影的 card 拆出來變成單獨的 component 在 App.js 中的 function 裡加上 props App.js1function Search(props) 建立 MovieCard.js 存放 card component 由於 MovieCard.js 裡抓不到 movie ，要加上props.movie 這樣才能取得 App.js file 的 movie MovieCard.js123456789101112131415161718192021222324252627//filename : MovieCard.jsimport React from &quot;react&quot;function MovieCard({movie}){ // 這個意思是 : // const movie = props.movie// 也等於這個 :// const {movie} = prop.movie// 最後可以簡化成這樣，如此在 App.js 裡就可以傳進參數return( &lt;div className=&quot;card-info&quot; &gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title} onError={(e)=&gt;{e.target.onerror = null; e.target.src=&quot;https://i.postimg.cc/3RpfrHDh/photo.png&quot;}} /&gt; &lt;h3&gt;{movie.title}&lt;/h3&gt; &lt;p&gt;Release date: {movie.release_date}&lt;/p&gt; &lt;p&gt;OverView: {movie.overview}&lt;/p&gt; &lt;p&gt;Rating: {movie.vote_average}&lt;/p&gt; &lt;/div&gt;)}export default MovieCard 到這裡會發現key會報錯，只要把 {key={movie.id}} 加到 裡就可以解決。 總結完成上面的步驟，這個簡單的電影搜尋的頁面就已經完成了。最後撒一些魔法粉變成好看的樣子就可以了。由於這個是為了練習 react 語法用的，因此沒有花太多時間和心思在畫面上，所以就像 Demo 這樣長得醜醜的 QAQ 還不熟悉 React 的寫法，若有錯誤或是可以寫得更好的地方再麻煩各位大大指點 :) 參考資料Learn React in 1 Hour by Building a Movie Search App","link":"/2021/04/13/0413-movie/"},{"title":"【實作記錄】 玻璃擬態登入頁面 | Vanilla Js","text":"Github : 點我看原始碼Code Pen : 點我進去玩玩看 簡介這是接觸網頁前端三巨頭時練習的第一個小作品。尚未學習RWD之觀念，因此畫面在手機觀看會爆掉QAQ。頁面呈現玻璃擬態(Glassmorphism)效果。 功能 CSS : 用戶輸入的部分設置了Placeholder CSS : 每一個預設可以點擊之按鈕都設置了hover效果 JS : 用戶點擊Sign in 按鈕後，先前輸入的資料會淨空 JS : 設置了用戶輸入提醒，若缺少用戶名/密碼將會跳出警告 JS : 用戶名與密碼藉有輸入將會跳出”username, Welcome!”之字樣 小筆記記錄一些CSS小筆記，作往後回顧之用。 Glassmorphism效果12345678910111213.loginSec{ padding: 42px 22px; border-radius: 10px; background-color: rgba(255, 255, 255, 0.10); border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); box-shadow: 0 0.9px 8.5px -9px rgba(0, 0, 0, 0.041), 0 2.4px 23.5px -9px rgba(0, 0, 0, 0.069), 0 5.7px 56.7px -9px rgba(0, 0, 0, 0.098), 0 19px 188px -9px rgba(0, 0, 0, 0.16) ;} Hover底線效果1234567891011121314#forgetBtn::after{ content: ''; display: block; border-bottom: solid 1.3px #ffffff; height: 1.3px; transform: scaleX(0); transform-origin: 0% 100%; transition: transform .3s;}#forgetBtn:hover:after{ transform: scaleX(1); transition: transform .3s;} 背景圖縮放不影響比例1234567body{ background-image: url(&quot;https://i.postimg.cc/3rv5HhSL/login-page-background.png&quot;); background-repeat: no-repeat; background-size: cover; background-position: center center; background-attachment: fixed;} 小結這個畫面可以改進的地方有很多，但由於是第一次練習，因此沒有特別修改，想留下一些 黑歷史 記錄。這篇筆記為個人學習記錄，若有錯誤或是可以更好改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/03/0303-login/"},{"title":"【學習筆記】 表單 | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 Controlled ComponentReact 創建表單的方式有兩種：Controlled Component 以及 Uncontrolled Component。前者的表單的資料是被 React component 所處理；後者表單的資料則由 DOM 本身處理。多數情況下建議使用 controlled component. Text在 React 中，可變的 state 通常是被維持在 component 中的 state property，並只能以 setState() 來更新。State 在用戶每次輸入的時候都會更新，如果將用戶輸入的資訊都印出來，字會隨著用戶輸入的一個一個字出現（結尾有示範影片）。 建立react component 在render()中設定需要的input 在this.state中初始化firstName/lastName的值 12345678class APP extends Component{ constructor(){ super() this.state = { firstName : &quot;&quot;, lastName : &quot;&quot; } } 設定 onChange 的function(handleChange)為了抓取用戶說輸入的資訊再更新 State，因此要在 input 中加入onChange，將其指向更新 function (這裡指向 handleChange function)。每次用戶輸入時，state 都會更新。與此同時綁定 function 以及 state. 在 handleChange function 中為 fisrtName / lastName 重新賦值。 1this.handleChange = this.handleChange.bind(this) 為了避免重新賦值時有錯誤，因此要為 input 個別設定 name（在input 中加入name）。在 handleChange function 中就可以直接指向 input 的 name. 無論是哪一種 input 都應該使用這樣的方式去更新資料。 123456handleChange(event){ this.setState({ //不直接寫firstName : event.target.value [event.target.name] : event.target.value }) } 為input添加value attribute讓 this.state 的 value 等於用戶輸入的樣子。 完整程式碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, { Component } from &quot;react&quot;class APP extends Component{ constructor(){ super() this.state = { //初始化 firstName : &quot;&quot;, lastName : &quot;&quot; } this.handleChange = this.handleChange.bind(this) //綁定 } //可以簡化成這樣 handleChange(event){ const {name, value} = event.target this.setState({ [name] : value } ) } render(){ return( &lt;form&gt; &lt;label&gt;First Name &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;firstName&quot; value={this.state.firstName} onChange={this.handleChange} /&gt; &lt;br/&gt; &lt;label&gt;Last Name &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot; value={this.state.lastName} onChange={this.handleChange} /&gt; &lt;p&gt;{this.state.firstName}{this.state.lastName}&lt;/p&gt; //印出來 &lt;/form&gt; ) }}export default APP TextArea跟原 HTML 的寫法有些不同，在 HTML 中，一個 textarea 的 element 是經由它的 children 來定義它的文字。React 中的則是使用 value attribute。 1&lt;textarea value={&quot;Some default value&quot;}/&gt; Checkboxcheckbox 中的 checked attribute 是 boolean，可在 this.state 中設定它的值。checkbox 可以讓用戶勾選/不勾選，因此需要設定 onChange 讓 checked 變成可改變的。 12345&lt;input type=&quot;checkbox&quot; checked={boolean} onChange={function}/&gt; Radioradio 跟 checkbox 的寫法很類似。同一組的 radio button 要設置相同的名字，這樣才會被認為是一組，才能從中擇一。 12345678910111213141516171819&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked={this.state.gender === &quot;male&quot;} onChange={} /&gt; Male&lt;/label&gt;&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; checked={this.state.gender === &quot;female&quot;} onChange={} /&gt; Female&lt;/label&gt; Selectselect 的下拉式選單中，預設被選定的值與 HTML 中寫的不同，React使用 value 這個 attribute 來選定預設的值，範例中預設被選定的是 ‘blue’ 。 123456789101112&lt;label&gt;Favorite Color: &lt;/label&gt; &lt;select value={&quot;blue&quot;} //預設值 onChange={this.handleChange} name=&quot;favColor&quot; &gt; &lt;option value=&quot;blue&quot;&gt;Blue&lt;/option&gt; &lt;option value=&quot;green&quot;&gt;Green&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;Red&lt;/option&gt; &lt;option value=&quot;orange&quot;&gt;Orange&lt;/option&gt; &lt;option value=&quot;yellow&quot;&gt;Yellow&lt;/option&gt; &lt;/select&gt; 範例Travel form 實作一個簡單的 Travel form，使用了&lt; text &gt; &lt; textarea &gt; &lt; checkbox &gt; &lt; radio &gt; 以及 &lt; select &gt;。 表單內容包括： First Name/ Last Name : text Age : number Gender : radio Destination : select Dietary restrictions: checkbox 解法 首先建立 react component 以及需要的 input。 創建操縱每個 input 改變的function + binding 為了讓 input 的值得以改變 12345function handleChange(event){ this.state({ xxx })} First Name/ Last Name/ Age : text 為了收到用戶的輸入以及及時改變 state，input 內需要onchange 以及 value 兩個attribute ( 其他 type 亦然 ) onchange: 當用戶輸入時，就會立刻執行指向的 function，立即更新 state value : 會指向 function 更新完後的 value 123456handleChange(event){ const {name, value} = event.target this.setState({ [name] : value //event.target.name選中的是input裡的'name' }) } 1234567&lt;input type=&quot;text&quot; name=&quot;firstName&quot; placeholder=&quot;First Name&quot; value={this.state.firstName} onChange={this.handleChange}/&gt; Gender : radio input 內加上 onchange（ 指向 handleChange function ） &amp; value 跟 checkbox 的原理相似，擇一的功能需要依賴 check 12345678&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; //當state是female時，就可以選到 checked={this.state.gender === &quot;female&quot;} onChange={this.handleChange}/&gt;Female Destination : select input 內加上 onchange（ 指向 handleChange function ） &amp; value 選項默認會是第一個，但這個選項不會被取得，需要切換到第二個選項再切回來才會被選中 1234567891011&lt;select value={this.state.destination} name=&quot;destination&quot; onChange={this.handleChange} &gt; &lt;option value=&quot;&quot;&gt;---Please choose a planet---&lt;/option&gt; &lt;option value=&quot;🪐Tatooine&quot;&gt;🪐Tatooine&lt;/option&gt; &lt;option value=&quot;🌖Alderaan&quot;&gt;🌖Alderaan&lt;/option&gt; &lt;option value=&quot;☀️Hoth&quot;&gt;☀️Hoth&lt;/option&gt; &lt;option value=&quot;⭐Bespin&quot;&gt;⭐Bespin&lt;/option&gt;&lt;/select&gt; Dietary restrictions: checkbox 設定每一個初始值為 false 使用checked來改變 function funtion 調整 這幾種 input 會分成兩種狀況：適用於 checkbox 的以及 checkbox 以外的。因為只分為兩種狀況，因此可以使用 if type 等於 checkbox 就執行冒號前的，不等於 checkbox 則執行冒號後的 結果顯示Yes / No 1234567//先設定每一個選項的 booleanthis.state = { isFish: false, isBread : false, isMilk : false,} 12345678//input的checked&lt;input type=&quot;checkbox&quot; name=&quot;isFish&quot; checked={this.state.isFish} onChange={this.handleChange} /&gt;Colo Claw Fish 12345678910111213//function調整handleChange(event){ const {name, value, type, checked} = event.target type === &quot;checkbox&quot; ? this.setState({ [name] : checked //checkbox的情況 }) : this.setState({ //其他的的情況 [name] : value, }) } 12//結果顯示&lt;p&gt;Colo Claw Fish : {this.state.isFish ? &quot;Yes&quot;:&quot;No&quot;}&lt;/p&gt; 小結直接刻表單程式碼會落落長的，所以可以分好 Component 讓程式碼比較好維護. 另外也有 Formik 這個工具，主打無痛創造 React 表單，但這個還沒仔細研究過。（坑待補） 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :) 參考資料 React Forms Presentational and Container Components","link":"/2021/04/09/0409-form-note/"},{"title":"【學習筆記】 useState | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 Function Component function component 長這樣 12345678910//function componentimport React from &quot;react&quot;function App() { return ( &lt;div&gt; &lt;h1&gt;Is state important to know? Yes&lt;/h1&gt; &lt;/div&gt; )} 123456789101112131415//例子import React, {useState} from &quot;react&quot; //引入useStatefunction App() { //這裡的state不一定要是object const [answer] = useState(&quot;Yes&quot;) const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: 'Learn Hooks' }])//這裡可以宣告多個變數 return ( &lt;div&gt; &lt;h1&gt;Is state important to know? {answer}&lt;/h1&gt; &lt;/div&gt; )} 宣告一個 state 變數 1const [目前 state 數值, function] = useState(initial value) useState 回傳一組數值：目前 state 數值和一個可以讓你更新 state 的 function 與 class component 不同，state 不一定要是object 與 class component this.state({name: value, name: value}) 相似，它可以宣告多個變數 計數器例子 12345import React, { useState } from 'react';function Example() { // 宣告一個新的 state 變數，稱為「count」 const [count, setCount] = useState(0);//不一定要是object useState 宣告了一個變數，這個變數會被保存起來 傳入 useState 的是這個變數的起始值，這個起始值可以不需要是 object，這裡因為計數器需要所以傳入 num 起始值只在第一次 render 的時候會使用到 讀取 State 與 class component 讀取 state 的方式不同 &lt;p&gt; {this.state.count} &lt;/p&gt; ，function component 可以直接讀取變數{count} 1&lt;h1&gt; {count} &lt;/h1&gt; 更新 state 可以直接用 setCount 和 count 直接更新123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; 總結 第 1 行 : 引入 useState 第 5 行 : 在 App component 裡，呼叫 useState Hook 宣告了一個新的 state 變數，成為 count ( 作計數用 )。將起始值設為 0 並傳入 useState 當作唯一參數。第二個回傳的值是個可以更新 count 的 function，命名為 setCount。 第 18 , 19 行：當使用者點擊，就呼叫 increment/ decrement function , setcount 更新 count 的值。 12345678910111213141516171819202122import React, {useState} from &quot;react&quot;function App() { // 宣告一個新的 state 變數，稱為 count const [count, setCount] = useState(0) function increment() { setCount(prevCount =&gt; prevCount + 1) } function decrement() { setCount(prevCount =&gt; prevCount - 1) } return ( &lt;div&gt; &lt;h1&gt; {count} &lt;/h1&gt; &lt;button onClick = {increment} &gt;Increment&lt;/button&gt; &lt;button onClick = {decrement} &gt;Decrement&lt;/button&gt; &lt;/div&gt; )} 綜合例子123456789101112131415161718192021222324252627282930313233343536373839404142import React, {useState} from &quot;react&quot;function App() { const [inputData, setInputData] = useState({firstName: &quot;&quot;, lastName: &quot;&quot;}) const [contactsData, setContactsData] = useState([]) function handleChange(event) { const {name, value} = event.target setInputData(prevInputData =&gt; ({...prevInputData, [name]: value})) } function handleSubmit(event) { event.preventDefault() setContactsData(prevContacts =&gt; [...prevContacts, inputData]) } const contacts = contactsData.map(contact =&gt; &lt;h2 key={contact.firstName + contact.lastName}&gt;{contact.firstName} {contact.lastName}&lt;/h2&gt;) return ( &lt;&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;input placeholder=&quot;First Name&quot; name=&quot;firstName&quot; value={inputData.firstName} onChange={handleChange} /&gt; &lt;input placeholder=&quot;Last Name&quot; name=&quot;lastName&quot; value={inputData.lastName} onChange={handleChange} /&gt; &lt;br /&gt; &lt;button&gt;Add contact&lt;/button&gt; &lt;/form&gt; {contacts} &lt;/&gt; )}export default App 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :) 參考資料 使用 State Hook 【React.js入門 - 20】 useEffect - 在function component用生命週期","link":"/2021/04/10/0410-note-usestate/"},{"title":"【學習筆記】 useEffect | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 useEffect 小栗子 可運作 side effect （可以影響其他 component 且在 render 期間無法完成的），如 fetch 資料、訂閱、或手動改變 DOM。 useEffect 包含了 componentDidMount ，componentDidUpdate ，以及 componentWillUnmount 的功能 每一次render都會執行useEffect，因此要設定在某個條件下才會觸發這個 function 計數器例子 12345678910111213141516171819202122import React, { useState, useEffect } from 'react'; //引入useEffectfunction Example() { const [count, setCount] = useState(0); // 與 componentDidMount 和 componentDidUpdate 類似： useEffect(() =&gt; { // 使用瀏覽器 API 更新文件標題 document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );}export default Example 計數器+random color例子 123456789101112131415161718192021222324252627282930import React, {useState, useEffect} from &quot;react&quot;import randomcolor from &quot;randomcolor&quot; //這引入了別的libraryfunction App() { const [count, setCount] = useState(0) const [color, setColor] = useState(&quot;&quot;) function increment() { setCount(prevCount =&gt; prevCount + 1) } function decrement() { setCount(prevCount =&gt; prevCount - 1) } useEffect(() =&gt; { setColor(randomcolor()) }, [count]) //執行條件設為當count改變時 return ( &lt;div&gt; &lt;h1 style={{color: color}}&gt;{count}&lt;/h1&gt; &lt;button onClick={increment}&gt;Increment&lt;/button&gt; &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt; &lt;/div&gt; )}export default App 注意 因為每一次render，都會重新呼叫useEffect這個function，所以要設定條件。12345//這樣寫會導致這個function一直被呼叫useEffect(() =&gt; { setColor(randomcolor())}) ==BUG== ==預設情況== 清除 effect 這裡指的 effect 就是我們傳進 useEffect 的 fucntion 每個 effect 都可以回傳一個會在它之後執行清除的 function 一個在執行之後需要清除的 function，可以在新增 function 後回傳一個需要清除的 function 其他不需要清除的就不需要回傳 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :)","link":"/2021/04/10/0411-note-useeffect/"},{"title":"【學習筆記】 Context | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 簡介React 中的 component 傳遞是由上往下的，無法在同級的 component 間 / 在其他的分支間傳遞。如果要在同級間傳遞，就要將 state 提升到上一層 component，如果在不同分支，就要一直往上提升到兩個 component 間都有共用的為止。往上提升後，再把 props 一層一層往下傳，傳到天荒地老。 Context 可以解決這種狀況。提供資料的稱為 Provider ，使用資料的為 Consumer。把需要共用的資料包在 Provider 裡，需要調用資料的用 Comsumer 包起來。Consumer 不用通過中間一層一層的傳遞，就可以直接使用 Provider 中的資料。除了 Data , Method 也可以通過這個方法傳遞，如果當某個 components 更新後，需要同時將共用這個 method 的 component 一併更新也可以做到。 使用方式用 Provider 把 包起來123456//創造 contextconst Context名字 = React.createContext() &lt;Context名字.Provider value={&quot;dark&quot;}&gt; //value 是必要的 &lt;App /&gt;&lt;/Context名字.Provider&gt; Consumer 調用 dataclass component 方法一 : 在component 外引用1234需要引用資料的 component.contextType = 被創造的 provider//例子Button.contextType = ThemeContext 方法二 : 在 conponent 內引用 ( render() 前)1234static contextType = 被創造的 provider//例子static contextType = ThemeContext function component 123&lt;Context名字.Consumer&gt; function&lt;/Context名字.Consumer&gt; 使用 &lt;Context名字.Consumer&gt; 包起來，裡面必須要是 function 是 render props pattern 🌰 栗子 : 使用 context 處理點擊 button 後轉換主題的效果 基本的 context 架構123456789101112131415161718// filename : App.js// 引入 Header 以及 Button import React from &quot;react&quot;import Header from &quot;./Header&quot;import Button from &quot;./Button&quot;function App() { return ( &lt;div&gt; &lt;Header /&gt; &lt;Button /&gt; &lt;/div&gt; )}export default App 123456// filename : ThemeContext.js// 創造 contextimport React from &quot;react&quot;const ThemeContext = React.createContext()export default ThemeContext 1234567891011121314151617// filename : index.js// 使用 context providerimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import ThemeContext from &quot;./ThemeContext&quot;ReactDOM.render( //使用theme context 的 method, Provider 沒有自己的component //後續會提到怎麼處理 &lt;ThemeContext.Provider value={&quot;dark&quot;}&gt; &lt;App /&gt; &lt;/ThemeContext.Provider&gt;, document.getElementById('root')) 1234567891011121314151617// filename : Button.js// 使用 context consumer + 簡單的判斷處理import React from &quot;react&quot;import ThemeContext from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;button className={`${theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContext.Consumer&gt; ) }export default Button 12345678910111213141516171819// filename : Header.js// 使用 context consumer + 簡單的判斷處理import React from &quot;react&quot;import ThemeContext from &quot;./ThemeContext&quot;function Header (){ return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;header className={`${theme}-theme`}&gt; &lt;h2&gt;{theme === &quot;light&quot; ? &quot;Light&quot; : &quot;Dark&quot;} Theme&lt;/h2&gt; &lt;/header&gt; )} &lt;/ThemeContext.Consumer&gt; )} export default Header 截至這裡，效果如下。如果將 &lt;ThemeContext.Provider value={&quot;dark&quot;}&gt; 更換成 “light” 就會是 Light Theme. 現在要添加 switch button 切換主題的功能。如果要實現這個功能，需要使用到 state ，但現在 Context Provider 沒有自己的 component，因此要處理這個部分。 把 Context Provider 移到自己的 component現在要把 Context Provider 移到自己的 component，後續才能在該 component 裡處理 state. 123456// 原本的// filename : ThemeContext.jsimport React from &quot;react&quot;const ThemeContext = React.createContext()export default ThemeContext 1234567891011121314151617// 調整後// filename : ThemeContext.jsimport React, { Component } from &quot;react&quot;const {Provider, Consumer} = React.createContext()class ThemeContextProvider extends Component { render() { return ( &lt;Provider value={&quot;light&quot;}&gt; {this.props.children} &lt;/Provider&gt; ) }}export {ThemeContextProvider, Consumer as ThemeContextConsumer} 第 7 行 : 創造 ThemeContextProvider component, 這個 component 是之後要在 index.js 中被引用的。index.js 中引入的是 &lt;ThemeContext.Provider&gt; , 所以才這個 component 中要放入 &lt;ThemeContext.Provider&gt;. 第 11 行 : 確保所有 children 都會被 render. 第 5 行 : ThemeContext 本身就帶有 ThemeContext.Provider 以及 ThemeContext.Consumer，因此可以寫成 {Provider, Consumer}, 第 10 行 : 同時 return 內的 &lt;ThemeContext.Provider&gt; 就可以只寫成 &lt; Provider &gt;. 第 12 行 : 要把 ThemeContextProvider export 出去，但不能只寫 export default ThemeContextProvider , 這樣只會 export 這個 component. Header.js &amp; Button.js 會用到 ThemeContext，因此要把兩個都 export 出去。 第 17 行 : 在export 時，除了 ThemeContextProvider , Consumer 會以 ThemeContextConsumer export 出去。 由於 ThemeContext.js 中 export 出去的東西改變了，因此其他文件中也要修改。修改完後，結果會與上面的一樣。 1234567891011121314151617//filename : Button.js//Header.js &amp; index.js 同理import React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContextConsumer&gt; {theme =&gt; ( &lt;button className={`${theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContextConsumer&gt; ) }export default Button 修改 context : 增加 state 在 ThemeContext.js 中增加 state 以及轉換 theme 的 function 123456789101112131415161718192021222324252627282930//filename : ThemeContext.jsimport React, { Component } from &quot;react&quot;const {Provider, Consumer} = React.createContext()class ThemeContextProvider extends Component { //增加 state state = { theme : &quot;light&quot; } //增加轉換的 function toggleTheme = () =&gt;{ this.setState(prevstate =&gt;{ return{ theme : prevstate.theme === &quot;light&quot; ? &quot;dark&quot;:&quot;light&quot; } }) } render() { return ( &lt;Provider value={{theme: this.state.theme, toggleTheme: this.toggleTheme}}&gt; //value 可以傳 object {this.props.children} &lt;/Provider&gt; ) }}export {ThemeContextProvider, Consumer as ThemeContextConsumer} 把 state 和 function toggleTheme 連接到 Button.js, Header.js 中 1234567891011121314151617//filename : Button.jsimport React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContextConsumer&gt; {context =&gt; ( &lt;button onClick={context.toggleTheme} className={`${context.theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContextConsumer&gt; ) }export default Button 12345678910111213141516171819//filename : Header.jsimport React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Header (){ return ( &lt;ThemeContextConsumer&gt; {context =&gt; ( &lt;header className={`${context.theme}-theme`}&gt; &lt;h2&gt;{context.theme === &quot;light&quot; ? &quot;Light&quot; : &quot;Dark&quot;} Theme&lt;/h2&gt; &lt;/header&gt; )} &lt;/ThemeContextConsumer&gt; )} export default Header 🌰 另一個栗子 : 使用 context 處理讓用戶更換 username 基本的 context 架構123456//filename : UserContext.jsimport React from &quot;react&quot;//創造 contextconst UserContext = React.createContext()export default UserContext 123456789101112131415//filename : index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &quot;./index.css&quot;import App from &quot;./App&quot;import UserContext from &quot;./userContext&quot;ReactDOM.render(//把 &lt;App/&gt; 包起來 &lt;UserContext.Provider value={&quot;Luke Skywalker&quot;}&gt; &lt;App /&gt; &lt;/UserContext.Provider&gt;, document.getElementById(&quot;root&quot;)) 123456789101112131415161718192021222324252627//filename : App.js//class componentimport React from &quot;react&quot;import Header from &quot;./Header&quot;import UserContext from &quot;./userContext&quot;class App extends React.Component { //引用 static contextType = UserContext render() { // 調用 this.context // this.context 是 index.js &lt;ThemeContext.Provider&gt;傳進來的 value const username = this.context return ( &lt;div&gt; &lt;Header /&gt; &lt;main&gt; &lt;p className=&quot;main&quot;&gt;No new notifications, {username}! 🎉&lt;/p&gt; &lt;/main&gt; &lt;/div&gt; ) }}export default App 12345678910111213141516171819//filename : Header.js//function componentimport React, {Component} from &quot;react&quot;import UserContext from &quot;./userContext&quot;function Header(props){ //傳進 props return( &lt;UserContext.Consumer&gt; //裡面要包 function {username =&gt; ( &lt;header&gt; &lt;p&gt;Welcome, {username}!&lt;/p&gt; &lt;/header&gt; )} &lt;/UserContext.Consumer&gt; )} export default Header 增加功能123456789101112131415//filename :index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &quot;./index.css&quot;import App from &quot;./App&quot;import {UserContextProvider} from &quot;./userContext&quot;ReactDOM.render( &lt;UserContextProvider&gt; &lt;App /&gt; &lt;/UserContextProvider&gt;, document.getElementById(&quot;root&quot;)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344//filename : App.jsimport React from &quot;react&quot;import Header from &quot;./Header&quot;import {UserContextConsumer} from &quot;./userContext&quot;class App extends React.Component { state = { newUsername: &quot;&quot; } handleChange = (e) =&gt; { const {name, value} = e.target this.setState({[name]: value}) } render() { return ( &lt;div&gt; &lt;Header /&gt; &lt;UserContextConsumer&gt; {({username, changeUsername}) =&gt; ( &lt;main&gt; &lt;p className=&quot;main&quot;&gt;No new notifications, {username}! 🎉&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;newUsername&quot; placeholder=&quot;New username&quot; value={this.state.newUsername} onChange={this.handleChange} /&gt; &lt;br/&gt; &lt;button onClick={() =&gt; changeUsername(this.state.newUsername)}&gt;Change Username&lt;/button&gt; &lt;/main&gt; )} &lt;/UserContextConsumer&gt; &lt;/div&gt; ) }}export default App 1234567891011121314151617181920212223242526//filename : userContext.jsimport React, { Component } from &quot;react&quot;const { Provider, Consumer } = React.createContext()class UserContextProvider extends Component { state = { username: &quot;Luke Skywalker&quot; } changeUsername = (username) =&gt; { this.setState({username}) } render () { const {username} = this.state return ( &lt;Provider value={{username, changeUsername : this.changeUsername}}&gt; {this.props.children} &lt;/Provider&gt; ) }}export { UserContextProvider, Consumer as UserContextConsumer } 1234567891011121314151617//filename : Header.jsimport React from &quot;react&quot;import {UserContextConsumer} from &quot;./userContext&quot;function Header(){ return ( &lt;header&gt; &lt;UserContextConsumer&gt; {({username}) =&gt; ( &lt;p&gt;Welcome, {username}!&lt;/p&gt; )} &lt;/UserContextConsumer&gt; &lt;/header&gt; ) } export default Header 特別情況小栗子 🌰 相同的 component 一個受 Provider 影響，另一個不 不在該 component 本身處理 context 可以在引入該 component 的地方做 123456789101112131415161718192021222324252627//filename : App.jsimport React from &quot;react&quot;import Header from &quot;./Header&quot;import Button from &quot;./Button&quot;import ThemeContext from &quot;./ThemeContext&quot;function App() { return ( &lt;div&gt; &lt;Header /&gt; //這個 button 引用 Provider 資料 &lt;ThemeContext.Consumer&gt; {theme =&gt;( &lt;Button theme={theme}/&gt; )} &lt;/ThemeContext.Consumer&gt; // 這個 button 不引用 &lt;Button theme=&quot;light&quot;/&gt; &lt;/div&gt; )}export default App 123456789101112131415161718192021//filename : button.jsimport React from &quot;react&quot;import PropTypes from &quot;prop-types&quot;import ThemeContext from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;button className={`${props.theme}-theme`}&gt;Switch Theme&lt;/button&gt; ) }Button.propTypes = { //用來限定傳入的 value 局限於這兩個選擇 theme: PropTypes.oneOf([&quot;light&quot;, &quot;dark&quot;])}Button.defaultProps = { theme: &quot;light&quot;}export default Button 參考資料上下文(Context)聊一聊我对 React Context 的理解以及应用","link":"/2021/04/23/0423-note-context/"},{"title":"【實作記錄】Joke Generator App | Vaniila JS","text":"Github : 點我看原始碼CodePen : 點我玩玩看 簡介這是為了練習連接 API 所設計的小遊戲，使用原生 JS 製作，界面模擬聊天機器人跟使用者互動。由於沒有設計真的的聊天機器人，所以使用了看起來笨笨的方法（延遲執行的方法）來操作。 功能 第一個聊天室可以進入 點擊 “ Tell me a Joke “ 就會出現笑話 提供簡單回復按鈕：Tell me the answer、LOL😂 暫時僅適用於Android和桌面用戶 小筆記 API : https://official-joke-api.appspot.com/jokes/programming/random 使用 async/ await 的方式 fetch API 使用 setTimeOut， 讓用戶在點擊按鈕 1 秒後才出現結果 小結簡簡單單的練習 fetch API，並沒有什麼太大的問題，反而在刻畫面上有比較大的問題，使用 Apple Device 瀏覽畫面就會直接爆掉。嗯，之後再來修好了，現在要繼續前進啦。","link":"/2021/04/02/0402-joke-generator/"},{"title":"【實作記錄】Snake Game | Vaniila JS","text":"Github : 點我看原始碼CodePen : 點我玩玩看，但這裡沒有音效，可以去上面的網址玩看看 簡介這是一款復古風的貪吃蛇遊戲。點擊開始 ᐅ ，蛇便會開始往前移動，通過鍵盤上下左右鍵操控蛇的方向。蛇往前的邏輯是碰到果實，碰到的格子會移除、蛇的最後會增加一格。果實和障礙物則隨機產生。在碰到障礙物、墻壁以及自己的身體時，遊戲便會結束，同時顯示蛇身長度以及分數。點擊 restart 可以重啟遊戲。 功能 隨機產生果實(藍色)與障礙物(block) 可通過 WASD 鍵 / ↑ ↓ ← → 鍵移動蛇 蛇的長度會隨著吃的果實而增加 吃的果實越多，移動速度就越快 碰到障礙物、墻壁、自己遊戲便會結束 提供建議遊戲規則 吃果實、碰到障礙物有音效 音效可以透過 “Volume icon” 關閉 遊戲結束後會顯示分數以及蛇的長度 小筆記增加音效的方法Audio for Web games 1234var myAudio = document.createElement(&quot;audio&quot;);myAudio.src = &quot;mysprite.mp3&quot;;myAudio.play();myAudio.pause(); 使用鍵盤操控1234567891011121314151617181920document.addEventListener(&quot;keyup&quot;, control)function control(e) { if (e.keyCode === 39 || e.keyCode === 68) { console.log(&quot;right pressed&quot;) direction = 1 } else if (e.keyCode === 38 || e.keyCode === 87) { console.log(&quot;up pressed&quot;) direction = -width } else if (e.keyCode === 37 || e.keyCode === 65) { console.log(&quot;left pressed&quot;) direction = -1 } else if (e.keyCode === 40 || e.keyCode === 83) { console.log(&quot;down pressed&quot;) direction = +width }} 小結這是為了練習 JS 邏輯而製作的一款小遊戲。之後會想要增加遊戲難度或是關卡、果實和障礙物出現的位置、蛇移動的靈活度也可以再調整。","link":"/2021/03/15/0315-snake-game/"},{"title":"【實作記錄】Pacman Game | Vanilla JS","text":"Github : 點我看原始碼CodePen : 點我玩玩看，但這裡沒有音效，可以去上面的網址玩看看 簡介這是一款使用 JavaScript 製作的小精靈遊戲。玩家將所有點點吃完便會獲勝、被精靈吃掉遊戲便結束。點點分數為 1 分、大點點 (power pallet) 為 10 分、吃掉害怕狀態的精靈增加 100 分。其中也添加了音效，默認為關閉，可點擊右上的 “volume icon” 打開。 功能 使用上下左右鍵移動 Pacman 吃了 Power Pallet 便可以吃掉顏色為橘色的精靈 每個動作都有音效，可以透過右上的 “volume icon” 關閉 吃完點點便會宣佈獲勝 被精靈吃掉，遊戲便結束 小筆記Pacman 的移動Pacman 的上下移動邏輯使用 switch 處理。判斷 pacman 在移動的時候是否碰到墻壁，若沒有碰到墻壁/沒有碰到精靈則可以往按鍵的方向行動。 判斷是否碰到墻壁：如果要往下的那個沒有 “wall” 這個 class ，表示沒有 判斷是否碰到精靈：如果要往下的那個沒有 “ghost” 這個 class ，表示沒有 keycode 移動方式 判斷方式 40 往下鍵 pacman 所在的位置 + width 判斷是否已經到最底層：如果 pacman 所在 index 加上 width 小於整個 layout 的最大 index， 表示沒有超出邊界 38 往上鍵 pacman 所在的位置 - width 判斷是否已經到最上層：如果 pacman 所在 index 減掉 width 小於整個 0， 表示沒有超出邊界 37 往左鍵 pacman 所在的位置 -1 判斷是否已經到最左邊：如果 pacman 所在 index 除 width 的餘數不等於 0， 表示沒有超出邊界 38 往由鍵 pacman 所在的位置 +1 判斷是否已經到最左邊：如果 pacman 所在 index 除 width 的餘數小於 width - 1， 表示沒有超出邊界 1234567891011switch(e.keyCode) { case 40 : console.log(&quot;pressed down&quot;) if ( pacmanCurrentIndex + width &lt; width * width &amp;&amp; !squares[pacmanCurrentIndex + width].classList.contains(&quot;wall&quot;)&amp;&amp; !squares[pacmanCurrentIndex + width].classList.contains(&quot;ghost-liar&quot;) ) pacmanCurrentIndex += width break 精靈的 class由於 4 個精靈是一組的，都有 className 、起始位置、移動速度、當下位置、是否為害怕狀態、計時器，因此使用 class 來處理。需要每一隻精靈執行共同的程式碼就使用 for Each. 12345678910111213141516171819class Ghost{ constructor(className, startIndex, speed){ this.className = className this.startIndex = startIndex this.speed = speed this.currentIndex = startIndex this.isScared = false this.timerId = NaN }}//傳入需要的參數：classname, 起始位置，速度const ghosts = [ new Ghost(&quot;blinky&quot; , 347, 250), new Ghost(&quot;pinky&quot; , 376, 400), new Ghost(&quot;inky&quot; , 352, 300), new Ghost(&quot;clyde&quot; , 379, 500),] 把精靈畫進 grid 裡123ghosts.forEach (ghost =&gt; { squares[ghost.currentIndex].classList.add(ghost.className) squares[ghost.currentIndex].classList.add(&quot;ghost&quot;) 精靈移動 使用 Math.random() 決定精靈移動的方向，因此方向是沒有邏輯的 12const directions = [-1 , +1 , -width , +width]let direction= directions[Math.floor(Math.random() * directions.length)] 沒有碰到碰到精靈或墻壁，就可以往隨機選出來的方向前進一格 1234567891011if ( !squares[ghost.currentIndex + direction].classList.contains(&quot;wall&quot;) &amp;&amp; !squares[ghost.currentIndex + direction].classList.contains(&quot;ghost&quot;) ){ squares[ghost.currentIndex].classList.remove(ghost.className) squares[ghost.currentIndex].classList.remove(&quot;ghost&quot;, &quot;scared-ghost&quot;) ghost.currentIndex += direction squares[ghost.currentIndex].classList.add(ghost.className) squares[ghost.currentIndex].classList.add(&quot;ghost&quot;)} 在吃了 power pallet 之後，精靈會轉為 scared 狀態，就可以被吃 this.isScared = true 會轉為橘色123456789if ( ghost.isScared &amp;&amp; squares[ghost.currentIndex].classList.contains(&quot;pacman&quot;)){ squares[ghost.currentIndex].classList.remove(ghost.className,&quot;scared-ghost&quot;) ghost.currentIndex = ghost.startIndex score += 100 squares[ghost.currentIndex].classList.add(ghost.className , &quot;ghost&quot;) eatGhostSound()} 遊戲結束 碰到精靈遊戲便會結束 計時器會被清除，按鍵被移除，game over 字樣出現123456789if ( !ghost.isScared &amp;&amp; squares[ghost.currentIndex].classList.contains(&quot;pacman&quot;)){ ghosts.forEach(ghost =&gt; clearInterval(ghost.timerId)) document.removeEventListener(&quot;keydown&quot;, control) gameOver.style.display = &quot;block&quot; overlay.style.display=&quot;block&quot; deathSound()} 玩家贏了 吃完所有點點就宣佈獲勝1234567891011let dot = 305function win(){ if( dot === 0){ ghosts.forEach(ghost =&gt; clearInterval(ghost.timerId)) document.removeEventListener(&quot;keydown&quot;, control) gameWin.style.display = &quot;block&quot; overlay.style.display=&quot;block&quot; winSound() }} 小結這個小遊戲中練習了 class 以及 switch. 這裡沒有處理精靈移動的邏輯，原本應該追著 / 包抄 pacman， 但因為是使用隨機方向，因此精靈們看起來很笨（扶額）。這個部分等我找到比較好的方式再來看看怎麼讓他們聰明一些。畫地圖是使用 excel 先畫一遍，再把他們轉為 index，才填上顏色。","link":"/2021/03/26/0326-pacman-game/"}],"tags":[{"name":"React","slug":"React","link":"/tags/React/"},{"name":"學習筆記","slug":"學習筆記","link":"/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"Vannila JS","slug":"Vannila-JS","link":"/tags/Vannila-JS/"}],"categories":[{"name":"React","slug":"React","link":"/categories/React/"},{"name":"Project","slug":"React/Project","link":"/categories/React/Project/"},{"name":"Project","slug":"Project","link":"/categories/Project/"}]}