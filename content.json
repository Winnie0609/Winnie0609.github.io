{"pages":[{"title":"安安，你好。","text":"翁慧倪 @huini_ong 狀態：緩慢但持續前進的烏龜 🐢 欸欸 我想成為聰明的人 📍&nbsp;&nbsp;TW. 🏠&nbsp;&nbsp;MY. 🎈&nbsp;June 9, 1998 下載履歷 前端菜雞 ( 2021 年 2 月開始自學前端開發 ) 正在尋找前端相關的工作 相信變強的最快方法是進去被電爆 我家猫会后空翻，我會寫程式。 我還會做小東西。 React | 📺 Netflix Clone React | 🎞️ Movie App React | ⌨️ Speed Test App React | 😂 Meme Generator React | ✔️ Todo App Vanilla JS | 🟡 Pacman Game Vanilla JS | 🐍 Snake Game Vanilla JS | 😜 Joke Generator Vanilla JS | 🎲 Dice Game 也會發廢文。 114 中文系畢業，喜歡寫字，沒想到後來也喜歡寫程式 摘星星的人，即使徒勞無功，亦不致於一手污泥 不笑時臉看起來很臭，但真的沒有心情不好 喜歡清心的多多綠微糖微冰加珍珠 都想做不同的事、玩不同的東西 馬來文、粵語、台語也會一些 寫程式和寫字都很浪漫 偶爾是廢文產生器 火鍋愛好者 我沒有貓 雖然我沒有貓，但還是要跟我聊天呀。 12//其實很討厭點了 email icon 就跳出寄信郵箱，所以這裡附上 emailwinnieong0609@gmail.com","link":"/about/index.html"}],"posts":[{"title":"【實作記錄】 玻璃擬態登入頁面 | Vanilla Js","text":"live DemoGithubCode Pen 簡介這是接觸網頁前端三巨頭時練習的第一個小作品。尚未學習RWD之觀念，因此畫面在手機觀看會爆掉QAQ。頁面呈現玻璃擬態(Glassmorphism)效果。 功能 CSS : 用戶輸入的部分設置了Placeholder CSS : 每一個預設可以點擊之按鈕都設置了hover效果 JS : 用戶點擊Sign in 按鈕後，先前輸入的資料會淨空 JS : 設置了用戶輸入提醒，若缺少用戶名/密碼將會跳出警告 JS : 用戶名與密碼藉有輸入將會跳出”username, Welcome!”之字樣 小筆記記錄一些CSS小筆記，作往後回顧之用。 Glassmorphism效果12345678910111213.loginSec{ padding: 42px 22px; border-radius: 10px; background-color: rgba(255, 255, 255, 0.10); border: 1px solid rgba(255, 255, 255, 0.15); backdrop-filter: blur(10px); box-shadow: 0 0.9px 8.5px -9px rgba(0, 0, 0, 0.041), 0 2.4px 23.5px -9px rgba(0, 0, 0, 0.069), 0 5.7px 56.7px -9px rgba(0, 0, 0, 0.098), 0 19px 188px -9px rgba(0, 0, 0, 0.16) ;} Hover底線效果1234567891011121314#forgetBtn::after{ content: ''; display: block; border-bottom: solid 1.3px #ffffff; height: 1.3px; transform: scaleX(0); transform-origin: 0% 100%; transition: transform .3s;}#forgetBtn:hover:after{ transform: scaleX(1); transition: transform .3s;} 背景圖縮放不影響比例1234567body{ background-image: url(&quot;https://i.postimg.cc/3rv5HhSL/login-page-background.png&quot;); background-repeat: no-repeat; background-size: cover; background-position: center center; background-attachment: fixed;} 小結這個畫面可以改進的地方有很多，但由於是第一次練習，因此沒有特別修改，想留下一些 黑歷史 記錄。這篇筆記為個人學習記錄，若有錯誤或是可以更好改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/03/0303-login/"},{"title":"【實作記錄】Snake Game | Vaniila JS","text":"Live DemoGithubCodePen 簡介這是一款復古風的貪吃蛇遊戲。點擊開始 ᐅ ，蛇便會開始往前移動，通過鍵盤上下左右鍵操控蛇的方向。蛇往前的邏輯是碰到果實，碰到的格子會移除、蛇的最後會增加一格。果實和障礙物則隨機產生。在碰到障礙物、墻壁以及自己的身體時，遊戲便會結束，同時顯示蛇身長度以及分數。點擊 restart 可以重啟遊戲。 功能 隨機產生果實(藍色)與障礙物(block) 可通過 WASD 鍵 / ↑ ↓ ← → 鍵移動蛇 蛇的長度會隨著吃的果實而增加 吃的果實越多，移動速度就越快 碰到障礙物、墻壁、自己遊戲便會結束 提供建議遊戲規則 吃果實、碰到障礙物有音效 音效可以透過 “Volume icon” 關閉 遊戲結束後會顯示分數以及蛇的長度 小筆記增加音效的方法Audio for Web games 1234var myAudio = document.createElement(&quot;audio&quot;);myAudio.src = &quot;mysprite.mp3&quot;;myAudio.play();myAudio.pause(); 使用鍵盤操控1234567891011121314151617181920document.addEventListener(&quot;keyup&quot;, control)function control(e) { if (e.keyCode === 39 || e.keyCode === 68) { console.log(&quot;right pressed&quot;) direction = 1 } else if (e.keyCode === 38 || e.keyCode === 87) { console.log(&quot;up pressed&quot;) direction = -width } else if (e.keyCode === 37 || e.keyCode === 65) { console.log(&quot;left pressed&quot;) direction = -1 } else if (e.keyCode === 40 || e.keyCode === 83) { console.log(&quot;down pressed&quot;) direction = +width }} 小結這是為了練習 JS 邏輯而製作的一款小遊戲。之後會想要增加遊戲難度或是關卡、果實和障礙物出現的位置、蛇移動的靈活度也可以再調整。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/15/0315-snake-game/"},{"title":"【實作記錄】The Dice Game | Vanilla JS","text":"live DemoGithub 簡介這是使用純 JS 寫的小小擲骰子遊戲，主要用來練習使用 JS 操控 DOM. 功能 點擊按鈕擲骰子，點數直接加到分數板，贏家為先獲得 20 分的隊伍 兩隊玩家各有兩個角色可以選擇 玩家可以輸入名字 輪到藍隊玩家時，其角色會出現藍色框框；粉隊玩家則為粉色框框 點數更換成骰子的 icon 小筆記 inner.HTML : 可以直接加入 html tag 123characterPlayer1_first.addEventListener(&quot;click&quot;, function(){ document.querySelector(&quot;.border1&quot;).innerHTML='&lt;img class=&quot;img1&quot; src=&quot;./img/robot-1.png&quot; alt=&quot;player one&quot;&gt;'}) 圖片重疊 : 使用 position:absolute 進行定位 小結這不是一個複雜的遊戲，基本擲骰子積計分的功能蠻快就做出來了。反而花最多時間的地方在玩家回合的粉色和藍色框框，原本框框設置成照片的 border, 但在換角色時候，框框就無法顯示。最後才想到把框框獨立出來就好了(༎ຶ⌑༎ຶ) 其他部分則沒有遇到太大的問題。之後有機會要再改良的話，應該會從兩隊勝率不均這個部分下手。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/12/0312-dice-game/"},{"title":"【實作記錄】Pacman Game | Vanilla JS","text":"Live DemoGithubCodePen 簡介這是一款使用 JavaScript 製作的小精靈遊戲。玩家將所有點點吃完便會獲勝、被精靈吃掉遊戲便結束。點點分數為 1 分、大點點 (power pallet) 為 10 分、吃掉害怕狀態的精靈增加 100 分。其中也添加了音效，默認為關閉，可點擊右上的 “volume icon” 打開。 功能 使用上下左右鍵移動 Pacman 吃了 Power Pallet 便可以吃掉顏色為橘色的精靈 每個動作都有音效，可以透過右上的 “volume icon” 關閉 吃完點點便會宣佈獲勝 被精靈吃掉，遊戲便結束 小筆記Pacman 的移動Pacman 的上下移動邏輯使用 switch 處理。判斷 pacman 在移動的時候是否碰到墻壁，若沒有碰到墻壁/沒有碰到精靈則可以往按鍵的方向行動。 判斷是否碰到墻壁：如果要往下的那個沒有 “wall” 這個 class ，表示沒有 判斷是否碰到精靈：如果要往下的那個沒有 “ghost” 這個 class ，表示沒有 keycode 移動方式 判斷方式 40 往下鍵 pacman 所在的位置 + width 判斷是否已經到最底層：如果 pacman 所在 index 加上 width 小於整個 layout 的最大 index， 表示沒有超出邊界 38 往上鍵 pacman 所在的位置 - width 判斷是否已經到最上層：如果 pacman 所在 index 減掉 width 小於整個 0， 表示沒有超出邊界 37 往左鍵 pacman 所在的位置 -1 判斷是否已經到最左邊：如果 pacman 所在 index 除 width 的餘數不等於 0， 表示沒有超出邊界 38 往由鍵 pacman 所在的位置 +1 判斷是否已經到最左邊：如果 pacman 所在 index 除 width 的餘數小於 width - 1， 表示沒有超出邊界 1234567891011switch(e.keyCode) { case 40 : console.log(&quot;pressed down&quot;) if ( pacmanCurrentIndex + width &lt; width * width &amp;&amp; !squares[pacmanCurrentIndex + width].classList.contains(&quot;wall&quot;)&amp;&amp; !squares[pacmanCurrentIndex + width].classList.contains(&quot;ghost-liar&quot;) ) pacmanCurrentIndex += width break 精靈的 class由於 4 個精靈是一組的，都有 className 、起始位置、移動速度、當下位置、是否為害怕狀態、計時器，因此使用 class 來處理。需要每一隻精靈執行共同的程式碼就使用 for Each. 12345678910111213141516171819class Ghost{ constructor(className, startIndex, speed){ this.className = className this.startIndex = startIndex this.speed = speed this.currentIndex = startIndex this.isScared = false this.timerId = NaN }}//傳入需要的參數：classname, 起始位置，速度const ghosts = [ new Ghost(&quot;blinky&quot; , 347, 250), new Ghost(&quot;pinky&quot; , 376, 400), new Ghost(&quot;inky&quot; , 352, 300), new Ghost(&quot;clyde&quot; , 379, 500),] 把精靈畫進 grid 裡123ghosts.forEach (ghost =&gt; { squares[ghost.currentIndex].classList.add(ghost.className) squares[ghost.currentIndex].classList.add(&quot;ghost&quot;) 精靈移動 使用 Math.random() 決定精靈移動的方向，因此方向是沒有邏輯的 12const directions = [-1 , +1 , -width , +width]let direction= directions[Math.floor(Math.random() * directions.length)] 沒有碰到碰到精靈或墻壁，就可以往隨機選出來的方向前進一格 1234567891011if ( !squares[ghost.currentIndex + direction].classList.contains(&quot;wall&quot;) &amp;&amp; !squares[ghost.currentIndex + direction].classList.contains(&quot;ghost&quot;) ){ squares[ghost.currentIndex].classList.remove(ghost.className) squares[ghost.currentIndex].classList.remove(&quot;ghost&quot;, &quot;scared-ghost&quot;) ghost.currentIndex += direction squares[ghost.currentIndex].classList.add(ghost.className) squares[ghost.currentIndex].classList.add(&quot;ghost&quot;)} 在吃了 power pallet 之後，精靈會轉為 scared 狀態，就可以被吃 this.isScared = true 會轉為橘色123456789if ( ghost.isScared &amp;&amp; squares[ghost.currentIndex].classList.contains(&quot;pacman&quot;)){ squares[ghost.currentIndex].classList.remove(ghost.className,&quot;scared-ghost&quot;) ghost.currentIndex = ghost.startIndex score += 100 squares[ghost.currentIndex].classList.add(ghost.className , &quot;ghost&quot;) eatGhostSound()} 遊戲結束 碰到精靈遊戲便會結束 計時器會被清除，按鍵被移除，game over 字樣出現123456789if ( !ghost.isScared &amp;&amp; squares[ghost.currentIndex].classList.contains(&quot;pacman&quot;)){ ghosts.forEach(ghost =&gt; clearInterval(ghost.timerId)) document.removeEventListener(&quot;keydown&quot;, control) gameOver.style.display = &quot;block&quot; overlay.style.display=&quot;block&quot; deathSound()} 玩家贏了 吃完所有點點就宣佈獲勝1234567891011let dot = 305function win(){ if( dot === 0){ ghosts.forEach(ghost =&gt; clearInterval(ghost.timerId)) document.removeEventListener(&quot;keydown&quot;, control) gameWin.style.display = &quot;block&quot; overlay.style.display=&quot;block&quot; winSound() }} 小結這個小遊戲中練習了 class 以及 switch. 這裡沒有處理精靈移動的邏輯，原本應該追著 / 包抄 pacman， 但因為是使用隨機方向，因此精靈們看起來很笨（扶額）。這個部分等我找到比較好的方式再來看看怎麼讓他們聰明一些。畫地圖是使用 excel 先畫一遍，再把他們轉為 index，才填上顏色。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/03/26/0326-pacman-game/"},{"title":"【實作記錄】Joke Generator App | Vaniila JS","text":"Live DemoGithubCodePen 簡介這是為了練習連接 API 所設計的小遊戲，使用原生 JS 製作，界面模擬聊天機器人跟使用者互動。由於沒有設計真的的聊天機器人，所以使用了看起來笨笨的方法（延遲執行的方法）來操作。 功能 第一個聊天室可以進入 點擊 “ Tell me a Joke “ 就會出現笑話 提供簡單回復按鈕：Tell me the answer、LOL😂 暫時僅適用於Android和桌面用戶 小筆記 API : https://official-joke-api.appspot.com/jokes/programming/random 使用 async/ await 的方式 fetch API 使用 setTimeOut， 讓用戶在點擊按鈕 1 秒後才出現結果 小結簡簡單單的練習 fetch API，並沒有什麼太大的問題，反而在刻畫面上有比較大的問題，使用 Apple Device 瀏覽畫面就會直接爆掉。嗯，之後再來修好了，現在要繼續前進啦。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬","link":"/2021/04/02/0402-joke-generator/"},{"title":"【學習筆記】 表單 | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 Controlled ComponentReact 創建表單的方式有兩種：Controlled Component 以及 Uncontrolled Component。前者的表單的資料是被 React component 所處理；後者表單的資料則由 DOM 本身處理。多數情況下建議使用 controlled component. Text在 React 中，可變的 state 通常是被維持在 component 中的 state property，並只能以 setState() 來更新。State 在用戶每次輸入的時候都會更新，如果將用戶輸入的資訊都印出來，字會隨著用戶輸入的一個一個字出現（結尾有示範影片）。 建立react component 在render()中設定需要的input 在this.state中初始化firstName/lastName的值 12345678class APP extends Component{ constructor(){ super() this.state = { firstName : &quot;&quot;, lastName : &quot;&quot; } } 設定 onChange 的function(handleChange)為了抓取用戶說輸入的資訊再更新 State，因此要在 input 中加入onChange，將其指向更新 function (這裡指向 handleChange function)。每次用戶輸入時，state 都會更新。與此同時綁定 function 以及 state. 在 handleChange function 中為 fisrtName / lastName 重新賦值。 1this.handleChange = this.handleChange.bind(this) 為了避免重新賦值時有錯誤，因此要為 input 個別設定 name（在input 中加入name）。在 handleChange function 中就可以直接指向 input 的 name. 無論是哪一種 input 都應該使用這樣的方式去更新資料。 123456handleChange(event){ this.setState({ //不直接寫firstName : event.target.value [event.target.name] : event.target.value }) } 為input添加value attribute讓 this.state 的 value 等於用戶輸入的樣子。 完整程式碼： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, { Component } from &quot;react&quot;class APP extends Component{ constructor(){ super() this.state = { //初始化 firstName : &quot;&quot;, lastName : &quot;&quot; } this.handleChange = this.handleChange.bind(this) //綁定 } //可以簡化成這樣 handleChange(event){ const {name, value} = event.target this.setState({ [name] : value } ) } render(){ return( &lt;form&gt; &lt;label&gt;First Name &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;firstName&quot; value={this.state.firstName} onChange={this.handleChange} /&gt; &lt;br/&gt; &lt;label&gt;Last Name &lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;lastName&quot; value={this.state.lastName} onChange={this.handleChange} /&gt; &lt;p&gt;{this.state.firstName}{this.state.lastName}&lt;/p&gt; //印出來 &lt;/form&gt; ) }}export default APP TextArea跟原 HTML 的寫法有些不同，在 HTML 中，一個 textarea 的 element 是經由它的 children 來定義它的文字。React 中的則是使用 value attribute。 1&lt;textarea value={&quot;Some default value&quot;}/&gt; Checkboxcheckbox 中的 checked attribute 是 boolean，可在 this.state 中設定它的值。checkbox 可以讓用戶勾選/不勾選，因此需要設定 onChange 讓 checked 變成可改變的。 12345&lt;input type=&quot;checkbox&quot; checked={boolean} onChange={function}/&gt; Radioradio 跟 checkbox 的寫法很類似。同一組的 radio button 要設置相同的名字，這樣才會被認為是一組，才能從中擇一。 12345678910111213141516171819&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; checked={this.state.gender === &quot;male&quot;} onChange={} /&gt; Male&lt;/label&gt;&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; checked={this.state.gender === &quot;female&quot;} onChange={} /&gt; Female&lt;/label&gt; Selectselect 的下拉式選單中，預設被選定的值與 HTML 中寫的不同，React使用 value 這個 attribute 來選定預設的值，範例中預設被選定的是 ‘blue’ 。 123456789101112&lt;label&gt;Favorite Color: &lt;/label&gt; &lt;select value={&quot;blue&quot;} //預設值 onChange={this.handleChange} name=&quot;favColor&quot; &gt; &lt;option value=&quot;blue&quot;&gt;Blue&lt;/option&gt; &lt;option value=&quot;green&quot;&gt;Green&lt;/option&gt; &lt;option value=&quot;red&quot;&gt;Red&lt;/option&gt; &lt;option value=&quot;orange&quot;&gt;Orange&lt;/option&gt; &lt;option value=&quot;yellow&quot;&gt;Yellow&lt;/option&gt; &lt;/select&gt; 範例Travel form 實作一個簡單的 Travel form，使用了&lt; text &gt; &lt; textarea &gt; &lt; checkbox &gt; &lt; radio &gt; 以及 &lt; select &gt;。 表單內容包括： First Name/ Last Name : text Age : number Gender : radio Destination : select Dietary restrictions: checkbox 解法 首先建立 react component 以及需要的 input。 創建操縱每個 input 改變的function + binding 為了讓 input 的值得以改變 12345function handleChange(event){ this.state({ xxx })} First Name/ Last Name/ Age : text 為了收到用戶的輸入以及及時改變 state，input 內需要onchange 以及 value 兩個attribute ( 其他 type 亦然 ) onchange: 當用戶輸入時，就會立刻執行指向的 function，立即更新 state value : 會指向 function 更新完後的 value 123456handleChange(event){ const {name, value} = event.target this.setState({ [name] : value //event.target.name選中的是input裡的'name' }) } 1234567&lt;input type=&quot;text&quot; name=&quot;firstName&quot; placeholder=&quot;First Name&quot; value={this.state.firstName} onChange={this.handleChange}/&gt; Gender : radio input 內加上 onchange（ 指向 handleChange function ） &amp; value 跟 checkbox 的原理相似，擇一的功能需要依賴 check 12345678&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; //當state是female時，就可以選到 checked={this.state.gender === &quot;female&quot;} onChange={this.handleChange}/&gt;Female Destination : select input 內加上 onchange（ 指向 handleChange function ） &amp; value 選項默認會是第一個，但這個選項不會被取得，需要切換到第二個選項再切回來才會被選中 1234567891011&lt;select value={this.state.destination} name=&quot;destination&quot; onChange={this.handleChange} &gt; &lt;option value=&quot;&quot;&gt;---Please choose a planet---&lt;/option&gt; &lt;option value=&quot;🪐Tatooine&quot;&gt;🪐Tatooine&lt;/option&gt; &lt;option value=&quot;🌖Alderaan&quot;&gt;🌖Alderaan&lt;/option&gt; &lt;option value=&quot;☀️Hoth&quot;&gt;☀️Hoth&lt;/option&gt; &lt;option value=&quot;⭐Bespin&quot;&gt;⭐Bespin&lt;/option&gt;&lt;/select&gt; Dietary restrictions: checkbox 設定每一個初始值為 false 使用checked來改變 function funtion 調整 這幾種 input 會分成兩種狀況：適用於 checkbox 的以及 checkbox 以外的。因為只分為兩種狀況，因此可以使用 if type 等於 checkbox 就執行冒號前的，不等於 checkbox 則執行冒號後的 結果顯示Yes / No 1234567//先設定每一個選項的 booleanthis.state = { isFish: false, isBread : false, isMilk : false,} 12345678//input的checked&lt;input type=&quot;checkbox&quot; name=&quot;isFish&quot; checked={this.state.isFish} onChange={this.handleChange} /&gt;Colo Claw Fish 12345678910111213//function調整handleChange(event){ const {name, value, type, checked} = event.target type === &quot;checkbox&quot; ? this.setState({ [name] : checked //checkbox的情況 }) : this.setState({ //其他的的情況 [name] : value, }) } 12//結果顯示&lt;p&gt;Colo Claw Fish : {this.state.isFish ? &quot;Yes&quot;:&quot;No&quot;}&lt;/p&gt; 小結直接刻表單程式碼會落落長的，所以可以分好 Component 讓程式碼比較好維護. 另外也有 Formik 這個工具，主打無痛創造 React 表單，但這個還沒仔細研究過。（坑待補） 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :) 參考資料 React Forms Presentational and Container Components","link":"/2021/04/09/0409-form-note/"},{"title":"【學習筆記】 useEffect | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 useEffect 小栗子 可運作 side effect （可以影響其他 component 且在 render 期間無法完成的），如 fetch 資料、訂閱、或手動改變 DOM。 useEffect 包含了 componentDidMount ，componentDidUpdate ，以及 componentWillUnmount 的功能 每一次render都會執行useEffect，因此要設定在某個條件下才會觸發這個 function 計數器例子 12345678910111213141516171819202122import React, { useState, useEffect } from 'react'; //引入useEffectfunction Example() { const [count, setCount] = useState(0); // 與 componentDidMount 和 componentDidUpdate 類似： useEffect(() =&gt; { // 使用瀏覽器 API 更新文件標題 document.title = `You clicked ${count} times`; }); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; );}export default Example 計數器+random color例子 123456789101112131415161718192021222324252627282930import React, {useState, useEffect} from &quot;react&quot;import randomcolor from &quot;randomcolor&quot; //這引入了別的libraryfunction App() { const [count, setCount] = useState(0) const [color, setColor] = useState(&quot;&quot;) function increment() { setCount(prevCount =&gt; prevCount + 1) } function decrement() { setCount(prevCount =&gt; prevCount - 1) } useEffect(() =&gt; { setColor(randomcolor()) }, [count]) //執行條件設為當count改變時 return ( &lt;div&gt; &lt;h1 style={{color: color}}&gt;{count}&lt;/h1&gt; &lt;button onClick={increment}&gt;Increment&lt;/button&gt; &lt;button onClick={decrement}&gt;Decrement&lt;/button&gt; &lt;/div&gt; )}export default App 注意 因為每一次render，都會重新呼叫useEffect這個function，所以要設定條件。12345//這樣寫會導致這個function一直被呼叫useEffect(() =&gt; { setColor(randomcolor())}) ==BUG== ==預設情況== 清除 effect 這裡指的 effect 就是我們傳進 useEffect 的 fucntion 每個 effect 都可以回傳一個會在它之後執行清除的 function 一個在執行之後需要清除的 function，可以在新增 function 後回傳一個需要清除的 function 其他不需要清除的就不需要回傳 12345678910useEffect(() =&gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); return () =&gt; { ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); }; }); 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :)","link":"/2021/04/10/0411-note-useeffect/"},{"title":"【學習筆記】 useState | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 Function Component function component 長這樣 12345678910//function componentimport React from &quot;react&quot;function App() { return ( &lt;div&gt; &lt;h1&gt;Is state important to know? Yes&lt;/h1&gt; &lt;/div&gt; )} 123456789101112131415//例子import React, {useState} from &quot;react&quot; //引入useStatefunction App() { //這裡的state不一定要是object const [answer] = useState(&quot;Yes&quot;) const [fruit, setFruit] = useState('banana'); const [todos, setTodos] = useState([{ text: 'Learn Hooks' }])//這裡可以宣告多個變數 return ( &lt;div&gt; &lt;h1&gt;Is state important to know? {answer}&lt;/h1&gt; &lt;/div&gt; )} 宣告一個 state 變數 1const [目前 state 數值, function] = useState(initial value) useState 回傳一組數值：目前 state 數值和一個可以讓你更新 state 的 function 與 class component 不同，state 不一定要是object 與 class component this.state({name: value, name: value}) 相似，它可以宣告多個變數 計數器例子 12345import React, { useState } from 'react';function Example() { // 宣告一個新的 state 變數，稱為「count」 const [count, setCount] = useState(0);//不一定要是object useState 宣告了一個變數，這個變數會被保存起來 傳入 useState 的是這個變數的起始值，這個起始值可以不需要是 object，這裡因為計數器需要所以傳入 num 起始值只在第一次 render 的時候會使用到 讀取 State 與 class component 讀取 state 的方式不同 &lt;p&gt; {this.state.count} &lt;/p&gt; ，function component 可以直接讀取變數{count} 1&lt;h1&gt; {count} &lt;/h1&gt; 更新 state 可以直接用 setCount 和 count 直接更新123&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me &lt;/button&gt; 總結 第 1 行 : 引入 useState 第 5 行 : 在 App component 裡，呼叫 useState Hook 宣告了一個新的 state 變數，成為 count ( 作計數用 )。將起始值設為 0 並傳入 useState 當作唯一參數。第二個回傳的值是個可以更新 count 的 function，命名為 setCount。 第 18 , 19 行：當使用者點擊，就呼叫 increment/ decrement function , setcount 更新 count 的值。 12345678910111213141516171819202122import React, {useState} from &quot;react&quot;function App() { // 宣告一個新的 state 變數，稱為 count const [count, setCount] = useState(0) function increment() { setCount(prevCount =&gt; prevCount + 1) } function decrement() { setCount(prevCount =&gt; prevCount - 1) } return ( &lt;div&gt; &lt;h1&gt; {count} &lt;/h1&gt; &lt;button onClick = {increment} &gt;Increment&lt;/button&gt; &lt;button onClick = {decrement} &gt;Decrement&lt;/button&gt; &lt;/div&gt; )} 綜合例子123456789101112131415161718192021222324252627282930313233343536373839404142import React, {useState} from &quot;react&quot;function App() { const [inputData, setInputData] = useState({firstName: &quot;&quot;, lastName: &quot;&quot;}) const [contactsData, setContactsData] = useState([]) function handleChange(event) { const {name, value} = event.target setInputData(prevInputData =&gt; ({...prevInputData, [name]: value})) } function handleSubmit(event) { event.preventDefault() setContactsData(prevContacts =&gt; [...prevContacts, inputData]) } const contacts = contactsData.map(contact =&gt; &lt;h2 key={contact.firstName + contact.lastName}&gt;{contact.firstName} {contact.lastName}&lt;/h2&gt;) return ( &lt;&gt; &lt;form onSubmit={handleSubmit}&gt; &lt;input placeholder=&quot;First Name&quot; name=&quot;firstName&quot; value={inputData.firstName} onChange={handleChange} /&gt; &lt;input placeholder=&quot;Last Name&quot; name=&quot;lastName&quot; value={inputData.lastName} onChange={handleChange} /&gt; &lt;br /&gt; &lt;button&gt;Add contact&lt;/button&gt; &lt;/form&gt; {contacts} &lt;/&gt; )}export default App 這是自己的學習筆記，文字並沒有特別修飾，以自己看得懂為主。如果有觀念/其他錯誤的地方，再麻煩大大指點 :) 參考資料 使用 State Hook 【React.js入門 - 20】 useEffect - 在function component用生命週期","link":"/2021/04/10/0410-note-usestate/"},{"title":"【實作記錄】Todo List | React","text":"Live DemoGithub 簡介這是一個有基本功能的 todo list 練習，為了練習語法以及邏輯，所以參考了教學影片，文末附上教學影片之連結。這裡練習了各個 Component 之間的傳遞、React Hook 也認識了之前沒有用過的幾個 CSS 小方法。下面詳細記錄了自己的學習步驟。 功能 增加 task 刪除 task 完成的 task : 打√, 劃掉的線 可以 filter 完成/未完成/所有的 task 前置作業簡單劃分需要的功能以及元件。除了 index.js 外，主要的操作都在 App.js.其餘的 Component 集中放到 components 的 file 中。 index.js App.js Form.js TodoList.js Todo.js 步驟基本設置整個Todo list 是由兩個部分組成的：form 以及 list。 form : 設置讓用戶輸入的 form , 包含輸入的框框 (input) &amp; 添加按鈕 (button) &amp; filter (select) 。Filter 裡有三個 option : All/ completed / uncompleted。 list : 用戶在增加 task 之後，該 task 會出現在 list 裡。只要設置一個 unorder list，增加的部分之後會處理。 index.js1234567891011import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';ReactDOM.render( &lt;div className=&quot;container&quot;&gt; &lt;App /&gt; &lt;/div&gt;, document.getElementById('root')); Form.js123456789101112131415161718192021222324252627import React from &quot;react&quot;import '../index.css'; //引入外部cssconst Form = () =&gt; { return( &lt;form&gt; &lt;div className=&quot;input-option&quot;&gt; &lt;select dir=&quot;rtl&quot;&gt; &lt;option class=&quot;options&quot; value=&quot;all&quot;&gt;All&lt;/option&gt; &lt;option class=&quot;options&quot; value=&quot;completed&quot;&gt;Completed&lt;/option&gt; &lt;option class=&quot;options&quot; value=&quot;uncompleted&quot;&gt;Uncompleted &lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div className=&quot;input-text&quot;&gt; &lt;input className=&quot;text&quot; type=&quot;text&quot; placeholder=&quot;Add a task...&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;&lt;i class=&quot;fas fa-times add&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; )}export default Form Form.js123456789101112import React from &quot;react&quot;import '../index.css';const TodoList = () =&gt; { return( &lt;div className=&quot;todo-container&quot;&gt; &lt;ul className=&quot;todo-list&quot;&gt;&lt;/ul&gt; &lt;/div&gt; )}export default TodoList 處理用戶輸入的input在 App.js 使用 useState 設定 value 的初始值。因為需要處理的 input在 Form.js 中，因此要把這兩個參數往下傳，之後才能在 Form.js 中引入。 App.js123const [inputText, setInputText] = useState(&quot;&quot;)//初始值為空字串&lt;Form inputText={inputText} setInputText={setInputText}/&gt; 接著處理用戶輸入的資訊。在 input 中設定 onchange 以及 value. input 改變時，onChange 會被觸發，因而執行設定好的 function. 創造一個處理更新的 function : handlechange.使用 setTnputText 更新input 的 value.用戶每輸入一個字，就會觸發 onchange, 所以會出現下面的結果。 const Form = ({ setInputText }) 相等於 const Form = ({props}) 的寫法，前者是直接把 setInput 這個參數傳進來，所以在使用 setInputText 的時候不用加上 props. 後者在使用時要寫 props.setInputText ，直接把參數傳進來的寫法會比較簡潔。 Form.js123456789101112const Form = ({ inputText ,setInputText }) =&gt; { //這是App.js中傳進來的參數 function handlechange(event){ setInputText(event.target.value) //更新inputText的值 console.log(event.target.value) //下面有log出來的效果 }&lt;input className=&quot;text&quot; type=&quot;text&quot; placeholder=&quot;Add a task...&quot; value={inputText} onChange={handlechange}/&gt; 結果會是這個樣子： 把用戶輸入的東西存進 todo list 裡運作邏輯：用戶輸入 task &gt; 按 summit button &gt; task 被加到 list 裡 增加 button onclick function. 在按下 button 之後，用戶輸入的值加到 todo list 裡，可以創造一個新的 hook 將 todo list 存進 array 裡。因此創造了const [todos, setTodos] = useState([])，初始值為空 array.與input一樣，這個功能會在 Form.js 裡完成，因此也要將參數往下傳。 App.js12345678const [todos, setTodos] = useState([])&lt;Form inputText={inputText} setInputText={setInputText} todos={todos} setTodos={setTodos} /&gt; 接著處理用戶輸入的資料。在把 todos, setTodos 傳進 Form.js 後，增加button 的 onclick，觸發 function 設為 submitHandleChange function. 這個 function 會更新 todos 這個 state，首先將原本就存在在 task 存進來，再增加用戶新輸入的 task. 用戶輸入的 task 會以 object 的形式傳進去，包括了 tasks 的名字 (text) 、是否完成 (completed:boolean)、id (使用亂數產生)。 Form.js1234567function submitHandleChange(e) { e.preventDefault() //移除默認 refresh 頁面 setTodos([ ...todos, {text: inputText, completed: false, id: Math.floor(Math.random()*100)} ]) setInputText(&quot;&quot;) //輸入完成後，框框上的字拿掉 } 可以使用 react debugger 來看 todos 這個 state 的變化。在輸入 task 後按下 submit button, state 就會立刻更新。 把輸入的 tasks ( 更新後的 state ) 渲染到瀏覽器上用戶輸入的 tasks 要加到 todo list 裡，這個部分要在 TodoList.js 進行。在 App.js 中把 todos 這個參數往下傳。 App.js1&lt; TodoList todos={todos}/&gt; 在 TodoList.js 裡，todos state 每一次更新，都要把資料往下傳到 todo.js 裡渲染。因此這裡使用 map() 遍歷 todos 裡的每一個 element ，除了輸入的 task 外，也要加上 key ，才不會報錯。 TodoList.js123456789101112const TodoList = ({todos}) =&gt; { console.log(todos) return( &lt;div className=&quot;todo-container&quot;&gt; &lt;ul className=&quot;todo-list&quot;&gt; {todos.map((todo) =&gt; ( &lt;Todo key={todo.id} text={todo.text}/&gt; ))} &lt;/ul&gt; &lt;/div&gt; )} 資料往下傳到 Todo.js 後，就會按照設定好的樣式傳染到瀏覽器上。 Todo.js123456789function Todo({text}) { return( &lt;div className=&quot;todo&quot;&gt; &lt;button className=&quot;check-btn&quot;&gt;&lt;i className=&quot;fas fa-check fa-xs&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;li className=&quot;todo-item&quot;&gt;{text}&lt;/li&gt; &lt;button className=&quot;trash-btn fa-xs&quot;&gt;&lt;i className=&quot;fas fa-times &quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; )} 增加刪除功能有關 task 本 task 的處理，都在 Todo.js裡處理。刪除功能是直接操作 todos state, 因此會調用到 todos 以及 setTodos. 這兩個參數要從要從最頂層的 App.js 往下傳到 TodoList.js ，然後再往下傳到 Todo.js 中. 創造新的 function , 使用filter()來過濾掉不符合條件的 element. 這裡的條件設定為：todos state 中的 element 與 被點擊的 element 之 id 如果不相同就會被留下，相同就表示那是是用戶要刪掉的 element，因為不符合條件所以就被過濾掉了。 Todo.js123function deleteHandleChange(){ setTodos(todos.filter((el) =&gt; el.id !== todo.id)) } 增加 task completed 功能創造新的 function , 使用 map() 遍歷 todos state, 如果 element id 等於被點擊的 item 的 id，就將該 element 的 completed 的 boolean 改成相反的。最後再返回該item. Todo.js1234567891011function CompleteHandleChange(){ setTodos(todos.map((item =&gt;{ if(item.id === todo.id){ return{ ...item, completed: !item.completed } } return item } ))) } 接著處理 UI 的部分，完成後會顯示打打勾、一槓、灰色字。可以用 todo.complete 來判斷是否要加入某個className. Todo.js1234567891011121314151617181920212223//打勾勾//todo.complete 為false時，打勾設定與背景同顏色//todo.complete 為true時，加入&quot;completed-checkbox&quot;，打勾更改為黑色&lt; i className={`fas fa-check fa-xs ${todo.completed? &quot;completed-checkbox&quot; : &quot;&quot;}`}&gt;&lt;/i&gt;//CSS//背景為灰色，打勾也是灰色.check-btn{ display: block; font-weight: 100; padding: .1em .25em; margin-left: 1em; border: none; border-radius: 7px; background-color: #DFDFDF; color: #DFDFDF;}//完成後，打勾顏色更改為黑色.completed-checkbox{ color:black} Todo.js12345678//一槓、灰色字&lt;li className={`todo-item ${todo.completed? &quot;completed &quot; : &quot;&quot;}`}&gt;{text}&lt;/li&gt;//CSS.completed { text-decoration: line-through; opacity: 0.5;} 製作 filter 功能 (All / Complete / Uncomplete)先創造一個 status state 來儲存點擊 option 後的結果。這個 state 會在 Form 中處理，因此要把參數往下傳。 App.js12345678910//把setStatus往下傳，會在 form.js 處理const [status, setStatus] = useState(&quot;all&quot;)//默認為all&lt;Form todos={todos} setTodos={setTodos} inputText={inputText} setInputText={setInputText} setStatus={setStatus} /&gt; 因為選單在 Form.js 裡，因此在 Form.js 處理。設定選單改變時要執行的 function : 更新 setStatus 成點選的選項。選擇 complete的話，這裡 setStatus 就會更新為 completed. Form.js123function statusHandleChange(event){ setStatus(event.target.value)} 再創造一個 filtered state 來儲存被加進來的 task。創造一個新的 state 是為了不要影響到原本用來儲存 tasks 的 todos state. 過濾後的tasks 會被儲存在這個 state. App.js12345678//會在 Todolish.js 中處理const [filteredTodo, setFilteredTodo] = useState([])&lt;TodoList setTodos={setTodos} todos={todos} setFilteredTodo={setFilteredTodo}/&gt; 接著設定 filter 的條件，這裡使用 switch() 來處理 All/completed/uncompleted 的情況。 App.js1234567891011121314151617function filterHandlerChange(){ switch(status){ //這個status的值是 : 點擊 option 後更新的值 //在 &lt;option value=&quot;completed&quot; 的狀況下&gt; case &quot;completed&quot; : //如果是 complete 就過濾出 completed 為 true 的 tasks setFilteredTodos(todos.filter((todo) =&gt; todo.completed === true)) break case &quot;uncompleted&quot; : setFilteredTodos(todos.filter((todo) =&gt; todo.completed === false)) break default: setFilteredTodos(todos) break } } FilteredTodos 會在 tasks 存進 todos state 以及 option 被選擇的時候更新。使用 useEffect 來設定當上述兩種情況發生時，FilteredTodos 執行 function filterHandlerChange。 App.js123useEffect(() =&gt; { filterHandlerChange() }, [todos,status]) 小結到這裡，基本的增、刪、過濾功能就已經完成了。當中遇到無法成功渲染的多數原因為，沒有將參數往下傳到各個 Component 中，在這次的練習中深刻體現要了解自己寫的每一行程式碼的意思，出錯了才有辦法找到 bug 在哪裡。經過這次練習，對拆分的 component 間要如何傳遞以及 React 的寫法都比較熟悉了一些。希望下一個練習可以挑戰更複雜的（堅定臉。 由於主要目的是熟悉 React 的寫法，界面就沒有弄得很 fancy ，就讓他陽春陽春的XD如果有任何不對的地方/有更好的寫法，再麻煩各位大大指教！ :) 參考資料Build A Todo App With REACT | React Project For Beginners (FULL).","link":"/2021/04/13/0413-todo/"},{"title":"【實作記錄】 Movie App | React","text":"GithubLive Demo 簡介這個為了練習使用 React 的邏輯以及編寫方式所刻的頁面。這裡練習了如何使用 TMDB 提供的 API 來獲取需要的資料、使用 useState 以及 useEffect來更新資料、拆分 component、使用 styled component 的方法。下面記錄了搜尋頁面 fetch API 的詳細步驟，其他頁面則只是記錄重點功能。參考資料附在文末。 另外，因為專案一直在添加新的功能，因此檔案名字以及 Code 都會有調整，並不完全跟筆記的一樣。 功能 首頁有即將上映之電影 &amp; 熱門電影/電視劇 (可通過點擊按鈕切換) 電影的呈現方式使用橫軸的滾動條 電影頁則是以卡片的形式呈現，點擊卡片會出現電影資訊 彈出的 Modal 內含有電影預告的網址，導致外部鏈接 搜尋到的電影可以加入 favourite list 裡，同時也會加到 local storage 裡 已經儲存的電影可點擊菜單列的愛心查看 無法顯示的照片使用默認照片顯示 前置作業 需要使用的 API : The Movie Database API 先到 TMDB 網站申請賬號，再根據 官方文件 申請網站的 API key .文件上都有清楚的申請步驟，申請成功後，把 key 以及 Access Token 保存下來。 Modal 以及 Pagination 使用 meterial ui1$ npm install @material-ui/lab 步驟搜尋頁面設置基本結構以及樣式簡單設置需要使用到的 class component ，在內添加 JRX 以及引入外部 CSS file 用以測試文件是否能夠渲染到瀏覽器上。 1234567891011121314151617mport React from 'react';import ReactDOM from 'react-dom';import './index.css';class Main extends React.Component{ render() { return ( &lt;div className=&quot;container&quot;&gt; &lt;header&gt; &lt;h1 className=&quot;title&quot;&gt; Search a movie.&lt;/h1&gt; &lt;/header&gt; &lt;/div&gt; ) }}ReactDOM.render(&lt;Main /&gt;,document.getElementById('root')); 創造一個 component使用 form 創造一個 searchMovie component ，裡面需要有 input, label 以及 submit button. 在文件的結尾 export 後，再於 index.js file 中引入 App.js. 12345678910111213function Search(){ return ( &lt;form className=&quot;form&quot;&gt; &lt;label htmlFor=&quot;query&quot;&gt;Movie name&lt;/label&gt; &lt;input type = &quot;text&quot; name = &quot;query&quot; placeholder = &quot;Goziila vs Kong...&quot; /&gt; &lt;button className=&quot;submitBtn&quot; type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; ) } 透過 API 抓取需要的資料首先創造 searchMovies function，在 button 添加 onSubmit attribute 指向剛才創造的function. 這個 function 要先將原本 onSubmit 預設的動作清除 (preventDefault) 加上我們想要的操作。在加上需要執行的代碼前，可以先簡單測試是否成功將預設的動作清除。 1234567//簡單測試const searchMovies = (e) =&gt;{ e.preventDefault() console.log(&quot;submitting&quot;) }&gt;&gt; submitting //如果成功清除會log出設定的字樣 API的組成如下，當中的搜索方式，TMDB 提供了了三種：search / discover /find，各有不同的功能，詳細的可以查看官方文件。 除了成功取得資料外，亦要考慮無法獲得資料的情況。因此可以使用 try catch 來做 error handling.在還沒獲取用戶輸入的資料前，可以先設置query來測試 API 是否運作順利。 123456789101112131415161718const API_KEY = process.env.REACT_APP_API_KEYconst searchMovies = async (e) =&gt;{ e.preventDefault() console.log(&quot;submitting&quot;) const query = &quot;Jurassic Park&quot; //測試用，query應是用戶輸入的資料 const url = `https://api.themoviedb.org/3/search/movie/?api_key=${API_KEY}&amp;language=en-US&amp;query=${query}` try{ //成功的情況 const res = await fetch(url) const data = await res.json() console.log(data) }catch(err){ //失敗的情況 console.error(err) } } 成功獲得資料的結果如下，搜尋 “Jurassic Park” 會出現15筆資料。我們需要的資料存在 results 裡。 使用 useState 更新 query在 input 內添加 value , value 為 {query}，即是用戶輸入的資訊。使用 useState 和useEffect 來更新 value 的值。const [query, setQuery] = useState(&quot;&quot;) query 為value 變數；setQuery 用來更新 query 的值；useState 內的則是query的初始值。在 input 中添加 onChange，使用 setQuery 更新 value 。 123456789const [query, setQuery] = useState(&quot;&quot;);&lt;input type = &quot;text&quot; name = &quot;query&quot; placeholder = &quot;Goziila vs Kong...&quot; value = {query} //添加value onChange ={(e) =&gt; setQuery(e.target.value)} //更新value/&gt; 使用 useState, useEffect 更新 movie (顯示給用戶的資料)獲得搜尋資料之後，需要將這些資料渲染到瀏覽器，因此需要一個 array 來存取這些資料。一樣先使用 useState 要設置 movies array，再用 useEffect 更新。把 movies array 更新成搜尋後獲得的資料。 1234567891011const [movies, setMovies] = useState([]) //movies是個arraytry{ const res = await fetch(url) const data = await res.json() setMovies(data.results) //把 movies array 更新成搜尋後獲得的資料 }catch(err){ console.error(err) }} 把搜尋結果呈現在畫面上 需要顯示在畫面上的資訊有：海報（poster_path），發行日期（release_date），電影簡介（overview），評分（vote_average）。可以用 movies array（裡面有剛才存進去的資料） 中調用我們需要的資料。使用 map 遍歷每一個搜尋結果，調用需要的資訊。 12345678910&lt;div className=&quot;card-list&quot;&gt; {movies.map(movie =&gt; ( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; //使用map都要加上key &lt;h3&gt;{movie.title}&lt;/h3&gt; //標題 &lt;p&gt;Release date: {movie.release_date}&lt;/p&gt; //發行日期 &lt;p&gt;OverView: {movie.overview}&lt;/p&gt; //簡介 &lt;p&gt;Rating: {movie.vote_average}&lt;/p&gt; //評分 &lt;/div&gt; ))}&lt;/div&gt; 海報照片有固定的 url 格式，改變的只有結尾的 poster_path ，因此只要更換最後這個部分就可以獲得海報連接。某些原本就沒有海報照片的電影會無法顯示，可以使用兩種方法解決這個狀況：直接篩掉沒有海報的電影或是顯示代替圖案。 1https://image.tmdb.org/t/p/[width size]/[poster_path] 方法1 : 直接篩掉沒有海報的電影 (.fliter) 12345678910&lt;div className=&quot;card-list&quot;&gt;//使用 .filter 只抓取 poster_path 為 true 的電影{movies.filter(movie =&gt; movie.poster_path).map(movie =&gt;( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title}/&gt; &lt;/div&gt; ))}&lt;/div&gt; 方法2 : 顯示代替圖案 (onError) 123456789101112&lt;div className=&quot;card-list&quot;&gt; {movies.map(movie =&gt; ( &lt;div className=&quot;card-info&quot; key={movie.id}&gt; &lt;img src={`https://image.tmdb.org/t/p/w300/${movie.poster_path}`} alt={movie.title} //當url為null時，使用替代圖片 onError={(e)=&gt;{e.target.onerror = null; e.target.src=&quot;https://i.postimg.cc/3RpfrHDh/photo.png&quot;}} /&gt; &lt;/div&gt; ))}&lt;/div&gt; 多個頁面Movies 頁面抓取 10頁 Top rated 的電影。這裡頁面切換使用 material ui 的 Pagination 製作。在抓取需要的資料後，設置 page 的 state，默認為 1，即抓取第一頁。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, {useState, useEffect} from 'react'import { Container, MovieCard } from &quot;../AllMovies/AllMovie_styles&quot;import CustomPagination from &quot;./CustomPagination&quot;import ContentModal from '../ContentModal/ContentModal'function AllMovies(){ const [ AllMovies, setAllMovies ] = useState([]) const [ page, setPage ] = useState(1) const API_KEY = process.env.REACT_APP_API_KEY const API_URL = &quot;https://api.themoviedb.org/3&quot; const all_movie_url = `${API_URL}/movie/top_rated?api_key=${API_KEY}&amp;language=en-US&amp;page=${page}` async function fetchAllMovies() { const res = await fetch(all_movie_url) const data = await res.json() setAllMovies(data) console.log(AllMovies.results) } useEffect(() =&gt; { fetchAllMovies() window.scroll(0,0) //回到最頂端 }, [page]) return( &lt;&gt; &lt;Container&gt; &lt;h2&gt;What to watch&lt;/h2&gt; {AllMovies.results &amp;&amp; AllMovies.results.map((movie) =&gt; ( //顯示的資料 &lt;MovieCard&gt; . . . &lt;/MovieCard&gt; ))} //傳入 CustomPagination component &lt;CustomPagination setPage={setPage}/&gt; &lt;/Container&gt; &lt;/&gt; )}export default AllMovies 在 Pagination component 裡處理頁面更新 page 的 state，將 page 更換成點擊的頁數，資料便會根據該頁數抓取那頁的資料。 CustomPagination.js12345678910111213141516171819202122import React from &quot;react&quot;import Pagination from &quot;@material-ui/lab/Pagination&quot;import styled from &quot;styled-components&quot;function CustomPagination({ setPage, numberOfPages = 10 }){ const handlePageChange = (page) =&gt; { setPage(page) window.scroll(0,0) } return( &lt;Pagination onChange={(e) =&gt; handlePageChange(e.target.textContent)} count={numberOfPages} //會顯示幾頁 shape=&quot;rounded&quot; hideNextButton hidePrevButton /&gt; )}export default CustomPagination 小結Search 頁面是第一個做的頁面，因此記錄得比較詳細，其他部分只記錄了一些沒有用過的功能。Live Demo 中無法點擊的部分是還沒做好的功能，裡面也還有 bug 還沒修好。 由於個別頁面和功能都是獨立做的，因此相似的功能會重複寫，架構也不是那麼清楚。之後有時間會把它再重新整理一下，筆記也會再同步更新。若有錯誤或是可以寫得更好的地方再麻煩各位大大指點 :) 參考資料Learn React in 1 Hour by Building a Movie Search AppMaterial UI Pagination","link":"/2021/04/17/0417-movie/"},{"title":"【實作記錄】Meme Generator | React","text":"GithubLive Demo 簡介Meme Generator 提供用戶製作迷因圖。使用串接 API 的方式將迷因圖呈現在畫面上，輸入文字後便可以下載該迷因圖。 功能 提供用戶挑選迷因模板 提供用戶輸入文字 提供圖片下載 前置作業 先看 meme api 所提供的文件 申請此網站的賬號（之後在處理 caption 環節時候會用到） 把 username 和 password 存在 env file 123456// filename:.env// 前綴要加上 REACT_APP 不然無法直接引用// 不需要額外安裝其他的套件REACT_APP_IMGFLIP_USERNAME = 用戶名REACT_APP_IMGFLIP_PASSWORD = 密碼 步驟fetch APIhttps://api.imgflip.com/get_memes抓取到的資料共有 100 筆，資料如照片所示。 12345678//filename : App.jsconst [templates, setTemplates] = useState([]); useEffect(( fetch(&quot;https://api.imgflip.com/get_memes&quot;) .then(res =&gt; res.json()) .then(json =&gt; setTemplates(json.data.memes)) ) ,[]) 把抓取到的資料呈現到畫面上。 12345678//filename : App.jsreturn ( &lt;div&gt; {templates.map(template =&gt; { return &lt;img style={{width:&quot;200px&quot;}} key={template.id} src={template.url} alt={template.name} /&gt; })} &lt;/div&gt; ) 點擊模板，進入該模板進行編輯點擊模板的動作可以使用 state 來處理。設置 template state，預設為 null，點擊後更新為該 template. 當 template 為 null 時，顯示所有模板；template 被更新後就顯示被點擊的模板以及供用戶輸入的框框。因為兩個地方都會用到模板，因此把模板拆成獨立的 component。 123456789101112131415161718192021const [template, setTemplate] = useState(null); //設定template的初始值為nullreturn ( &lt;div&gt; //如果點擊了圖片的情況 {template &amp;&amp; &lt;Meme template = {template} /&gt;} //如果沒有點擊圖片的情況 {!template &amp;&amp; templates.map(template =&gt; { return( &lt;Meme template = {template} onClick = {()=&gt; setTemplate(template) } /&gt; ) })} &lt;/div&gt; ) 123456789101112131415//filename : meme.js import React from &quot;react&quot;function Meme({template, onClick}){ return( &lt;img src={template.url} alt={template.name} onClick={onClick} /&gt; )}export default Meme 製作讓用戶輸入的框框使用form製作框框分別為 top text 以及 buttom text. 在 return 中，照片的位置下加入form，form內包含 2 個input。另外加入submit button 做提交資料用。 12345678910{template &amp;&amp; ( &lt;form onSubmit = {(e) =&gt; { e.prevertDefault()}} &gt; &lt;Meme template = {template} /&gt; //圖片顯示 &lt;input placeholder = &quot;top text&quot;/&gt; &lt;input placeholder = &quot;buttom text&quot;/&gt; &lt;button type = &quot;submit&quot;&gt; Generate &lt;/button&gt; &lt;/form&gt;)} 通過 API 將用戶的資料放到照片上 抓取用戶輸入的資料 設定點擊 submit button 後會執行的動作 使用 imgflip 網站提供的 image caption url 獲取已完成的迷因圖 如果成功獲取已經完成的迷因圖就顯示該圖片 抓取用戶輸入的資料用戶需要輸入的框框有兩個，分別為 top text 和 bottom text，都使用 state 來更新他們的 value. 12345678910//filename: App.jsconst [topText, setTopText] = useState(&quot;&quot;)const [bottomText, setBottomText] = useState(&quot;&quot;)&lt;input placeholder = &quot;top text&quot; value = {topText} onChange={(e) =&gt; setTopText(e.target.value)}/&gt; 設定點擊 submit button 後會執行的動作點擊 submit 之後，會去 fetch 設定到的 url 格式，這裡使用 async await 來處理。設定 url 的格式：需要 template_id, text0, text1, 用戶名, password. url 需要的參數通過 objectToQueryParams 傳入. 成功獲取資料後 json 回傳的是一個有已經完成的迷因圖的 url」 和是否成功的提示。將這個 url 存在 meme status 中。 123456789101112131415161718192021222324252627282930//filename: App.js//引入存在 env file 的資訊const username = process.env.REACT_APP_IMGFLIP_USERNAMEconst password = process.env.REACT_APP_IMGFLIP_PASSWORD//設定 url 格式const objectToQueryParam = (obj) =&gt; { const params = Object.entries(obj).map(([key, value]) =&gt; `${key}=${value}`) return &quot;?&quot; + params.join(&quot;&amp;&quot;)}&lt;form onSubmit = { async (e) =&gt; { e.preventDefault() const params = { template_id: template.id, text0: topText, text1: bottomText, username: username, password: password, } const response = await fetch( `https://api.imgflip.com/caption_image${objectToQueryParam(params)}` ) const json = await response.json() setMeme (json.data.url)&gt; 顯示已經完成的迷因圖將這個 url 存在 meme status 中，如果 meme 有資料，則顯示那張已經完成的迷因圖。 12345678910//filename: App.jsif (meme) { return ( &lt;div&gt; &lt;h2&gt;Feel free to download your meme.&lt;/h2&gt; &lt;img src={ meme } alt=&quot;custom meme&quot; /&gt; &lt;/div&gt; )} 小結上面的解說都只截取了部分的程式碼，看起來會有一些亂，文末附了完整的程式碼，參照著看會比較清楚。這是一個功能比較單一的迷因產生器，目前只能製作只需要輸入兩段文字的迷因，需要超過兩段文字的迷因圖，文字位置會措置，這個之後再回來修嘿。 完整的程式碼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// filename : App.jsimport React, {useState, useEffect} from &quot;react&quot;import Meme from &quot;./component/meme&quot;import &quot;./index.css&quot;const username = process.env.REACT_APP_IMGFLIP_USERNAMEconst password = process.env.REACT_APP_IMGFLIP_PASSWORD//caption url 格式設定const objectToQueryParam = (obj) =&gt; { const params = Object.entries(obj).map(([key, value]) =&gt; `${key}=${value}`) return &quot;?&quot; + params.join(&quot;&amp;&quot;)}function App() { const [templates, setTemplates] = useState([]) const [template, setTemplate] = useState(null) const [topText, setTopText] = useState(&quot;&quot;) const [bottomText, setBottomText] = useState(&quot;&quot;) const [meme, setMeme] = useState(null)//取得所有模板 useEffect(() =&gt; { fetch(&quot;https://api.imgflip.com/get_memes&quot;) .then(res =&gt; res.json() .then(json =&gt; setTemplates(json.data.memes)) ) },[])//如果成功獲得 meme url，則顯示該圖片 if (meme) { return ( &lt;div style={{ textAlign: &quot;center&quot; }}&gt; &lt;h2&gt;Feel free to download your meme.&lt;/h2&gt; &lt;img style={{ width: 200 }} src={ meme } alt=&quot;custom meme&quot; /&gt; &lt;/div&gt; ) } return ( &lt;div className=&quot;all_memes&quot;&gt; //如果 template 不是空的則顯示被點擊的那張圖 {template &amp;&amp; ( &lt;form onSubmit = { async (e) =&gt; { e.preventDefault() const params = { template_id: template.id, text0: topText, text1: bottomText, username: username, password: password, } const response = await fetch( `https://api.imgflip.com/caption_image${objectToQueryParam(params)}` ) const json = await response.json() setMeme (json.data.url) &gt; &lt;Meme template = {template} /&gt; &lt;input placeholder = &quot;top text&quot; value = {topText} onChange={(e) =&gt; setTopText(e.target.value)} /&gt; &lt;input placeholder = &quot;bottom text&quot; value = {bottomText} onChange={(e) =&gt; setBottomText(e.target.value)} /&gt; &lt;button type = &quot;submit&quot;&gt; Generate &lt;/button&gt; &lt;/form&gt; )} {!template &amp;&amp; ( &lt;&gt; &lt;h2&gt;Choose a template!&lt;/h2&gt; {templates.map((template) =&gt; { return ( &lt;&gt; &lt;Meme key = {template.id} template={template} onClick={() =&gt; {setTemplate(template) console.log(template)}} /&gt; &lt;/&gt; ) })} &lt;/&gt; )} &lt;/div&gt; )}export default App 123456789101112131415//filename : Meme.jsimport React from &quot;react&quot;function Meme({template, onClick}){ return( &lt;img style={{ width:&quot;10rem&quot;, height:&quot;10rem&quot;, objectFit: &quot;cover&quot;, padding: &quot;1.5em&quot;}} src={template.url} alt={template.name} onClick={onClick} /&gt; )}export default Meme","link":"/2021/04/15/0415-meme-generator/"},{"title":"【學習筆記】 Context | React","text":"此篇文章為看過 Scrimba 線上課程 （The Frontend Developer Career Path） 之教學影片後的筆記整理，內容與例子大多出自該教學影片。 簡介React 中的 component 傳遞是由上往下的，無法在同級的 component 間 / 在其他的分支間傳遞。如果要在同級間傳遞，就要將 state 提升到上一層 component，如果在不同分支，就要一直往上提升到兩個 component 間都有共用的為止。往上提升後，再把 props 一層一層往下傳，傳到天荒地老。 Context 可以解決這種狀況。提供資料的稱為 Provider ，使用資料的為 Consumer。把需要共用的資料包在 Provider 裡，需要調用資料的用 Comsumer 包起來。Consumer 不用通過中間一層一層的傳遞，就可以直接使用 Provider 中的資料。除了 Data , Method 也可以通過這個方法傳遞，如果當某個 components 更新後，需要同時將共用這個 method 的 component 一併更新也可以做到。 使用方式用 Provider 把 包起來123456//創造 contextconst Context名字 = React.createContext() &lt;Context名字.Provider value={&quot;dark&quot;}&gt; //value 是必要的 &lt;App /&gt;&lt;/Context名字.Provider&gt; Consumer 調用 dataclass component 方法一 : 在component 外引用1234需要引用資料的 component.contextType = 被創造的 provider//例子Button.contextType = ThemeContext 方法二 : 在 conponent 內引用 ( render() 前)1234static contextType = 被創造的 provider//例子static contextType = ThemeContext function component 123&lt;Context名字.Consumer&gt; function&lt;/Context名字.Consumer&gt; 使用 &lt;Context名字.Consumer&gt; 包起來，裡面必須要是 function 是 render props pattern 🌰 栗子 : 使用 context 處理點擊 button 後轉換主題的效果 基本的 context 架構123456789101112131415161718// filename : App.js// 引入 Header 以及 Button import React from &quot;react&quot;import Header from &quot;./Header&quot;import Button from &quot;./Button&quot;function App() { return ( &lt;div&gt; &lt;Header /&gt; &lt;Button /&gt; &lt;/div&gt; )}export default App 123456// filename : ThemeContext.js// 創造 contextimport React from &quot;react&quot;const ThemeContext = React.createContext()export default ThemeContext 1234567891011121314151617// filename : index.js// 使用 context providerimport React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';import ThemeContext from &quot;./ThemeContext&quot;ReactDOM.render( //使用theme context 的 method, Provider 沒有自己的component //後續會提到怎麼處理 &lt;ThemeContext.Provider value={&quot;dark&quot;}&gt; &lt;App /&gt; &lt;/ThemeContext.Provider&gt;, document.getElementById('root')) 1234567891011121314151617// filename : Button.js// 使用 context consumer + 簡單的判斷處理import React from &quot;react&quot;import ThemeContext from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;button className={`${theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContext.Consumer&gt; ) }export default Button 12345678910111213141516171819// filename : Header.js// 使用 context consumer + 簡單的判斷處理import React from &quot;react&quot;import ThemeContext from &quot;./ThemeContext&quot;function Header (){ return ( &lt;ThemeContext.Consumer&gt; {theme =&gt; ( &lt;header className={`${theme}-theme`}&gt; &lt;h2&gt;{theme === &quot;light&quot; ? &quot;Light&quot; : &quot;Dark&quot;} Theme&lt;/h2&gt; &lt;/header&gt; )} &lt;/ThemeContext.Consumer&gt; )} export default Header 截至這裡，效果如下。如果將 &lt;ThemeContext.Provider value={&quot;dark&quot;}&gt; 更換成 “light” 就會是 Light Theme. 現在要添加 switch button 切換主題的功能。如果要實現這個功能，需要使用到 state ，但現在 Context Provider 沒有自己的 component，因此要處理這個部分。 把 Context Provider 移到自己的 component現在要把 Context Provider 移到自己的 component，後續才能在該 component 裡處理 state. 123456// 原本的// filename : ThemeContext.jsimport React from &quot;react&quot;const ThemeContext = React.createContext()export default ThemeContext 1234567891011121314151617// 調整後// filename : ThemeContext.jsimport React, { Component } from &quot;react&quot;const {Provider, Consumer} = React.createContext()class ThemeContextProvider extends Component { render() { return ( &lt;Provider value={&quot;light&quot;}&gt; {this.props.children} &lt;/Provider&gt; ) }}export {ThemeContextProvider, Consumer as ThemeContextConsumer} 第 7 行 : 創造 ThemeContextProvider component, 這個 component 是之後要在 index.js 中被引用的。index.js 中引入的是 &lt;ThemeContext.Provider&gt; , 所以才這個 component 中要放入 &lt;ThemeContext.Provider&gt;. 第 11 行 : 確保所有 children 都會被 render. 第 5 行 : ThemeContext 本身就帶有 ThemeContext.Provider 以及 ThemeContext.Consumer，因此可以寫成 {Provider, Consumer}, 第 10 行 : 同時 return 內的 &lt;ThemeContext.Provider&gt; 就可以只寫成 &lt; Provider &gt;. 第 12 行 : 要把 ThemeContextProvider export 出去，但不能只寫 export default ThemeContextProvider , 這樣只會 export 這個 component. Header.js &amp; Button.js 會用到 ThemeContext，因此要把兩個都 export 出去。 第 17 行 : 在export 時，除了 ThemeContextProvider , Consumer 會以 ThemeContextConsumer export 出去。 由於 ThemeContext.js 中 export 出去的東西改變了，因此其他文件中也要修改。修改完後，結果會與上面的一樣。 1234567891011121314151617//filename : Button.js//Header.js &amp; index.js 同理import React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContextConsumer&gt; {theme =&gt; ( &lt;button className={`${theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContextConsumer&gt; ) }export default Button 修改 context : 增加 state 在 ThemeContext.js 中增加 state 以及轉換 theme 的 function 123456789101112131415161718192021222324252627282930//filename : ThemeContext.jsimport React, { Component } from &quot;react&quot;const {Provider, Consumer} = React.createContext()class ThemeContextProvider extends Component { //增加 state state = { theme : &quot;light&quot; } //增加轉換的 function toggleTheme = () =&gt;{ this.setState(prevstate =&gt;{ return{ theme : prevstate.theme === &quot;light&quot; ? &quot;dark&quot;:&quot;light&quot; } }) } render() { return ( &lt;Provider value={{theme: this.state.theme, toggleTheme: this.toggleTheme}}&gt; //value 可以傳 object {this.props.children} &lt;/Provider&gt; ) }}export {ThemeContextProvider, Consumer as ThemeContextConsumer} 把 state 和 function toggleTheme 連接到 Button.js, Header.js 中 1234567891011121314151617//filename : Button.jsimport React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;ThemeContextConsumer&gt; {context =&gt; ( &lt;button onClick={context.toggleTheme} className={`${context.theme}-theme`}&gt;Switch Theme&lt;/button&gt; )} &lt;/ThemeContextConsumer&gt; ) }export default Button 12345678910111213141516171819//filename : Header.jsimport React from &quot;react&quot;import {ThemeContextConsumer} from &quot;./ThemeContext&quot;function Header (){ return ( &lt;ThemeContextConsumer&gt; {context =&gt; ( &lt;header className={`${context.theme}-theme`}&gt; &lt;h2&gt;{context.theme === &quot;light&quot; ? &quot;Light&quot; : &quot;Dark&quot;} Theme&lt;/h2&gt; &lt;/header&gt; )} &lt;/ThemeContextConsumer&gt; )} export default Header 🌰 另一個栗子 : 使用 context 處理讓用戶更換 username 基本的 context 架構123456//filename : UserContext.jsimport React from &quot;react&quot;//創造 contextconst UserContext = React.createContext()export default UserContext 123456789101112131415//filename : index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &quot;./index.css&quot;import App from &quot;./App&quot;import UserContext from &quot;./userContext&quot;ReactDOM.render(//把 &lt;App/&gt; 包起來 &lt;UserContext.Provider value={&quot;Luke Skywalker&quot;}&gt; &lt;App /&gt; &lt;/UserContext.Provider&gt;, document.getElementById(&quot;root&quot;)) 123456789101112131415161718192021222324252627//filename : App.js//class componentimport React from &quot;react&quot;import Header from &quot;./Header&quot;import UserContext from &quot;./userContext&quot;class App extends React.Component { //引用 static contextType = UserContext render() { // 調用 this.context // this.context 是 index.js &lt;ThemeContext.Provider&gt;傳進來的 value const username = this.context return ( &lt;div&gt; &lt;Header /&gt; &lt;main&gt; &lt;p className=&quot;main&quot;&gt;No new notifications, {username}! 🎉&lt;/p&gt; &lt;/main&gt; &lt;/div&gt; ) }}export default App 12345678910111213141516171819//filename : Header.js//function componentimport React, {Component} from &quot;react&quot;import UserContext from &quot;./userContext&quot;function Header(props){ //傳進 props return( &lt;UserContext.Consumer&gt; //裡面要包 function {username =&gt; ( &lt;header&gt; &lt;p&gt;Welcome, {username}!&lt;/p&gt; &lt;/header&gt; )} &lt;/UserContext.Consumer&gt; )} export default Header 增加功能123456789101112131415//filename :index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import &quot;./index.css&quot;import App from &quot;./App&quot;import {UserContextProvider} from &quot;./userContext&quot;ReactDOM.render( &lt;UserContextProvider&gt; &lt;App /&gt; &lt;/UserContextProvider&gt;, document.getElementById(&quot;root&quot;)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344//filename : App.jsimport React from &quot;react&quot;import Header from &quot;./Header&quot;import {UserContextConsumer} from &quot;./userContext&quot;class App extends React.Component { state = { newUsername: &quot;&quot; } handleChange = (e) =&gt; { const {name, value} = e.target this.setState({[name]: value}) } render() { return ( &lt;div&gt; &lt;Header /&gt; &lt;UserContextConsumer&gt; {({username, changeUsername}) =&gt; ( &lt;main&gt; &lt;p className=&quot;main&quot;&gt;No new notifications, {username}! 🎉&lt;/p&gt; &lt;input type=&quot;text&quot; name=&quot;newUsername&quot; placeholder=&quot;New username&quot; value={this.state.newUsername} onChange={this.handleChange} /&gt; &lt;br/&gt; &lt;button onClick={() =&gt; changeUsername(this.state.newUsername)}&gt;Change Username&lt;/button&gt; &lt;/main&gt; )} &lt;/UserContextConsumer&gt; &lt;/div&gt; ) }}export default App 1234567891011121314151617181920212223242526//filename : userContext.jsimport React, { Component } from &quot;react&quot;const { Provider, Consumer } = React.createContext()class UserContextProvider extends Component { state = { username: &quot;Luke Skywalker&quot; } changeUsername = (username) =&gt; { this.setState({username}) } render () { const {username} = this.state return ( &lt;Provider value={{username, changeUsername : this.changeUsername}}&gt; {this.props.children} &lt;/Provider&gt; ) }}export { UserContextProvider, Consumer as UserContextConsumer } 1234567891011121314151617//filename : Header.jsimport React from &quot;react&quot;import {UserContextConsumer} from &quot;./userContext&quot;function Header(){ return ( &lt;header&gt; &lt;UserContextConsumer&gt; {({username}) =&gt; ( &lt;p&gt;Welcome, {username}!&lt;/p&gt; )} &lt;/UserContextConsumer&gt; &lt;/header&gt; ) } export default Header 特別情況小栗子 🌰 相同的 component 一個受 Provider 影響，另一個不 不在該 component 本身處理 context 可以在引入該 component 的地方做 123456789101112131415161718192021222324252627//filename : App.jsimport React from &quot;react&quot;import Header from &quot;./Header&quot;import Button from &quot;./Button&quot;import ThemeContext from &quot;./ThemeContext&quot;function App() { return ( &lt;div&gt; &lt;Header /&gt; //這個 button 引用 Provider 資料 &lt;ThemeContext.Consumer&gt; {theme =&gt;( &lt;Button theme={theme}/&gt; )} &lt;/ThemeContext.Consumer&gt; // 這個 button 不引用 &lt;Button theme=&quot;light&quot;/&gt; &lt;/div&gt; )}export default App 123456789101112131415161718192021//filename : button.jsimport React from &quot;react&quot;import PropTypes from &quot;prop-types&quot;import ThemeContext from &quot;./ThemeContext&quot;function Button(props) { return ( &lt;button className={`${props.theme}-theme`}&gt;Switch Theme&lt;/button&gt; ) }Button.propTypes = { //用來限定傳入的 value 局限於這兩個選擇 theme: PropTypes.oneOf([&quot;light&quot;, &quot;dark&quot;])}Button.defaultProps = { theme: &quot;light&quot;}export default Button 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬 參考資料上下文(Context)聊一聊我对 React Context 的理解以及应用","link":"/2021/04/23/0423-note-context/"},{"title":"【實作記錄】Typing Speed Test | React","text":"Live DemoGithub 簡介Typing Speed Test App 有基本的倒數計算字數的功能。運用了 React Hook 的 useState, useEffect 以及 useRef. 最後把 hook 獨立出來，讓程式碼易讀性更高。完整的程式碼附在文末。 功能 點擊按鈕開始計時，開始後無法再點擊按鈕 倒數結束，textarea 無法再輸入 字數與單個字數隨著用戶輸入不停更新 步驟基本設置設置基本樣式，包含輸入的地方 (textarea)、倒數器、每分鐘打了幾個字、每分鐘輸入了幾個字母、開始按鈕 (button). 增加 state 為 textarea 增加 state 用戶在輸入的時候，textarea 的 value 產生改變 App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, { useState } from &quot;react&quot;import './App.css';import &quot;./index.css&quot;//增加 statefunction App() { const [text, setText] = useState(&quot;&quot;) function handleChange(e){ const {value} = e.target setText(value) } return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;head&quot;&gt; &lt;header&gt; &lt;p className=&quot;subtile&quot;&gt;TYPING SPEED TEST&lt;/p&gt; &lt;h1&gt;How &lt;span&gt;fast&lt;/span&gt; do you type?&lt;/h1&gt; &lt;/header&gt; &lt;div className=&quot;result&quot;&gt; &lt;div className=&quot;time&quot;&gt; &lt;p className=&quot;num&quot;&gt;60&lt;/p&gt; &lt;p&gt;seconds&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;words&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;0&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;words/min&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;chars&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;0&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;chars/min&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;textarea className=&quot;area&quot; value={text} type=&quot;text&quot; name=&quot;typingArea&quot; onChange={handleChange} placeholder={&quot;Tales from the Galaxy’s Edge put players in the role of a droid-repair technician who crash landed on Batuu following a pirate attack.} /&gt; &lt;button type=&quot;submit&quot;&gt;Start&lt;/button&gt; &lt;p&gt;{text}&lt;/p&gt; //測試是否有成功增加 &lt;/div&gt; );}export default App; 算字數和單個字母 以空格分開，把輸入的字存進 array 裡，最後返回 array 的長度 字母同理 App.js12345678function wordsCount(keyInText){ const wordsArr = text.trim().split(&quot; &quot;) if (text !== &quot;&quot;){ return wordsArr.length }else{ return 0 }} 倒數計時器 使用 useEffect 搭配 setTimeout 處理 倒數開始：按下 start button 後 &amp; 當秒數大於 0 時 倒數結束：isTimeRunning state 要回到 false App.js123456789101112131415const [seconds, setSeconds] = useState(10)const [isTimeRunning, setisTimeRunning] = useState(false)useEffect(() =&gt; { if (isTimeRunning &amp;&amp;seconds &gt; 0){ setTimeout(() =&gt; { setSeconds(prevsec =&gt; prevsec - 1) }, 1000) }else if (seconds === 0){ setisTimeRunning(false) } },[seconds, isTimeRunning]) &lt;button onClick={() =&gt; setisTimeRunning(() =&gt; true)}&gt;Start&lt;/button&gt; Result 同步更新 用戶一遍輸入，result 一遍更新 App.js123456789const [word, setWord] = useState(0)const [char, setChar] = useState(0)function countingWords(){ setWord(wordsCount(text)) setChar(charsCount(text)) }useEffect(countingWords,[text]) 遊戲開始/進行時 StartGame() : 遊戲開始時初始化所有東西 useRef : 可以在不重新 Render 的狀況下更新值 遊戲開始時，自動 focus textarea, 用戶不用點擊就能開始打字 因為在 textarea 中設定了計時器尚開始前，處在 disabled 的狀態 所以如果只寫 textboxRef.current.focus()，其實是 focus 在 disabled 的狀態，點擊開始時不會自動 focus textarea 可以加上一行 textboxRef.current.disabled = false 解決這個問題 App.js123456789const STARTING_TIME = 60function startGame(){ setSeconds(STARTING_TIME) setIsTimeRunning(true) setText(&quot;&quot;) textboxRef.current.disabled = false textboxRef.current.focus() } button disabled : 遊戲進行時(計時器開始後)，button 無法點擊 App.js1&lt;button onClick={startGame} disabled={isTimeRunning}&gt;Start&lt;/button&gt; textarea disabled : 遊戲結束時(計時器結束時)， textarea 不能再輸入 App.js12345678&lt;textarea className=&quot;area&quot; value={text} type=&quot;text&quot; name=&quot;typingArea&quot; onChange={handleChange} disabled={!isTimeRunning} ref={textboxRef}/&gt; custom hook首先把原本在 App.js 建立好的各個 function 拆出放到另一個檔案（useWordGame.js），在這個檔案中要定義 custom hook. （參考下面完整的程式碼）把其他 component 需要用到的值或是 function 回傳。 useWordGame.js1return {seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame} App.js 中需要使用到的值以及 function 就可以使用剛剛定義好的 hooks, 就跟使用其他 hooks 一樣，接著就可以運用這些值 / function 了。 App.js1const { seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame } = useWordGame() 總結有好幾個需要的功能還沒放進去，先在這裡留個記錄，之後有機會再回來補。但經過這個小練習，也更熟悉 hook 的基本用法，希望之後可以挑戰更難得耶耶。 這篇筆記為個人學習記錄，若有錯誤或是可以改進的地方再麻煩各位大大指點（鞠躬 參考資料Hooks API Reference : useRef【Day 24】 useRef 完整程式碼App.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React from &quot;react&quot;import useWordGame from &quot;./useWordGame&quot; import &quot;./index.css&quot;function App() { const { seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame } = useWordGame() const article = &quot;Tales from the Galaxy’s Edge put players in the role of a droid-repair technician who crash landed on Batuu following a pirate attack. Upon entering a cantina owned by Seezelslak (played by Saturday Night Live’s and Star Wars Resistance’s Bobby Moynihan), players were swept up into an adventure that found them exploring Batuu and interacting with Star Wars characters new and classic. Part II looks to expand on that, starting with Dok-Ondar.&quot; return ( &lt;div className=&quot;container&quot;&gt; &lt;div className=&quot;head&quot;&gt; &lt;header&gt; &lt;p className=&quot;subtile&quot;&gt;TYPING SPEED TEST&lt;/p&gt; &lt;h1&gt;How &lt;span&gt;fast&lt;/span&gt; do you type?&lt;/h1&gt; &lt;/header&gt; &lt;hr/&gt; &lt;div className=&quot;result&quot;&gt; &lt;div className=&quot;time&quot;&gt; &lt;p className=&quot;num&quot;&gt;{seconds}&lt;/p&gt; &lt;p&gt;seconds&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;words&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;{word}&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;words/min&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;chars&quot;&gt; &lt;p className=&quot;num num-result border&quot;&gt;{char}&lt;/p&gt; &lt;p className=&quot;font-result&quot;&gt;chars/min&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;p className=&quot;article&quot;&gt;{article}&lt;/p&gt; &lt;textarea className=&quot;area&quot; value={text} type=&quot;text&quot; name=&quot;typingArea&quot; onChange={handleChange} disabled={!isTimeRunning} ref={textboxRef} placeholder={&quot;Start your test now!&quot;} /&gt; &lt;button onClick={startGame} disabled={isTimeRunning} &gt; Start &lt;/button&gt; &lt;/div&gt; );}export default App; useWordGame.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import { useState, useEffect, useRef } from &quot;react&quot;function useWordGame(){ const STARTING_TIME = 60 const [text, setText] = useState(&quot;&quot;) const [seconds, setSeconds] = useState(STARTING_TIME) const [isTimeRunning, setIsTimeRunning] = useState(false) const [word, setWord] = useState(0) const [char, setChar] = useState(0) const textboxRef = useRef(null) //input 改變 function handleChange(e){ const {value} = e.target setText(value) } //計算word function wordsCount(keyInText){ const wordsArr = text.trim().split(&quot; &quot;) if (text !== &quot;&quot;){ return wordsArr.length }else{ return 0 } } //計算character function charsCount(keyInText){ const charsArr = text.trim().split(&quot;&quot;) if (text !== &quot;&quot;){ return charsArr.length }else{ return 0 } } //遊戲開始 function startGame(){ setSeconds(STARTING_TIME) setIsTimeRunning(true) setText(&quot;&quot;) textboxRef.current.disabled = false textboxRef.current.focus() } function countingWords(){ setWord(wordsCount(text)) setChar(charsCount(text)) } //倒數 useEffect(() =&gt; { if (isTimeRunning &amp;&amp;seconds &gt; 0){ setTimeout(() =&gt; { setSeconds(prevsec =&gt; prevsec - 1) }, 1000) } else if (seconds === 0){ setIsTimeRunning(false) } },[seconds, isTimeRunning]) useEffect(countingWords,[text]) return {seconds, word, char, text, handleChange, isTimeRunning, textboxRef, startGame}}export default useWordGame","link":"/2021/04/24/0424-typing-speed-test/"},{"title":"【實作記錄】Netflix Clone | React","text":"Live DemoGithub 簡介這是一個模仿 netlfix 製成的網站，還原的部分有首頁、登入頁、選擇用戶、系列列表、分類列表、每張卡片的詳細資訊。 底下附上每一個 part 的製作過程， style 部分則不會全部記在筆記裡，主要記錄架構以及邏輯。 使用到的技術 使用 Coumpound Component 以及 Styled Component 使用 Firebase 儲存電影資料以及驗證用戶登入 使用 Fuse.js 出裡搜索功能 功能 頁面 : Home, sign in, sign up , browser Home : 訂閱 bar、簡介、常見問題 Sign in / Sign up : 使用 firebase 驗證登入 Browser : 進入電影列表前可以選擇用戶 Browser : 可以選擇 Series/ Films 兩個頁面 Browser : Series / Films 各有 4-5 個類別 Browser : 類別裡的卡片可以點擊，會出現該影片的詳細資訊以及播放按鈕 Browser : 點擊播放按鈕會出現播放器 Browser : 有搜尋功能 前置作業 下載 react-router-dom 1$ npm install --save react-router-dom styled-components 1$ npm i styled-components fuse.js 1$ npm install --save fuse.js 基本設置這個專案會使用到 compound component 以及 styled component.首先創建需要的資料夾以及基本文件設置。 App.js 中設置 router ，作換頁用 需要 4 個頁面 : 主頁、sign in 、sign up 、browser App.js 中的 routes 最後有更動 App.js1234567891011121314151617181920212223242526272829import React from 'react'import { Switch, Route } from 'react-router-dom'import Home from &quot;./pages/Home&quot;function App() { return ( &lt;Switch&gt; &lt;Route path=&quot;/signin&quot;&gt; &lt;p&gt;Sign in page&lt;/p&gt; &lt;/Route&gt; &lt;Route path=&quot;/signup&quot;&gt; &lt;p&gt;Sign up page&lt;/p&gt; &lt;/Route&gt; &lt;Route path=&quot;/browse&quot;&gt; &lt;p&gt;browse page&lt;/p&gt; &lt;/Route&gt; &lt;Route path=&quot;/&quot;&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; 步驟Netflix Clone : 首頁首頁由 5 個部分組成：Header 首頁大圖、Jumbotron 資訊塊、Accordion 常見問題、Otp form 訂閱表單、Footer 頁尾。每一塊都為單獨的component，組合起來後才渲染到瀏覽器。每一個 component 的創建邏輯相似：創建需要的元件 &gt; 創建組裝元件的 container，把需要的元件排進去 &gt; 添加樣式。 分開創建 component 除了便於維護外，最大的功能在於可以重複使用，就如 part 4 的 Opt form 在 part 5 的 header 中可以直接套用。 Netflix Clone : 用戶登入頁用戶登入包括了 sign in 和 sign up 兩個頁面。都使用了 firebase 的 auth 功能處理。Firebase 會幫忙驗證 email 和 password 的合法性。最後也會處理只有登入的用戶才能瀏覽 browser 頁的功能。真的是 hen 方便。 Netflix Clone : Browser 頁Browser 頁處理的東西比較多：用戶 Profile 選擇、首頁大圖、每列分類以及卡片、卡片詳細資訊、播放器、搜尋功能、sign out 功能。series 以及 films 的資料都存在 firestore 裡，之後有餘力會再多增加幾筆資料做換頁效果。 Netflix Clone : 最後整理最後是用戶登入的 auth 以及網頁的路徑。在用戶尚未登入前不能瀏覽 browser 頁面。 總結這個專案的過程都有詳細記錄下來，是希望之後如果需要類似的功能可以回來看看，希望到時候還記得寫了什麼東西（有多金魚腦）。這次小專案還是參考教學影片做的，但還是會吃力唉唉，像是在處理 firebase 的時候都要多花時間去看，但感覺還是沒那麼熟悉，下次再找專案玩玩看。從中學到了很多沒有學過的東西，也對 react 的邏輯和寫法更熟練了一些，但要說完全透徹還說不上。 第一次碰到 compound component 和 styled component, 是一個 all in JS 的寫法。這樣的寫法在多頁式的網頁中很方便，component 都可以互相使用，需要額外的功能就再往上加就可以了。Styled component 頗方便的地方在可以傳入變數和可以在 JS 裡設定樣式，selector 也還算容易理解。資料的處理則是存放在 firestore 裡，需要的時候再調用。 每一個地方都有小小相似和不相似的地方，怎麼去融會貫通和運用類似的概念也有好好練習了。再來是 Google 的能力，文件/技術更換得很快除了看文件外，下對關鍵字也很重要（淚），相似的問題可能其他人也遇過。 東西對我而言都是新的，參數傳來傳去，這裡加來加去、套來套去有時候找不到 bug 會很阿雜，但找到後/完成一個功能成就感會爆棚。完整這個專案可以補充一天半份的開心。最後，文章內有觀念不對或是其他錯誤，請各位大大指教，謝謝！（鞠躬 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/02/0502-netflix-clone-1/"},{"title":"【實作記錄】Netflix Clone：最後整理","text":"Live DemoGithub 簡介最後是用戶登入的 auth 以及網頁的路徑。在用戶尚未登入前不能瀏覽 browser 頁面。 經過前面幾個 part，component 以及基本的功能都處理完畢。最後就可以收尾啦。 Custom Auth Listener Hook use-auth-listener (hooks) >folded12345678910111213141516171819202122232425import { useState, useEffect, useContext } from &quot;react&quot;import { FirebaseContext } from &quot;../context/firebase&quot;function useAuthListener() { const [user, setUser] = useState() const { firebase } = useContext(FirebaseContext) useEffect(() =&gt; { const listener = firebase.auth().onAuthStateChanged((authUser) =&gt; { if (authUser) { localStorage.setItem(&quot;authUser&quot;, JSON.stringify(authUser)) setUser(authUser) } else { localStorage.removeItem('authUser') setUser(null) } }) return () =&gt; listener() }, []) return { user }}export default useAuthListener App.js >folded123456789101112131415161718192021222324252627282930313233import React from 'react'import { Switch, Route } from 'react-router-dom'import * as ROUTES from './constants/routes';import { Home, Signin, Signup, Browse } from &quot;./pages&quot;import { useAuthListener } from &quot;./hooks&quot;function App() { const { user } = useAuthListener() return ( &lt;Switch&gt; &lt;Route path={ROUTES.SIGN_IN}&gt; &lt;Signin /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.SIGN_UP}&gt; &lt;Signup /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.BROWSE}&gt; &lt;Browse /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; Modifying Our App Routes to Be Protected確保用戶在登陸之後才能瀏覽頁面，如果直接跳到 browse 頁面，會將用戶導回 sign in page. routes.js (helpers) >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';import { Route, Redirect } from 'react-router-dom';export function IsUserRedirect({ user, loggedInPath, children, ...restProps }) { return ( &lt;Route {...restProps} render={() =&gt; { if (!user) { return children; } if (user) { return ( &lt;Redirect //to 後面要接 2 個括號 to={ pathname: loggedInPath, } /&gt; ) } return null }} /&gt; )}export function ProtectedRoute({ user, children, ...restProps }) { return ( &lt;Route {...restProps} render={({ location }) =&gt; { if (user) { return children; } if (!user) { return ( &lt;Redirect//to 後面要接 2 個括號 to={ pathname: 'signin', state: { from: location }, } /&gt; ) } return null }} /&gt; )} App.js >folded1234567891011121314&lt;Switch&gt; &lt;IsUserRedirect user={user} loggedInPath={ROUTES.BROWSE} path={ROUTES.SIGN_IN}&gt; &lt;Signin /&gt; &lt;/IsUserRedirect&gt; &lt;IsUserRedirect user={user} loggedInPath={ROUTES.BROWSE} path={ROUTES.SIGN_UP}&gt; &lt;Signup /&gt; &lt;/IsUserRedirect&gt; &lt;ProtectedRoute user={user} path={ROUTES.BROWSE}&gt; &lt;Browse /&gt; &lt;/ProtectedRoute&gt; &lt;IsUserRedirect user={user} loggedInPath={ROUTES.BROWSE} path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/IsUserRedirect&gt;&lt;/Switch&gt; 參考資料設置身份驗證狀態觀察器並獲取用戶數據 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/11/0511-netflix-clone-5/"},{"title":"【JavaScript】JS 的 this","text":"本篇大綱： this 在 4 種情境下指向什麼 快速判斷 this 的小方法 箭頭函式的 this this 用法解析器（瀏覽器）在呼叫函式的時候都會傳隱形的參數，就是 this . this 指向一個物件，這個物件是上下文物件。根據函式呼叫的方法不同， this 會指向不同的東西。 純粹函式呼叫（直接呼叫）這是函式最通常用法，屬於全局性呼叫， this 代表全局對象 (window)。this 在脫離物件導向之後，沒有什麼太大的意義。 12345678//直接呼叫var name = &quot;Luke&quot;function test() { console.log(this.name)}test() //Luke 1234567//脫離物件導向的 thisfunction hello(){ console.log(this)}hello() //window this 上述例子的情況下，不是指向 hello 這個 function。瀏覽器、node.js 會有預設綁定的值： 嚴格模式，都是 undefined 非嚴格模式，瀏覽器下是 window 非嚴格模式，node.js 下是 global 作為物件的方法呼叫（物件呼叫）使用函式的方法呼叫， this 是呼叫方法的那個對象。 12345678910111213141516171819202122232425// 物件呼叫function fun(){ console.log(this)}var obj ={ name : &quot;Winnie&quot;, sayName:fun};var obj2 ={ name : &quot;huini&quot;, sayName:fun};console.log(obj.sayName === fun)obj.sayName() //這是 obj 調用的函式，所以 this 會指向這個物件obj2.sayName() //這是 obj2 調用的函式&gt;&gt;&gt; true&gt;&gt;&gt; { name: 'Winnie', sayName: [Function: fun] } //回傳的是obj這個物件，this 變成了 obj&gt;&gt;&gt; { name: 'huini', sayName: [Function: fun] } 作為構造函式呼叫通過函式產生的新對象（實例），這時的 this 會指向這個新對象。 使用 new 關鍵字創造了 person 這個實例後，Fun function 中的 this 就指向了 person. 呼叫 person.name 會印出 Luke。印 name 時仍然會印出開始就宣告的 Leia，表明了這裡的 this 並不是全局物件。（與上面直接呼叫的情況不同） 12345678910111213// 作為構造函式呼叫var name = &quot;Leia&quot;function Fun() { this.name = &quot;Luke&quot;}var person = new Fun()console.log(person.name) //Lukeconsole.log(person) //Fun { name: 'Luke' }console.log(name) //Leia 各種強行呼叫：apply、call、bind（強行呼叫）在 this 有原本預設的值的情況下，如果想要更改它，一共有三個方法：apply、call、bind. call 的使用方式與 apply 差不多，call 的呼叫方式跟一般的 function 一樣，apply 在傳入參數時使用 array 的方式。 12345678'use strict' //嚴格模式下function hello(a, b){ console.log(this, a, b)}hello(1, 2) //undefined 1 2hello.call(undefined, 1, 2) //undefined 1 2hello.apply(undefined, [1,2]) //undefined 1 2 apply() 與 call()apply() 和 call() 的效果幾乎一樣，它們在這裡的作用是改變函式的呼叫對象。第一個參數代表的是「改變後的呼叫這個函式的物件」，這時的 this 指的就是這個參數。 從第一個例子中可看到，如果第一個參數是空的，默認呼叫全局物件，this 指向的是全局物件，因此會印出 Luke。另一種情況是第一個參數填入了其他物件，this 就會轉而指向這個被填入的物件，所以會印出 Rey. apply 和 call 產生的結果是一樣的。 1234567891011121314var name = &quot;Luke&quot;function test() { console.log(this.name)}var obj = {}obj.name = &quot;Rey&quot;obj.m = testtest() //Lukeobj.m.apply() //Lukeobj.m.apply(obj) //Reyobj.m.call() //Lukeobj.m.call(obj) //Rey 再來看一個例子。在嚴格模式下，如果第一個參數是 undefined， 印出的也會是 undefined. 當第一個參數傳入 Luke 和 Leia 之後，印出的就是這兩個字串，可以證明 this 指向的是這個參數。 123456789101112'use strict' //嚴格模式下function hello(a, b){ console.log(this, a, b)}hello(1, 2) //undefined 1 2hello.call(undefined, 1, 2) //undefined 1 2hello.apply(undefined, [3,4]) //undefined 3 4hello.call(&quot;Luke&quot; , 1, 2) //Luke 1 2hello.apply(&quot;Leia&quot; , [3, 4]) //Leia 3 4 儘管 this 指向的是別的東西，在使用這兩個方法之後也會被覆蓋掉。原本的 this 應該是 myPerson 這個實例，但經過 call 和 apply 傳進去的參數後，this 就被改變了。 12345678910class Person { hello() { console.log(this) } } const myPerson = new Person()myPerson.hello() // myPerson instancemyPerson.hello.call('Luke') // LukemyPerson.hello.apply('Leia') // Leia bind()123456789'use strict';function hello() { console.log(this)}const myPerson = hello.bind(&quot;Luke&quot;)myPerson() // LukemyPerson.call(&quot;Rey&quot;) // Luke ( 前面已經被綁定過了，因此不會改變 )myPerson.apply(&quot;Leia&quot;) // Luke ( 前面已經被綁定過了，因此不會改變 ) bind 會回傳一個新的 function. 將 hello 這個 function 使用 Luke 來綁定，在呼叫 myPerson() 的時候會輸出 Luke. 已經被 bind 過回傳的 function，不能再使用 call / apply 去改變 this 指向的物件。即使使用了，還是會回傳已經被綁定的值。 另一種判斷 this 方式可以將所有 function 都轉成用 call 呼叫。這樣一來就能夠快速的看出 this 會指向什麼。方法是這樣的，以下面的程式碼為例： 轉換的規則是：call 的第一個參數會是 method 前的東西。obj.hello() 會轉換成 obj.hello.call(obj)，根據前面所說的第一個參數就是 this 會指向的物件，這裡的 this 就是 obj ; hey() 轉換成 hey.call() , this 是 undefined. 12345678910const obj = { value: 1, hello: function() { console.log(this.value) }}obj.hello() // 1const hey = obj.hellohey() // undefined 12345678910111213141516171819const obj = { value: 1, hello: function() { console.log(this.value) }, inner: { value: 2, hello: function() { console.log(this.value) } }}const obj2 = obj.innerconst hello = obj.inner.helloobj.inner.hello() //轉換成 obj.inner.hello.call(obj.inner) =&gt; 2obj2.hello() //轉換成 obj2.hello.call(obj.2) =&gt; 2hello() //hello.call =&gt; undefined 再來看一個例子，程式碼執行後的結果會是 2。 obj.hello() 會被轉為 obj.hello.call(obj)，這裡的 this 會指向 obj. 而 obj.hello() 中的 hello2 其實與 obj 的 value 無關，hello2() 被轉為 hello2.call()，這裡的 this 會指向 window，window 的 value 為 2，hello2 的 this.value 也會是 2. 123456789101112var value = 2var obj = { value: 10, hello: function(){ var hello2 = function(){ console.log(this.value) } hello2() }}obj.hello() //2 在遇到函數陣列的時候，也可以用這樣的方式去找 this. 可以將 arr[0]() 想象成 arr.0() ( 語法不對哦，只是假想 )，這個格式就能夠套上前面說說的方法了：arr.0.call(arr)，this 就是 arr. 123function fn (){ console.log(this) }var arr = [fn, fn2]arr[0]() //this 為 arr 箭頭函式箭頭函式是 ES6 新增的，它本身並沒有 this， 因此「在宣告他的地方的 this 是什麼，他的 this 就是什麼」。以下面這例子來說，hello 的 this 是什麼， test 的 this 就是什麼。 在呼叫 obj.hello() 的時候，這裡的 this 會是 obj ( obj.hello(obj) )，因此 test 的 this 也會是 obj. 1234567891011121314const obj = { x: 1, hello: function(){ console.log(this) const test = () =&gt; { console.log(this.x) } test() }}obj.hello() // 1const hello = obj.hellohello() // undefined 小結這裡簡單整理了 this 的 4 種使用方式，沒有涉獵較為複雜的使用情景。如果要快速知道 this 指向的物件可以使用 call() 來判斷，就可以輕鬆取得 this 的值。最後做個使用方式的小總結： 【直接呼叫】呼叫函式的話，this 永遠都是 window → fun() 【物件呼叫】使用函式的方法的話，this 是呼叫方法的那個對象 → obj.name() 【作為以構造式函式呼叫】this 指向的是新創造的物件 → new func() 【強行呼叫】會指向呼叫的對象 → call、apply、bind(obj) 參考資料淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂Javascript 的 this 用法this 的值到底是什么？一次说清楚你怎么还没搞懂 this？","link":"/2021/06/20/0620-js-this/"},{"title":"【Nuxt】 一個 Nuxt.js 搭配 VueX 的 CRUD 小栗子","text":"本篇大綱： 簡介 前置作業 Vuex 設定 CRUD 功能 簡介這是一個 Nuxt 搭配 Vuex 的 CRUD 栗子。 Source codeLive Demo 前置作業新增 Nuxt 專案1npx create-nuxt-app crud-app 在輸入指令後會提供幾個項目的選擇，包括服務器端框架、UI 框架、測試框架、Nuxt 模式等。這裡的 UI 框架選擇的是 Vuetify.js. 準備資料這裡使用了 JSONPlaceholder 提供的 API. 裡面提供的例子使用 fetch， 所以在這個例子裡，就可以直接 抄起來 使用. 要注意的是：這個 API 在發送新增 / 更新 / 刪除的 request 時並不會真的更改原本的資料。 設定 UI 部分這裡需要的 UI 只有 form, card, button, 直接套用 vuetify 裡的模板。 Vuex 設定Vuex 是類似 Redux 的 state 集中管理器。這裡的 state 比較單純，只有我們設定的 posts 一項，用來儲存每筆的資料。 這裡會用到 Vuex 的功能包含了： state, mutation, action. 因為 Nuxt 已經幫忙處理 Vuex 後面的東西，所以只要按照 文件 上的方式使用就可以了。 Vuex 的檔案會放在 store 底下。 State這裡創造了一個 posts 為空 array, 用來儲存資料。 123456//filename : index.jsexport const state = () =&gt; ({ posts: []}) Action要執行的動作會在 action 裡處理. Action 並不會直接改變 state， 而是會提交 mutation，由mutation 來改變 state. Action 會通過 store.dispatch 被觸發，會在 nuxt 的 methods 中 dispatch。 123456789//例子methods: { async createPost () { await this.$store.dispatch('createPost', { title: this.title, body: this.body }) this.title = '' this.body = '' },} dispatch 的第二個參數是我們想要傳到 action 的參數。如果要傳多個參數就要將他們包成一個 object 往下傳，因為 action 只能接受 1 個參數。 action 在接收參數時候，要注意參數位置。第一個參數：內建的參數，如 commit / state；第二個參數：自己要往下傳的參數。 1234567891011//錯誤例子export const actions = { async createPost ({ commit , title, body }) {// 這裡會是兩個參數不是一個：// async createPost ({commit}, {title, body}) · · · }} mutationMutation 是最為底層的操作，比如說「把某個變數改成 true」、「把這筆資料塞到 array 裡」的操作。因此在命名上也要以改 function 做了什麼為標準，才能做到最大程度的重複使用和避免混淆。 CRUD 功能CRUD 的功能包括增加 (Create), 讀取 (Read), 更新 (Update) 和 刪除 (Delete). JSONplaceholder 提供了這四個方法但因為發送的請求不會改變原本的資料，所以其實都是在操作自己的 array. Read 讀取在執行其他 function 前，會先將資料抓取下來，所以這個步驟會放在 Nuxt mouted() 裡。 123456//filename : index.vueasync mounted () { await this.$store.dispatch('initPost')}, Action 中的 init post 會發送請求，data 會是 100 筆的資料。 第 4 行 : commit 是 action 自帶的參數 第 7 行 : 每筆資料都需要 show 這個變數，用來控制是一般狀態 / 可編輯狀態 123456789101112//filename : index.jsexport const actions = { async initPost ({ commit }) { const res = await fetch('https://jsonplaceholder.typicode.com/posts') const data = await res.json() data.forEach((item) =&gt; { item.show = true }) commit('setPosts', data) }, ...} 12345678910//filename : index.js// 把 posts 設成 action 抓下來的 dataexport const mutations = { setPosts (state, data) { state.posts = data }, ...} Create 增加提供用戶輸入 title 和 body 兩個部分。需要把用戶輸入的 title 和 body 都往下傳。 12345678910//index.vuemethods: { async createPost () { await this.$store.dispatch('createPost', { title: this.title, body: this.body }) this.title = '' this.body = '' }, ...} 每則 comment 的 id 使用亂數產生。這裡發送的 request 並不會直接更新到原本的資料，只會把這筆資料加到 posts 裡。 與前面的相同，這裡需要為新增的資料加上 show 變數。 123456789101112131415161718192021222324252627//index.jsexport const actions = { ... async createPost ({ commit }, { title, body }) { const res = await fetch('https://jsonplaceholder.typicode.com/posts', { method: 'POST', body: JSON.stringify({ title, body, userId: 1 }), headers: { 'Content-type': 'application/json; charset=UTF-8' } }) const post = await res.json() post.show = true post.id = Math.floor(Math.random() * 10000) // console.log(post) commit('pushPost', post) }, ...} 這裡的動作就是將新增加的這筆資料加到 posts 裡。這裡的 post 存在 state 裡，所以要使用 state.posts 才能讀取。 1234567891011//index.jsexport const mutations = { ... pushPost (state, post) { state.posts.unshift(post) }, ...} Update 更新更新資料一樣使用 JSONplaceholder 提供的 API. 更新資料的邏輯是設定兩個區塊( 一般顯示/ 顯示 form 欄位 )，使用 show 當做變數來操控：當 show 為 true 時，就顯示正常的狀況、反之則顯示 form 讓用戶更新資料。 123456789101112131415161718192021//index.vuemethods: { ... async updatePost (post, editedTitle, editedBody) { await this.$store.dispatch('updatePost', { post, editedTitle: this.editedTitle, editedBody: this.editedBody }) }, editBtn (post) { this.$store.dispatch('editBtn', post) this.editedTitle = post.title this.editedBody = post.body }, ...} 因為這裡不會改變原本的資料，因此這裡的 URL 後面的 id 可以不用改。再者，因為在創造新資料的時候，創造新的 id 是使用亂數產生，這些亂數並不存在在原本的資料中，因此用新 id 去發送請求會出現 error. 在 form 出現的時候，submit 和 cancel button 會一同出現，edit 和 delete 就會隱藏起來。（會在 template 裡處理）. edit button 和 cancel button 都是使用 for loop 的方式去找導被點擊的卡片。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//index.jsexport const actions = { ... async updatePost ({ commit }, { post, editedTitle, editedBody }) { const res = await fetch('https://jsonplaceholder.typicode.com/posts/1', { method: 'PUT', body: JSON.stringify({ id: 1, title: post.title, body: post.body, userId: 1 }), headers: { 'Content-type': 'application/json; charset=UTF-8' } }) await res.json() commit('setPost', { id: post.id, title: editedTitle, body: editedBody }) commit('setShow', { id: post.id, show: true }) }, editBtn ({ commit, state }, post) { state.posts.forEach((item) =&gt; { if (item.id !== post.id) { commit('setShow', { id: item.id, show: true }) } }) commit('setShow', { id: post.id, show: !post.show }) }, cancelBtn ({ commit, state }, post) { const postIndex = state.posts.findIndex(item =&gt; item.id === post.id) state.posts.forEach((item) =&gt; { if (item.id === postIndex) { commit('setShow', { id: item.id, show: true }) } }) commit('setShow', { id: post.id, show: true }) }, ...} 12345678910111213141516171819202122//index.jsexport const mutations = { ... setPost (state, { id, title, body }) { const postIndex = state.posts.findIndex(item =&gt; item.id === id) this._vm.$set(state.posts, postIndex, { title, body, id, show: true }) }, setShow (state, { id, show }) { const postIndex = state.posts.findIndex(item =&gt; item.id === id) state.posts[postIndex].show = show } ...} Delete 刪除如前面所說的，發出去的 request 並不會真的改變原本的資料。因此這裡刪除的處理方式就是將被點到 comment 從 posts array 中移除。 1234567// filename : index.vuemethods: { ... deletePost (post) { this.$store.dispatch('deletePost', post) }} 12345678910111213//index.jsexport const actions = { ... deletePost ({ commit }, post) { fetch(`https://jsonplaceholder.typicode.com/posts/${post.id}`, { method: 'DELETE' }) commit('removePost', post.id) }} 1234567891011//index.jsexport const mutations = { ... removePost (state, id) { const removeItem = state.posts.findIndex(item =&gt; item.id === id) state.posts.splice(removeItem, 1) }, ... }} 其他小筆記全局引入 CSS這個例子其實沒有用到很多的樣式，但還是有一個 CSS 檔案需要引入。這裡選擇了最方便的方式：在 nuxt.config.js 中全局引入。 因為還沒有深入研究全局引入和其他方式引入有什麼優劣，因此這裡就是用我認為最方便的方法。 methods 裡的 functionmethods 是一個 dictionary, 內容看起來不是常見的 key: value pair, 他其實是簡寫。原本長得是這個樣子，但如果後面接的是匿名函式就可以簡寫成 createPost() {...} . 1234567//原本長這樣methods: { createPost: () =&gt; { ... }} 部署到 github page這裡參考了這篇文章：28. Nuxt 靜態頁部署 ，就沒有在另外寫筆記啦。 小結這次機緣巧合下需要接觸 Vue 和 Nuxt 所做出來的小栗子。當中有遇到一些參數傳遞的問題，以及一些元件沒有及時更新的問題，後者的問題在使用 Vuex 之後就解決了。其他遇到的坑或是需要留意的部分都記錄下來了。 心得就是不會就要問，卡太久就要問，問了就會記下來這樣。因為這是第一次接觸 Nuxt, 以前也沒有寫過 Vue, 弄起來還是有些吃力，背後的原理還是概念會再慢慢補起來，這裡就當做一個簡單記錄。","link":"/2021/07/21/0721-nuxt-vuex/"},{"title":"【JavaScript】JS 的原型鏈","text":"本篇大綱： 原型是什麼 原型鏈是什麼 檢查屬性以及實例的方法 JavaScript 的物件通過原型 (Prototype) 機制來達到相互繼承功能。當使用 Constructor Function 創造 object 時，所創造出來的物件不共享 constructor 的屬性和方法。說創造出來的物件稱為實例 ( instance ). 12345678910111213141516// prototype 例子// 不共享屬性function Person(first, last, gender) { this.first = first this.last = last this.gender = &quot;male&quot;}var person_one = new Person()var person_two = new Person()person_two.gender = &quot;female&quot;console.log(person_one.gender) //maleconsole.log(person_two.gender) //female person_one 和 person_two 的 gender 屬性是獨立的，因此在修改 person_two 的 gender 時，不會影響到 person_one，兩個函式之間不共享屬性。 原型 Prototype如果要讓所有實例都共享同一個屬性，可以運用實例的特性：當函式以構建函式的形式創建的時候，所創建的物件都有一個隱含的屬性( __ proto __ )，指向該構建函式的原型物件。 因此如果將屬性設置到 prototype，所有函式都能夠存取到該屬性。設置的方式為：FunctionName.prototype.variable . Person 這個函式物件以及他的實例的 __ proto __ 指向的是同一個 prototype。這裡將 gender 這個屬性設置到 prototype，因此所有實例都可以取得這個屬性。 person_one 這個實例另外設置了 gender 屬性。當呼叫物件的屬性時，首先會查找自身物件是否有該屬性，有的話就會回傳本身的，沒有的話則會往上一層 prototype 找，直到找到該屬性為止，如果到頂層都沒有找到就會回傳 undefined。因此，person_one.gender 會回傳 female , 而 person_two.gender 回傳 male . 1234567891011121314151617181920212223242526// prototype 例子function Person() {}//向 Person 的 prototype 中添加屬性 genderPerson.prototype.gender = &quot;male&quot; Person.prototype.sayHello = function() { return &quot;Hellooo&quot;}var person_one = new Person()var person_two = new Person()//設置 person_one 的 genderperson_one.gender = &quot;female&quot;console.log(person_one.gender) //會先找自身有沒有該屬性，有的話會直接使用; person_中有 gender 屬性，所以會使用自身的 genderconsole.log(person_two.gender) //因為 person_ two 中沒有屬性 gender, 所以會去原型物件中找console.log(person_one.sayHello())//可以呼叫 prototype 裡的 functionconsole.log(person_one.age) //這個屬性不存在&gt; female&gt; male&gt; Hellooo&gt; undefined 小結： 原型物件就像是一個公共區域，同一個構造函式的實例都可以取得這個原型物件。 當呼叫物件的屬性時，如果物件有該屬性，就會使用自身的；沒有的話就會往 prototype 找。 prototype 裡也可以設置 function 如果普通函式呼叫 prototype method，並不會起任何作用。 關於原型鏈實例的 __ proto __ 會指向 constructor 的 prototype。 如果呼叫某個物件的屬性，如 person_two.gender, 如果在自身 object 裡找不到，就會往上一層 Person.prototype 找，如果還是沒有，就找 Person.prototype.__ proto __ ，直到找到某個東西的 __ proto __ 是 null 為止。 眾多 __ ptoto __ 串起來的鏈就稱為原型鏈。通過原型鏈，可以達成類似繼承的功能，得以呼叫自己 parent 的 method. PS: Person.__ proto __ 是 Function.prototype , Person 是 Function 的 instance. 1234567891011121314function Person(first,last) { this.first = first this.last = last}Person.prototype.gender = &quot;male&quot;var person_one = new Person(&quot;Sky&quot;,&quot;Walker&quot;)//person_one.__proto__ 指向 Person.prototypeconsole.log(person_one.__proto__ === Person.prototype) //Person.prototype.__proto__ 指向 object.prototypeconsole.log(Person.prototype.__proto__ === Object.prototype) //object.prototype 是 null 為原型鏈的頂端console.log(Object.prototype.__proto__) 其他檢查屬性 in : 使用 in 檢查物件中是否含有某個屬性，如果物件中沒有，但 prototype 有會返回true object.hasOwnProperty(): 檢查物件自身有沒有這個屬性 123456789101112131415161718//檢查屬性function Person(first,last) { this.first = first this.last = last}Person.prototype.gender = &quot;male&quot;var person_one = new Person(&quot;Sky&quot;,&quot;Walker&quot;)person_one.age = 42console.log(&quot;gender&quot; in person_one) //trueconsole.log(&quot;age&quot; in person_one) //trueconsole.log(person_one.hasOwnProperty(&quot;gender&quot;)) //false console.log(person_one.hasOwnProperty(&quot;last&quot;)) //trueconsole.log(person_one.hasOwnProperty(&quot;age&quot;)) //true 檢查實例 instanceOf : 檢查函式是不是某個 constructor 的 instance , 會往上搜查原型鏈。 1234567891011//檢查實例function Person(first,last) { this.first = first this.last = last}var person_one = new Person(&quot;Sky&quot;,&quot;Walker&quot;)console.log(person_one instanceof Person) //trueconsole.log(person_one instanceof Object) //true 參考資料該來理解 JavaScript 的原型鍊了你不可不知的原型鏈Prototype | JavaScript鍛鍊日記","link":"/2021/06/20/0620-js-prototype/"},{"title":"【Vue】 欸欸來切換語言啊 (Vue 3 搭配 Vue CLI 與 i18n)","text":"本篇大綱： 環境設置 準備多語言檔案 檔案設定 在 component 中使用 其他資料格式 簡介這是一篇 Vue3 搭配 Vue CLI 使用 i18n 來切換網站語言的栗子。 環境設置 node : v14.17.1 vue : “^3.0.0” vue-cli : “~4.5.0” vue-i18n : “^9.1.7” 安裝 i18nVue I18n 1npm install vue-i18n@next 檔案架構123456789src├- i18n.js //設定 i18n 檔案├- i18n ├-- tw.json //中文翻譯 ├-- en.json //英文翻譯├- components ├-- HelloWorld.vue ├- App.vue├- main.js 準備多語言檔案使用 json 檔案儲存個別語言對應的名詞，這裡準備了 zh-TW (繁體中文) 和 en-US (英文) 兩種語言。 12345678//filename : tw.json{ &quot;name&quot;: &quot;姓名&quot;, &quot;gender&quot;: &quot;性別&quot;, &quot;email&quot; : &quot;電郵&quot;, &quot;address&quot;: &quot;地址&quot;} 1234567//filename : en.json{ &quot;name&quot;: &quot;Name&quot;, &quot;gender&quot;: &quot;Gender&quot;, &quot;email&quot; : &quot;Email&quot;, &quot;address&quot;: &quot;Address&quot;} 檔案設定設定 i18n 檔案需要使用 createI18n 來設定，其中需要 3 個參數 ： locale (設定語言)、 fallbacakLocale ( 如果翻譯失敗使用的語言 )、messages ( 各個語言翻譯的檔案 )。 這裡為了方便起見所以使用 json 檔案來儲存各語言的翻譯，再引入到 messages 裡。 因為沒有另外建立 store 來儲存語言這個變數，因此語言設定從 local storage 中的 language 中取得，也可以將預設語言設定為電腦本身的語言 : let lang = navigator.language || 'tw' . 1234567891011121314151617181920//filename: i18n.jsimport { createI18n } from &quot;vue-i18n&quot; //引入 createI18n//引入需要的 json 檔案const messages = { &quot;en-US&quot; : require('./i18n/en.json'), &quot;zh-TW&quot; : require('./i18n/tw.json')}//設定語言，從 local storage 取得const lang = localStorage.getItem('language') || 'zh-TW'const i18n = createI18n({ locale: lang, // set locale fallbackLocale: 'en-US', // set fallback locale messages})export default i18n 在 main.js 中引入套件Vue 3 和 Vue 2 的使用插件有些不一樣，在開始找資料的時候多找到 Vue2 的寫法，然後弄了很久才發現 Vue 2 和 Vue 3 寫法不一樣啊啊啊（Vue 小白的煩惱 QAQ）。 123456789//main.jsimport { createApp } from 'vue'import App from './App.vue'import i18n from './i18n'const app = createApp(App)app.use(i18n)app.mount('#app') 在 component 中使用 這部分參考 在 Vue-cli 中使用 i18n 實作多國語系 | Eason Lin 在設定好上面兩個檔案之後，就可以在任何 component 中使用這個套件。只要使用 $t 符號，就可以插入需要的文字，且只需要撰寫一次 template 就可以通過轉換語言 lang 變數來達到翻譯的效果。 1&lt;p&gt;{{ $t(&quot;pageTitleText&quot;) }}&lt;/p&gt; 設定了兩個按鈕來更換語言，點擊 tw 按鈕時會觸發 setLang function, 把變數 lang 的傳到 setActiveLanguage 這個 fucntion. 而 setActiveLanguage 則會更新 local storage language 中的值，從而達到更新語言的目的。 1234567891011121314151617181920212223242526// filename : HelloWorld.vue&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;div&gt;hellllo&lt;/div&gt; &lt;p&gt;{{ $t(&quot;pageTitleText&quot;) }}&lt;/p&gt; &lt;button data-lang=&quot;zh-TW&quot; @click=&quot;setLang&quot;&gt;tw&lt;/button&gt; &lt;button data-lang=&quot;en-US&quot; @click=&quot;setLang&quot;&gt;en&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: 'HelloWorld', methods: { setActiveLanguage(lang) { localStorage.setItem('language', lang) }, setLang(event) { const lang = event.target.dataset.lang this.setActiveLanguage(lang) return history.go(0) } }}&lt;/script&gt; 這是基本的使用方式，i18n 也接受不同的資料撰寫格式，在使用上提供了更大的彈性。 其他資料格式InterpolationsInterpolations : Named interpolation可以在資料裡使用花括號 {}, 插入到 component 內時，可以自己定義 msg 的值。 1234//json{ &quot;first&quot;: &quot;{msg} world&quot;,} 123//html&lt;p&gt;{{ $t(&quot;first&quot;, { msg: 'hello' }) }}&lt;/p&gt;//輸出 : hello world Interpolations : List interpolation花括號裡的數字是 array 的 index. 在 component 中傳入一個 array 就可以指定要輸出哪一個 item. 1234//json{ &quot;first&quot;: &quot;{1} world&quot;,} 123//html&lt;p&gt;{{ $t(&quot;first&quot;, ['hello', 'bye']) }}&lt;/p&gt;//輸出 : bye world Interpolations : Literal Interpolation設定好需要的區塊，在把資料傳進去。在花括號裡加上單引號就會被認為是字串。 1234//json{ &quot;email&quot;: &quot;{account}{'@'}{domain}&quot;,} 123//html&lt;p&gt;{{ $t(&quot;email&quot;, {account: 'hello', domain: 'mail.com'}) }}&lt;/p&gt;//輸出 : hello@mail.com Linked messages在資料裡串接資料，使用方式是加上 @ , 然後接上所需要的資料。 12345678//json{ &quot;msg&quot;:{ &quot;the_world&quot;: &quot;the world&quot;, &quot;dio&quot;: &quot;DIO&quot;, &quot;linked&quot;: &quot;@:msg.dio @:msg.the_world !!!&quot; } ,} 123//html&lt;p&gt;{{ $t(&quot;msg.linked&quot;) }}&lt;/p&gt;//輸出 : DIO the world !!! 小結因為實習的專案中遇到了多國語言轉換的問題，因此看了一些資料實作看看。當然專案中不只是這基礎的操作，還有一些較為複雜的部分，之後可能會再回來更新一些遇到的坑。 參考資料Vue I18n在 Vue-cli 中使用 i18n 實作多國語系(Vue2) medium","link":"/2021/08/29/0829-vue-i18n/"},{"title":"【實作記錄】Netflix Clone：首頁","text":"Live DemoGithub 簡介首頁由 5 個部分組成：Header 首頁大圖、Jumbotron 資訊塊、Accordion 常見問題、Otp form 訂閱表單、Footer 頁尾。每一塊都為單獨的component，組合起來後才渲染到瀏覽器。每一個 component 的創建邏輯相似：創建需要的元件 &gt; 創建組裝元件的 container，把需要的元件排進去 &gt; 添加樣式。 分開創建 component 除了便於維護外，最大的功能在於可以重複使用，就如 part 4 的 Opt form 在 part 5 的 header 中可以直接套用。 Part 1 : Jumbotron 資訊塊 + Global style 在首頁裡一共有 3 個 Jumbotron，其組成有：照片、標題、副標題。會先創需要的元件，再將他們放進 container 裡，最後進行樣式調整。 樣式部分不會全部都放在筆記裡，主要記下架構邏輯的部分。 創建基本檔案 components &gt; jumbotron &gt; index.js : 處理 Jumbotron components &gt; jumbotron &gt; styles &gt; jumbotron.js : 引入 styled ，在裡面處理 styled component Home.js : 首頁大圖會出現的地方 containers &gt; jumbotron.js index.js 中創立 jumbotron 需要的所有元件：container, title, subtitle, Image 和後來添加的 pane. index.js (Component > Jumbotron) >folded1234567891011121314151617181920212223242526272829303132import React from &quot;react&quot;import { Item, Inner, Container, Title, Subtitle } from &quot;./styles/Jumbotron&quot;function Jumbotron({ children, direction = &quot;row&quot;, ...restProps }){ return ( &lt;Item {...restProps}&gt; &lt;Inner direction={direction}&gt;{children}&lt;/Inner&gt; &lt;/Item&gt; )}Jumbotron.Container = function JumbotronContainer({ children, ...restProps }){ return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; }Jumbotron.Title = function JumbotronTitle({ children, ...restProps }){ return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt; }Jumbotron.SubTitle = function JumbotronSubTitle({ children, ...restProps }){ return &lt;Subtitle {...restProps}&gt;{children}&lt;/Subtitle&gt; }Jumbotron.Pane = function JumbotronPane({ children, ...restProps }){ return &lt;Pane {...restProps}&gt;{children}&lt;/Pane&gt; }Jumbotron.Image = function JumbotronSubTitle({ ...restProps }){ return &lt;Image {...restProps}/&gt;}export default Jumbotron 第 4 行 : 引入 Jumbotron.js 中設定的每個區塊 第 6 行 : 創建一個會傳入 children , direction (jumbo.json中有出現的) 以及剩餘的 props 參數的 function. 第 7 -12 行 : 這個 function 會返回一個 &lt; Item&gt;, 他的 children 是 &lt; Inner&gt;， &lt; Inner &gt; 的 children 可以是下面的 container/ title/ subtitle 第 14 行 : 創造新的變數，這個變數是一個 function，傳入的參數為 children 以及剩餘的 props. 後返回一個 &lt; Container &gt; element. 第 15 行 : &lt; Container &gt; element 傳入的參數說所有的 props, children 為 children 應該會是字串，顯示在熒幕上的字等等的 比如說 Home.js 中的 &lt; Jumbotron.Title &gt; 包的東西就是 &lt; Title &gt; 的children Home.js (Pages) >folded12345678910111213// filename : Home.js (Pages)import React from 'react'import Jumbotron from '../components/jumbotron'export default function Home() { return ( &lt;Jumbotron.Container&gt; &lt;Jumbotron.Title&gt;Hello&lt;/Jumbotron.Title&gt; &lt;Jumbotron.SubTitle&gt;Huala&lt;/Jumbotron.SubTitle&gt; &lt;/Jumbotron.Container&gt; )} 第 4 行 : 引入上面建立好的 Jumbotron 第 8 行 : 可以直接使用 index.js 中創造好的變數 把首頁需要的資訊渲染到畫面上 把在 Home.js 中的 container component 移到另一個檔案 : Jumbotron.js ( container &gt; Jumbotron.js），再引入 Home.js 中 jumbotron.js (Containers > jumbotron.js) >folded12345678910111213141516171819202122232425262728// filename : jumbotron.js (Containers &gt; jumbotron.js)import React from &quot;react&quot;import Jumbotron from &quot;../components/jumbotron&quot;import jumboData from &quot;../fixtures/jumbo.json&quot;function JumbotronContainer(){ return( &lt;Jumbotron.Container&gt; {jumboData.map((item) =&gt; ( // 會使用 index.js 中的 Jumbotron function 作為模板，title/subtitle這類的會變成children &lt;Jumbotron key={item.id} direction={item.direction}&gt; &lt;Jumbotron.Pane&gt; //style component 需要的，為標題和照片增加padding &lt;Jumbotron.Title &gt;{item.title}&lt;/Jumbotron.Title&gt; &lt;Jumbotron.SubTitle&gt;{item.subTitle}&lt;/Jumbotron.SubTitle&gt; &lt;/Jumbotron.Pane&gt; &lt;Jumbotron.Pane&gt; &lt;Jumbotron.Image src={item.image} alt={item.name}&gt;&lt;/Jumbotron.Image&gt; &lt;/Jumbotron.Pane&gt; &lt;/Jumbotron&gt; ))} &lt;/Jumbotron.Container&gt; )}export { JumbotronContainer } jumbo.json ( fixtures > jumbo.json ) >folded1234567891011// filename : jumbo.json ( fixtures &gt; jumbo.json )//裡面共有三筆資料，每筆資料長這樣 { &quot;id&quot;: 1, &quot;title&quot;: &quot;Enjoy on your TV.&quot;, &quot;subTitle&quot;: &quot;Watch on smart TVs, PlayStation, Xbox, Chromecast, Apple TV, Blu-ray players and more.&quot;, &quot;image&quot;: &quot;/images/misc/home-tv.png&quot;, &quot;alt&quot;: &quot;Tiger King on Netflix&quot;, &quot;direction&quot;: &quot;row&quot; //styled &gt; jumbotron.js 中會用到} 設計首頁每一個 Jumbotron 需要 title、Subtitle、Image Jumbotron.js (Component > Jumbotron > styles) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// filename : Jumbotron.js (Component &gt; Jumbotron &gt; styles)// 處理 styled component，順便設置不同裝置熒幕尺寸import styled from 'styled-components'export const Inner = styled.div` display: flex; align-items: center; justify-content: space-between; flex-direction: ${({ direction }) =&gt; direction}; //根據jumbo.json 裡的 direction 改變 max-width: 1100px; margin: auto; width: 100%; @media(max-width: 1000px) { flex-direction: column; }`//標題和圖片間增加 paddingexport const Pane = styled.div` width : 50%; @media (max-width: 1000px) { width:100%; padding: 0 45px; text-alighn: center; }`export const Item = styled.div` display: flex; border-bottom: 8px solid #222; padding: 50px 5%; color: white; overflow: hidden;`//手機裝置最後一個 jumbotron 會太靠近底部，增加bottomexport const Container = styled.section` background-color: black; @media (max-width: 1000px) { ${Item}:last-of-type h2 { margin-bottom: 50px; } text-align: center; }`export const Title = styled.h1` font-size: 50px; line-height: 1.1; margin-bottom: 8px; @media (max-width: 600px) { font-size: 35px; }`export const SubTitle = styled.h2` font-size: 26px; font-weight: normal; line-height: normal; @media (max-width: 600px) { font-size: 18px; }`export const Image = styled.img` max-width: 100%; height: auto;` 整理 Component Library &amp; Implementing Global Styles With Styled Components Component Library 之後會有很多 component 要加進來，如果每次都單獨 import 檔案進來看起來就會冗冗的 在 index.js (Component) 把路徑設成 {Jumbotron} 之後要引用這個路徑就可以直接寫 Jumbotron 更改 jumbotron.js (containers) 的路徑 index.js (Component) >folded1export { default as Jumbotron } from './jumbotron'; jumbotron.js (containers) >folded1234// filename : jumbotron.js (containers)//原本的 : import Jumbotron from &quot;../components/jumbotron&quot;import { Jumbotron } from &quot;../components&quot; Global Styles 使用 styled component 會難以估計每個元件預設的值是多少 可以創建一個新的 conponent 來儲存 global 的樣式 這個 component 要加在最根部，進行渲染的那一頁 (index.js) filename : global-style.js >folded123456789101112131415// filename : &quot;global-style.js&quot;import { createGlobalStyle } from 'styled-components';export const GlobalStyles = createGlobalStyle` html, body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; background-color: #000000; color: #333333; font-size: 16px; margin: 0; }`; index.js >folded12345678910111213141516171819//filename : index.jsimport React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import { BrowserRouter } from &quot;react-router-dom&quot;import { GlobalStyles } from &quot;./global-style&quot; import &quot;./index.css&quot;import App from &quot;./App&quot;ReactDOM.render( &lt;&gt; &lt;GlobalStyles/&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/&gt;, document.getElementById('root')); Part 2 : Footer 頁尾 Footer 一共有 4 欄，其排版會使用 gird 來進行。在縮小的時候會先變成 3 欄 ，再變為兩欄。 創建基本檔案 components &gt; footer &gt; index.js : footer 會在裡面處理 components &gt; footer &gt; styles &gt; footer.js : 引入 styled ，在裡面處理 styled component containers &gt; footer.js 在 index.js (components 的) 添加 export { default as Footer } from './footer'; , 會在 footer.js (containers) 中引入 Home.js 中增加 footer container 建立需要的元件index.js 中創立 footer 需要的所有元件：container, row, column, title, link 和 break. index.js (conponents > footer) >folded12345678910111213141516171819202122232425262728293031323334//filename : index.js (conponents &gt; footer)import React from &quot;react&quot;import { Container, Row, Column, Link, Title, Break, Text } from &quot;./styles/footer&quot;function Footer({ children, ...restProps }) { return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt;}Footer.Row = function FooterRow({ children, ...restProps }) { return &lt;Row {...restProps}&gt;{children}&lt;/Row&gt;}Footer.Column = function FooterColumn ({ children, ...restProps }) { return &lt;Column {...restProps}&gt;{children}&lt;/Column&gt;} Footer.Link = function FooterLink({ children, ...restProps }) { return &lt;Link {...restProps}&gt;{children}&lt;/Link&gt;}Footer.Title = function FooterTitle({ children, ...restProps }) { return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Footer.Text = function FooterText({ children, ...restProps }) { return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}Footer.Break = function FooterBreak ({ ...restProps }) { return &lt;Break {...restProps}/&gt;} export { FooterContainer } 第 4 行 : 引入 styled component 第 6 行 : 設置 Footer container, children 是下面的一大串 (row, column…) 第 10 行 : 設置 Row function ,會傳入 children 和其他 props, return &lt; Row &gt;，其他的同理 第 30 行 : 排版的時候會用到空行，所以這裡設置 break component，排版的時候就可以用 處理 footer links把每一個需要的鏈接都放在 container 裡. 因為使用 grid 所以需要 Column 和 Row. footer.js (containers > footer.js) >folded12345678910111213141516171819202122232425262728293031// filename : footer.js (containers &gt; footer.js)// 處理 footer links 的部分import React from &quot;react&quot;import { Footer } from &quot;../components&quot;//這裡在 index.js (components) 處理過了function FooterContainer() { return ( &lt;Footer&gt; &lt;Footer.Title&gt;Question?Contact us.&lt;/Footer.Title&gt; &lt;Footer.Break /&gt; &lt;Footer.Row&gt; &lt;Footer.Column&gt; &lt;Footer.Link href=&quot;#&quot;&gt;FAQs&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Investor Relations&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Ways to watch&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Corparate Informations&lt;/Footer.Link&gt; &lt;Footer.Link href=&quot;#&quot;&gt;Netflix Originals&lt;/Footer.Link&gt; &lt;/Footer.Column&gt; · · · &lt;/Footer.Column&gt; &lt;/Footer.Row&gt; &lt;Footer.Break/&gt; &lt;/Footer&gt; )}export default FooterContainer Part 3: Accordion 常見問題 常見問題的部分會使用手風琴式選單來製作（可以點開收起）。其中需要的元件有標題、問題、內容(回答)、點擊按鈕。 常見問題 (FAQ) 與 Jumbotron 製作的方式類似，都有幾筆類型相同、格式也相同的資料，因此渲染到畫面上的方法是一樣的。 創建基本檔案 components &gt; Accordion &gt; index.js : Accordion 會在裡面處理 components &gt; Accordion &gt; styles &gt; accordion .js : 引入 styled ，在裡面處理 styled component containers &gt; faq.js 在 index.js (components 的) 添加 export { default as Accordion } from './accordion'; , 會在 accordion .js (containers) 中引入 Home.js 中增加 Accordion container 建立需要的元件 + 把需要的資料渲染到瀏覽器上 （直到這裡的步驟都與 jumbotron 的相同） 建立 index.js (之後會詳細處理 state 的部分，這裡不放程式碼) ，創建基本的架構 建立 accordion.js (component &gt; accrodion &gt; styles)，確保index.js 中需要的元件都有在 accordion.js 中出現，避免報錯 FAQ 資料保存在 faqs.json (fixtures) 中，一共有4筆。資料形態如下： faqs.json >folded1234567// filename : faqs.json{ &quot;id&quot;: 1, &quot;header&quot;: &quot;What is Netflix?&quot;, &quot;body&quot;: &quot;Netflix is a streaming service that offers a wide variety of award-winning TV programmes, films, anime, documentaries and more – on thousands of internet-connected devices.\\n\\nYou can watch as much as you want, whenever you want, without a single advert – all for one low monthly price. There's always something new to discover, and new TV programmes and films are added every week!&quot;}, faqs.js (containers) >folded1234567891011121314151617181920212223// filename : faqs.js (containers)import React from &quot;react&quot;import { Accordion } from &quot;../components&quot;import faqsData from &quot;../fixtures/faqs.json&quot;function FaqsContainer(){ return( &lt;Accordion &gt; &lt;Accordion.Title&gt;Frequently Asked Questions&lt;/Accordion.Title&gt; &lt;Accordion.Frame&gt; //這是用來補充 margin 的 {faqsData.map((item) =&gt; ( &lt;Accordion.Item key={item.id}&gt; &lt;Accordion.Header&gt;{item.header}&lt;/Accordion.Header&gt; &lt;Accordion.Body&gt;{item.body}&lt;/Accordion.Body&gt; &lt;/Accordion.Item&gt; ))} &lt;/Accordion.Frame&gt; &lt;/Accordion&gt; )}export { FaqsContainer} Part 4 : Otp form 訂閱表單 + Router 處理 提供用戶訂閱的 Opt Form 會放在 FAQs 那一個部分裡，因此只需要創建 Opt Form 的 component，不需要將其 container 獨立出來。 另外文末也會進行 Router 處理。 創建基本檔案 components &gt; Opt-Form &gt; index.js : opt-form 會在裡面處理 components &gt; Opt-Form &gt; styles &gt; opt-form .js : 引入 styled ，在裡面處理 styled component 在 index.js (components 的) 添加 export { default as Accordion } from ‘./Opt-Form’; index.js (components > opt-form) >folded12345678910111213141516171819202122232425262728293031//filename : index.js (components &gt; opt-form )import React from 'react';import { Container, Input, Break , Button, Text } from './styles/opt-form';function OptForm({ children, ...restProps }) { return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt;}OptForm.Input = function OptFormInput({ ...restProps }) { return &lt;Input {...restProps} /&gt;}OptForm.Button = function OptFormButton({ children, ...restProps }) { return ( &lt;Button {...restProps}&gt; {children} &lt;i className=&quot;fas fa-chevron-right&quot;&gt; &lt;/i&gt; &lt;/Button&gt; )}OptForm.Break = function OptBreak({ ...restProps }) { return &lt;Break {...restProps} /&gt;;}OptForm.Text = function OptFormText({ children, ...restProps }) { return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}export default OptForm 處理 components (pages) 的 router 如果之後要更換路徑，只要更新一個地方就可以了，比較容易維護 創建好之後就可以更換 App.js 中的路徑 Routes.js (constants) >folded123456// filename :Routes.js (constants)export const HOME = '/'export const BROWSE = '/browse'export const SIGN_UP = '/signup'export const SIGN_IN = '/signin' App.js >folded1234567891011121314151617181920212223242526272829303132//filename : App.jsimport React from 'react'import { Switch, Route } from 'react-router-dom'import * as ROUTES from './constants/routes'; //引入import Home from &quot;./pages/Home&quot;function App() { return ( &lt;Switch&gt; &lt;Route path={ROUTES.SIGN_IN}&gt; //這樣使用 &lt;p&gt;Sign in page&lt;/p&gt; &lt;/Route&gt; &lt;Route path={ROUTES.SIGN_UP}&gt; &lt;p&gt;Sign up page&lt;/p&gt; &lt;/Route&gt; &lt;Route path={ROUTES.BROWSE}&gt; &lt;p&gt;browse page&lt;/p&gt; &lt;/Route&gt; &lt;Route path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; Part 5 : Header 首頁大圖 創建基本檔案 components &gt; header &gt; index.js : header 會在裡面處理 components &gt; header &gt; styles &gt; header .js : 引入 styled ，在裡面處理 styled component containers &gt; header.js 在 index.js (components 的) 添加 export { default as Header } from ‘./header’; , 會在 header .js (containers) 中引入 Home.js 中增加 header container 建構需要的元件頁首需要的元件：背景, Logo, Sign In button, opt form . Logo 和 Sign In button 點擊後會跳往指定的頁。Opt form 上一個部分已經做了，所以可以直接使用。 index.js (containers > header) >folded1234567&lt;p&gt;//filename : index.js (containers &amp;gt; header)&lt;/p&gt;&lt;p&gt;import React from “react”&lt;br&gt;import { Link as ReachRouterLink } from “react-router-dom”&lt;br&gt;import { Background, Container, Logo, ButtonLink } from “./styles/header”&lt;/p&gt;&lt;p&gt;function Header({ bg= true, children, …restProps }){&lt;br&gt; return bg ? &amp;lt;Background {…restProps}&amp;gt;{children}&lt;/Background&gt; : children&lt;br&gt;}&lt;/p&gt;&lt;p&gt;Header.Frame = function HeaderFrame({ children, …restProps }) {&lt;br&gt; return &amp;lt;Container {…restProps}&amp;gt;{children}&lt;/Container&gt;&lt;br&gt;}&lt;/p&gt;&lt;p&gt;Header.Logo = function HeaderLogo({ to, …restProps }){&lt;br&gt; return(&lt;br&gt; &lt;ReachRouterLink to={to}&gt;&lt;br&gt; &amp;lt;Logo {…restProps} /&amp;gt;&lt;br&gt; &lt;/ReachRouterLink&gt;&lt;br&gt; )&lt;br&gt;}&lt;/p&gt;&lt;p&gt;Header.ButtonLink = function HeaderButtonLink({ children, …restProps }){&lt;br&gt; return &amp;lt;ButtonLink {…restProps}&amp;gt;{children}&lt;/ButtonLink&gt;&lt;br&gt;}&lt;/p&gt;&lt;p&gt;export default Header&lt;/p&gt; 第 4 行 : logo &amp; signin button 需要使用 Link 第 7 行 : bg 為 true ，會顯示背景圖片 第 11 行 : Header.Frame 會返回 Container 第 15 行 : 使用 Link 把 Logo 包起來，讓他變成點擊後會跳轉的 第 23 行 : Header.ButtonLink 是 for sign in button 的 把需要的元件排進 container 裡header.js (components > header) >folded1234&lt;p&gt;//filename : header.js (components &amp;gt; header)&lt;/p&gt;&lt;p&gt;import React from “react”&lt;br&gt;import { Header } from “../components”&lt;br&gt;import * as ROUTES from “../constants/routes”;&lt;/p&gt;&lt;p&gt;function HeaderContainer({ children }){&lt;br&gt; return(&lt;br&gt; &lt;Header&gt;&lt;br&gt; &amp;lt;Header.Frame&amp;gt;&lt;br&gt; &amp;lt;Header.Logo&lt;br&gt; to={ROUTES.HOME}&lt;br&gt; src=”/images/misc/logo.png”&lt;br&gt; alt=”Netflix”&lt;br&gt; /&amp;gt;&lt;br&gt; &amp;lt;Header.ButtonLink to={ROUTES.SIGN_IN}&amp;gt;Sign In&amp;lt;/Header.ButtonLink&amp;gt;&lt;br&gt; &amp;lt;/Header.Frame&amp;gt;&lt;br&gt; {children}&lt;br&gt; &lt;/Header&gt;&lt;br&gt; )&lt;br&gt;}&lt;/p&gt;&lt;p&gt;export default HeaderContainer&lt;/p&gt; 第 5 行 : 引入 route.js，為 logo &amp; sign in button 加上 Link 第 11 行 : Header.Logo 是個 Link 所以需要 to 第 16 行 : 與第 11 行 同理 加入 Opt Form會有 title, subtitle, form. 為了方便，title, subtitle 會另外創一個 container 來裝。 跟上面的步驟一樣，在 containers 中創建 feature. feature 中創建 index.js 以及 styles, styles 中創建 feature.js. index.js (components > feature) >folded123456789101112131415161718//filename : index.js (components &gt; feature)import React from &quot;react&quot;import { Container, Title, SubTitle } from &quot;./styles/feature&quot;function Feature({ children, ...restProps }){ return &lt;Container {...restProps}&gt;{children}&lt;/Container&gt;}Feature.Title = function FeatureTitle({ children, ...restProps }){ return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Feature.SubTitle = function FeatureSubTitle({ children, ...restProps }){ return &lt;SubTitle {...restProps}&gt;{children}&lt;/SubTitle&gt;}export default Feature Home.js >folded1234567891011121314151617181920212223242526272829303132//filename : Home.jsimport React from 'react'import { Feature, OptForm } from &quot;../components&quot;import { FaqsContainer } from &quot;../containers/faqs&quot;import { JumbotronContainer } from &quot;../containers/jumbotron&quot;import { FooterContainer } from &quot;../containers/footer&quot;import { HeaderContainer } from &quot;../containers/header&quot;export default function Home() { return ( &lt;&gt; &lt;HeaderContainer&gt; &lt;Feature&gt; &lt;Feature.Title&gt;Unlimited films, TV programmes and more.&lt;/Feature.Title&gt; &lt;Feature.SubTitle&gt;Watch anywhere. Cancel at any time.&lt;/Feature.SubTitle&gt; &lt;OptForm&gt; &lt;OptForm.Input placeholder=&quot;Email Address&quot; /&gt; &lt;OptForm.Button&gt;Try it now&lt;/OptForm.Button&gt; &lt;OptForm.Break /&gt; &lt;OptForm.Text&gt;Ready to watch? Enter your email to create or restart your membership.&lt;/OptForm.Text&gt; &lt;/OptForm&gt; &lt;/Feature&gt; &lt;/HeaderContainer&gt; &lt;JumbotronContainer /&gt; &lt;FaqsContainer /&gt; &lt;FooterContainer /&gt; &lt;/&gt; )} 第 4 行 : 把 feature component 傳進來 第 14 行 : 把中間整塊視為 feature, 所以用 feature component 把整塊包起來 第 15,16 行 : 傳進 title 和 subtitle 第 17 行 : 把上一個 part 做好的 Opt Form 整個傳進來 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/05/0505-netflix-clone-2/"},{"title":"【實作記錄】Netflix Clone：用戶登入頁","text":"Live DemoGithub 簡介用戶登入包括了 sign in 和 sign up 兩個頁面。都使用了 firebase 的 auth 功能處理。Firebase 會幫忙驗證 email 和 password 的合法性。最後也會處理只有登入的用戶才能瀏覽 browser 頁的功能。真的是 hen 方便。 Part 1 : Sign in Page + Sign up Page Form 分為兩個部分：已經是用戶在 sign in page, 非用戶會導到 sign up page. Sign in Page components &gt; form &gt; index.js : 處理 Form components &gt; form &gt; styles &gt; form.js : 引入 styled ，在裡面處理 styled component Signin.js : 表單會出現的地方 在 App.js 中加入這個 component 首先創造 Form container，需要form, title, input, submit button, error message, sign up. index.js (components > form >index.js) >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React from &quot;react&quot;import { Container, Base, Title, Text, TextSmall, Error, Input, Submit, Link} from &quot;./styles/form&quot;function Form({ children, ...restProps }){ return( &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; )}//整個 formForm.Base = function FormBase({children, ...restProps}) { return &lt;Base {...restProps}&gt;{children}&lt;/Base&gt;}//標題Form.Title= function FormTitle({children, ...restProps}) { return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}//sign up guideForm.Text = function FormText({children, ...restProps}) { return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}//noteForm.TextSmall = function FormTextSmall({children, ...restProps}) { return &lt;TextSmall {...restProps}&gt;{children}&lt;/TextSmall&gt;}//gsign up linkForm.Link = function FormLink({children, ...restProps}) { return &lt;Link {...restProps}&gt;{children}&lt;/Link&gt;}Form.Error = function FormErrMessage({children, ...restProps}) { return &lt;Error {...restProps}&gt;{children}&lt;/Error&gt;}//email, passwordForm.Input = function FormInput({children, ...restProps}) { return &lt;Input {...restProps}&gt;{children}&lt;/Input&gt;}//Submit ButtonForm.Submit = function FormSubmit({children, ...restProps}) { return &lt;Submit {...restProps}&gt;{children}&lt;/Submit&gt;}export default Form 整理 pages 路徑index.js (pages) >folded12345// filename: index.js (pages)export { default as Home } from &quot;./Home&quot;export { default as Signin } from &quot;./Signin&quot; 在 Signin.js 中設置 form在 signin.js 中處理了以下功能: error 的出現依賴 state 來處理 點擊 submit button, email, password 的改變使用 state 處理 email/ password 其中一個沒有輸入 button 就會 disabled 加入 footer Signin.js >folded12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// filename : Signin.jsimport React, { useState } from 'react'import { Form } from '../components'import { HeaderContainer } from '../containers/header'import { FooterContainer } from '../containers/footer'function Signin() { const [ error, setError ] = useState(&quot;&quot;) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const isInvalid = password === '' | emailAddress === '' const handleSignin = (event) =&gt; { event.preventDefault() } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign In&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.Error&gt;{error}&lt;/Form.Error&gt;} //包著 email 和 password &lt;Form.Base onSubmit={handleSignin} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign In &lt;/Form.Submit&gt; &lt;Form.Text &gt; New to Netflix? &lt;Form.Link to=&quot;/signup&quot;&gt;Sign up now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signin 第 20 行 : 引入 header container，包著所有原件 第 26 行 : 需要接收 submit 的資料，method 為 POST 第 30, 38 行 : 更新 email value 第 13, 41 行 : 設定 button disabled 條件 第 46 行 : 添加 Link , 連接到 sign up page 第 56 行 : 添加 footer Sign up PageSign up page 的配置與 sign in 的差不多：FirstName, email, password, submit. 因為引用與 sign in 同一個 styled component，所以不需要再另外設置。 Signup.js (pages) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import React, { useState } from &quot;react&quot;import { HeaderContainer } from '../containers/header'import { Form } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;import { FooterContainer } from &quot;../containers/footer&quot;function Signup({ children, ...RestProps }){ const [ firstName, setFirstName ] = useState(&quot;&quot;) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const [ error, setError ] = useState(&quot;&quot;) const isInvalid = firstName === &quot;&quot; || emailAddress === &quot;&quot; || password === &quot;&quot; const handleSignup = (event) =&gt; { event.preventDefault() } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign Up&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.error&gt;{error}&lt;/Form.error&gt;} &lt;Form.Base onSubmit={handleSignup} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;First Name&quot; value={firstName} onChange = {({ target })=&gt; setFirstName(target.value)} /&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign Up &lt;/Form.Submit&gt; &lt;Form.Text&gt; Already a user? &lt;Form.Link to=&quot;/signin&quot;&gt;Sign in now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signup Part 2 : 用戶選擇 Profile select 創建基本檔案 pages &gt; browse.js 在 index.js (pages 的) 增加 export { default as Browse } from &quot;./Browse&quot; components &gt; profiles &gt; index.js components &gt; profilesr &gt; styles &gt; profiles .js containers &gt; brwoser.js containers &gt; SelectProfileContainer.js 在 App.js 中引入 browse.js App.js >folded123456789101112131415161718192021222324252627282930import React from 'react'import { Switch, Route } from 'react-router-dom'import * as ROUTES from './constants/routes';import { Home, Signin, Signup, Browse } from &quot;./pages&quot;function App() { return ( &lt;Switch&gt; &lt;Route path={ROUTES.SIGN_IN}&gt; &lt;Signin /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.SIGN_UP}&gt; &lt;Signup /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.BROWSE}&gt; &lt;Browse /&gt; &lt;/Route&gt; &lt;Route path={ROUTES.HOME}&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; );}export default App; browse.js 中需要引入的東西： header component (頁首) route.js (跳轉頁面) firebase context (film 資料) select profile container (進入 film 列表前的用戶選擇) footer container (頁腳) 用戶選擇登入成功後，在進入 film 列表前有選擇用戶的區塊 (select profile container) 。在 browse.js 中創造用戶 profile，為一個 object，內有 display name 和 photo url. 選擇用戶區塊是否顯示是根據 display name 是否存在，如果存在則顯示設定好的 browser 畫面，不存在則顯示選擇用戶頁面. Profile 使用 state 來更新其狀態。 browse.js (containers) >folded123456789101112131415161718192021222324252627import React, {useState} from &quot;react&quot;import { Header } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;import { FirebaseContext } from &quot;../context/firebase&quot;import { SelectProfileContainer } from &quot;./profiles&quot;import { FooterContainer } from &quot;./footer&quot;function BrowseContainer() { const [ profile, setProfile ] = useState({}) const user = { displayName: 'Karl', photoURL:&quot;1&quot; } return profile.displayName ? ( &lt;p&gt; &lt;p&gt;Browse Container&lt;/p&gt; &lt;FooterContainer/&gt; &lt;/p&gt;): ( &lt;SelectProfileContainer user={user} setProfile={ setProfile}/&gt; //參數要往下傳, selectProfileContainer 才能使用 user 等 )}export { BrowseContainer } 接著設置 Profiles.js (containers), select profile container 會在這裡處理。需要引入： header component (Logo, 撐開 logo 的 frame, 不要背景 ) ROUTES (Logo 跳轉頁面) profile component 在 profiles component (index.js)裡創造需要的元件：Title, User, List, Picture, Name. index.js (components > profiles ) >folded12345678910111213141516171819202122232425262728293031import React from &quot;react&quot;import { Container, Title, List, User, Name, Picture } from &quot;./styles/profiles&quot;function Profiles({ children, ...restProps }) { return( &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; )}Profiles.Title = function ProfilesTitle({ children, ...restProps }) { return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Profiles.List = function ProfilesList({ children, ...restProps }) { return &lt;List {...restProps}&gt;{children}&lt;/List&gt;}Profiles.User = function ProfilesUser({ children, ...restProps }) { return &lt;User {...restProps}&gt;{children}&lt;/User&gt;}Profiles.Name = function ProfilesName({ children, ...restProps }) { return &lt;Name {...restProps}&gt;{children}&lt;/Name&gt;}//注意照片傳進來的參數 : 沒有children，傳進 srcProfiles.Picture= function ProfilesPicture({src, ...restProps }) { return &lt;Picture {...restProps} src={src? 照片鏈接:照片鏈接}} //在瀏覽器還沒把照片load出來前顯示loading gifexport default Profiles 在 profles container (Profiles.js) 中排版，設置頁面需要的東西。Profiles.users 在點擊之後會更新 profile 的 state，用來跳轉畫面。 profiles.js (containers) >folded1234567891011121314151617181920212223242526272829303132333435import React from &quot;react&quot;import { Header, Profiles } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;function SelectProfileContainer({ user, setProfile }) { return( &lt;&gt; &lt;Header bg={false}&gt; &lt;Header.Frame&gt; &lt;Header.Logo src=&quot;/images/misc/logo.png&quot; to={ROUTES.HOME} alt=&quot;Netflix&quot;/&gt; &lt;/Header.Frame&gt; &lt;/Header&gt; &lt;Profiles&gt; &lt;Profiles.Title&gt;Who is Watching?&lt;/Profiles.Title&gt; &lt;Profiles.List&gt; &lt;Profiles.User onClick={() =&gt; setProfile({ displayName: user.displayName, photoURL: user.photoURL })} &gt; &lt;Profiles.Picture src={user.photoURL}/&gt; &lt;Profiles.Name&gt;{user.displayName}&lt;/Profiles.Name&gt; &lt;/Profiles.User&gt; &lt;/Profiles.List&gt; &lt;/Profiles&gt; &lt;/&gt; )}export { SelectProfileContainer } Part 3 : 連接 FireBase + 用戶 Auth 參考資料用 Firebase Authentication 做一套簡易會員系統 – 電子郵件 密碼 連接 Firebase + firestore 在 context file 裡創建 firebase.js firebase.js (context) >folded12import { createContext } from &quot;react&quot;export const FirebaseContext = createContext(null) 在 index.html 中加入以下程式碼 index.html >folded12&lt;script src=&quot;https://www.gstatic.com/firebasejs/8.4.3/firebase-app.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://www.gstatic.com/firebasejs/8.4.3/firebase-firestore.js&quot;&gt;&lt;/script&gt; 在 firebase 創建新的項目，跟著指示網下走 創建新的資料庫，點擊 firestore &gt; 創建資料庫 &gt;選擇生產者模式 選擇資料存放地區 回到專案頁面 &gt; 點擊”網頁” &gt; 添加名字 &gt; 點擊註冊應用 &gt; 跳出一個這個數據庫的資料 舊版本會有 database url，這個版本不需要 index.js 中加入 剛才創建的 firebase.js index.js (src) >folded1234567891011121314151617181920212223242526272829import React from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import { BrowserRouter } from &quot;react-router-dom&quot;import { GlobalStyles } from &quot;./global-style&quot; import { FirebaseContext } from &quot;./context/firebase&quot; import App from &quot;./App&quot;const Config = { apiKey: &quot;-----------------&quot;, authDomain: &quot;-----------------&quot;, projectId: &quot;-----------------&quot;, storageBucket: &quot;-----------------&quot;, messagingSenderId: &quot;-----------------&quot;, appId: &quot;-----------------&quot;}//firebase context 中以把 value 設為 {firebase: window.firebase}, 以 props 的方式傳進去ReactDOM.render( &lt;&gt; &lt;FirebaseContext.Provider value={}&gt; &lt;GlobalStyles/&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/FirebaseContext.Provider&gt; &lt;/&gt;, document.getElementById('root')); Firebase Authendication進入專案 &gt; 點擊 Authendication &gt; Sign in method (依照個人需求) &gt; email/password 打開 &gt; 在 html 中加入一段 auth 的程式碼 CustomPagination.js >folded1&lt;script src=&quot;https://www.gstatic.com/firebasejs/8.0.1/firebase-auth.js&quot;&gt;&lt;/script&gt; 為 Sign up Page 加上 Authentication在 index.js initializ firebaseindex.js >folded12//filename :index.js const firebase = window.firebase.initializeApp(config) 在 signup.js 處理 authenation讓用戶註冊賬號，如果註冊不成功便會出現錯誤信息，密碼少於6碼或是賬號已經被使用過等錯誤會被印出來。如果註冊成功會直接導到 profile select 那一頁，這個部分可以使用 useHistory 處理，不用重整畫面就可以做到跳轉頁面的效果。 這是一個 promise，所以使用 then() 以及 catch()來操作. Signup.js (pages) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import React, { useState, useContext } from &quot;react&quot;import { useHistory } from 'react-router-dom';import { HeaderContainer } from '../containers/header'import { FooterContainer } from &quot;../containers/footer&quot;import { FirebaseContext } from &quot;../context/firebase&quot;import { Form } from &quot;../components&quot;import * as ROUTES from &quot;../constants/routes&quot;function Signup({ children, ...RestProps }){ const history = useHistory() const { firebase } = useContext(FirebaseContext) const [ firstName, setFirstName ] = useState(&quot;&quot;) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const [ error, setError ] = useState(&quot;&quot;) const isInvalid = firstName === &quot;&quot; || emailAddress === &quot;&quot; || password === &quot;&quot; const handleSignup = (event) =&gt; { event.preventDefault() firebase .auth() .createUserWithEmailAndPassword(emailAddress, password) .then((result) =&gt; result.user .updateProfile({ displayName: firstName, photoURL: Math.floor(Math.random() * 4 ) + 1 }) .then(() =&gt; { setEmailAddress(&quot;&quot;) setPassword(&quot;&quot;) setError(&quot;&quot;) history.push(ROUTES.BROWSE) }) ).catch((error) =&gt; setError(error.message)) } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign Up&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.Error&gt;{error}&lt;/Form.Error&gt;} &lt;Form.Base onSubmit={handleSignup} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;First Name&quot; value={firstName} onChange = {({ target })=&gt; setFirstName(target.value)} /&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign Up &lt;/Form.Submit&gt; &lt;Form.Text&gt; Already a user? &lt;Form.Link to=&quot;/signin&quot;&gt;Sign in now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signup 由於需要用到 firebase context 來操作 firebase 第 6 行 : 引入 { firebaseContext } 第 12 行 : 使用 useContext 調用 第 24 行 : 使用 firebase 的 method, 本身為一個 promise 處理點擊 sign up 後的動作 第 25, 26 行 : 使用 firebase 的 method 第 27 行 : 成功註冊後更新 profile 第 31 行 : photoURL 使用隨機號碼當做 url (image文件夾裡有 4 張照片，檔名為1, 2, 3, 4) 第 33 行 : 成功註冊後清除輸入欄 第 37 行 : 使用 useHistory 把網頁導到 browser 那頁 第 39 行 : 註冊失敗會出現錯誤信息 為 Sign in Page 加上 AuthenticationSign in page 的操作步驟與 sign up 的差不多，差別只在點擊 sign in button 後的處理。 Signup.js (pages) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, { useState, useContext } from 'react'import { useHistory } from &quot;react-router-dom&quot;import { Form } from '../components'import { HeaderContainer } from '../containers/header'import { FooterContainer } from '../containers/footer'import { FirebaseContext } from &quot;../context/firebase&quot;import * as ROUTES from &quot;../constants/routes&quot;function Signin() { const history = useHistory() const { firebase } = useContext(FirebaseContext) const [ emailAddress, setEmailAddress ] = useState(&quot;&quot;) const [ password, setPassword ] = useState(&quot;&quot;) const [ error, setError ] = useState(&quot;&quot;) const isInvalid = password === '' | emailAddress === '' const handleSignin = (event) =&gt; { event.preventDefault() firebase .auth() .signInWithEmailAndPassword ( emailAddress, password ) .then( setEmailAddress(&quot;&quot;), setPassword(&quot;&quot;), setError(&quot;&quot;), history.push(ROUTES.BROWSE) ) } return( &lt;&gt; &lt;HeaderContainer&gt; &lt;Form&gt; &lt;Form.Title&gt;Sign In&lt;/Form.Title&gt; {error &amp;&amp; &lt;Form.Error&gt;{error}&lt;/Form.Error&gt;} &lt;Form.Base onSubmit={handleSignin} method=&quot;POST&quot;&gt; &lt;Form.Input placeholder=&quot;Email Address&quot; value={emailAddress} onChange={({ target }) =&gt; setEmailAddress(target.value)} /&gt; &lt;Form.Input type=&quot;password&quot; placeholder=&quot;Password&quot; value={password} autocomplete=&quot;off&quot; onChange={({ target }) =&gt; setPassword(target.value)} /&gt; &lt;Form.Submit disabled={isInvalid}type=&quot;submit&quot;&gt; Sign In &lt;/Form.Submit&gt; &lt;Form.Text &gt; New to Netflix? &lt;Form.Link to=&quot;/signup&quot;&gt;Sign up now.&lt;/Form.Link&gt; &lt;/Form.Text&gt; &lt;Form.TextSmall&gt; This page is protected by Google reCAPTCHA. &lt;/Form.TextSmall&gt; &lt;/Form.Base&gt; &lt;/Form&gt; &lt;/HeaderContainer&gt; &lt;FooterContainer/&gt; &lt;/&gt; )}export default Signin 寫入資料在寫入資料前，要先把 rules 改成 true，但這個設定會讓所有人都有權限把資料寫進去。 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/07/0507-netflix-clone-3/"},{"title":"【實作記錄】Netflix Clone：Browser頁","text":"Live DemoGithub 簡介Browser 頁處理的東西比較多：用戶 Profile 選擇、首頁大圖、每列分類以及卡片、卡片詳細資訊、播放器、搜尋功能、sign out 功能。series 以及 films 的資料都存在 firestore 裡，之後有餘力會再多增加幾筆資料做換頁效果。 Part 1: 頁頭功能 Browser header Brower header 分為三個部分處理 ： 右側功能、左側功能、以及首頁大圖。 Browser 右側功能browser 右側 有 Logo, Catagory link, Series Link ，以及一個 container: Group. 可以使用之前創造好的 header component，但缺少的元件要回去 header (index.js) 裡補上。 browse.js (containers) >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, { useState, useContext } from &quot;react&quot;import { Header } from &quot;../components&quot;import { FirebaseContext } from &quot;../context/firebase&quot;import { FooterContainer } from &quot;./footer&quot;import { SelectProfileContainer } from &quot;./profiles&quot;import * as ROUTES from &quot;../constants/routes&quot;function BrowseContainer(){ const [ profile, setProfile ] = useState({}) const [ category, setCategory ] = useState(&quot;series&quot;) const [ loading, setLoading ] = useState(true) const { firebase } = useContext(FirebaseContext) const user = { displayName: 'Karl', photoURL:&quot;1&quot; } return profile.displayName ? ( &lt;&gt; &lt;Header src=&quot;joker1&quot; dontShowOnSmallViewPort&gt; &lt;Header.Frame&gt; &lt;Header.Group&gt; &lt;Header.Logo to={ROUTES.HOME} src=&quot;images/misc/logo.png&quot; alt=&quot;Netflix&quot;/&gt; &lt;Header.Link active ={category === &quot;series&quot;? &quot;true&quot;:&quot;false&quot;} onClick={() =&gt; setCategory(&quot;series&quot;)} &gt; Series &lt;/Header.Link&gt; &lt;Header.Link active ={category === &quot;films&quot;? &quot;true&quot;:&quot;false&quot;} onClick={() =&gt; setCategory(&quot;films&quot;)} &gt; Film &lt;/Header.Link&gt; &lt;/Header.Group&gt; &lt;/Header.Frame&gt; &lt;/Header&gt; &lt;FooterContainer/&gt; &lt;/&gt; ) : (&lt;SelectProfileContainer user={user} setProfile={ setProfile }/&gt;) }export { BrowseContainer } 第 21 行 : 如果有 display name，就進入 browser ，無則顯示用戶選擇頁第 23 行 : 引入 Header, 傳入首頁大圖，設定小熒幕不呈現 第 25 行 : container 的概念，用來調整樣式第 31, 38 行 : 設定 link, 使用 state 來改變 active的狀態，active 用來調整樣式 index.js (components > header) >folded1234567 Header.Link = function HeaderLink({ children, ...restProps }){ return &lt;Link {...restProps}&gt;{children}&lt;/Link&gt;}Header.Group = function HeaderGroup({ children, ...restProps }) { return &lt;Group {...restProps}&gt;{children}&lt;/Group&gt;} header.js (components > header > styles) >folded1234567891011121314151617181920export const Link = styled.p` color: #fff; text-decoration: none; margin-right: 30px; font-weight: ${({ active }) =&gt; (active === 'true' ? '700' : 'normal')}; cursor: pointer; &amp;:hover { font-weight: bold; } &amp;:last-of-type { margin-right: 0; }`export const Group = styled.div` display: flex; align-items: center;` Browser 首頁大圖Browser 首頁大圖除了電影海報、會加上介紹，Play Button，info button.其中 Play Button 在點擊後會連到電影預告 (Youtube). Header 會再加上 Feature, FeatureCallOut, Text, Span, Play Button, Info Button, 因此 index.js (header) 要增加這幾個元件。 browse.js (containers) >folded12345678910&lt;Header.Feature&gt; //container的概念&lt;Header.FeatureCallOut&gt;Extraction&lt;/Header.FeatureCallOut&gt; &lt;Header.Text&gt; A black-market mercenary who has nothing to lose is hired to rescue the kidnapped son of an imprisoned international crime lord. But in the murky underworld of weapons dealers and drug traffickers, an already deadly mission approaches the impossible. &lt;/Header.Text&gt;&lt;Header.Span&gt; &lt;Header.PlayButton&gt;&lt;/i&gt;more info&lt;/Header.InfoButton&gt;&lt;/Header.Span&gt;&lt;/Header.Feature&gt; index.js (components > header) >folded1234567891011121314151617181920212223Header.Text = function HeaderText({ children, ...restProps }){ return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}Header.Feature = function HeaderFeature({ children, ...restProps }){ return &lt;Feature {...restProps}&gt;{children}&lt;/Feature&gt;}Header.FeatureCallOut = function HeaderFeatureCallOut({ children, ...restProps }){ return &lt;FeatureCallOut {...restProps}&gt;{children}&lt;/FeatureCallOut&gt;}Header.InfoButton = function HeaderInfoButton({ children, ...restProps }){ return &lt;InfoButton {...restProps}&gt;{children}&lt;/InfoButton&gt;}Header.PlayButton = function HeaderPlayButton({ children, ...restProps }){ return &lt;PlayButton {...restProps}&gt;{children}&lt;/PlayButton&gt;}Header.Span = function HeaderSpan({ children, ...restProps }){ return &lt;Span {...restProps}&gt;{children}&lt;/Span&gt;} Browser 左側功能 : search bar點擊 search icon 搜索框就會跳出來，在小於700px的熒幕不提供搜尋功能。跳出來的功能是靠改變 state 來完成的，點擊按鈕 active 變成 true，在sytled component 裡有 active 與不 active 相應的樣式。 browse.js (containers) >folded123&lt;Header.Group&gt; &lt;Header.Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt;&lt;/Header.Group&gt; index.js (components > header) >folded1234567891011121314151617181920//filename:index.js (components &gt; header)Header.Search = function HeaderSearch({ searchTerm, setSearchTerm, ...restProps }){ const [ searchActive, setSearchActive ] = useState(false) return( &lt;Search {...restProps}&gt; &lt;SearchIcon onClick={() =&gt; setSearchActive(!searchActive)}&gt; &lt;i className=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/SearchIcon&gt; &lt;SearchInput value={searchTerm} onChange={({ target }) =&gt; setSearchTerm(target.value)} placeholder=&quot;Search files and series&quot; active={searchActive} /&gt; &lt;/Search&gt; ) } header.js (conponents > header) >folded1234567891011121314// active 時候 input 的設法export const SearchInput = styled.input` background-color: rgba(105, 105, 105, 0.3); color: #000; border: 1px solid #fff; transition: width 0.5s; height: 30px; font-size: 14px; margin-left: ${({ active }) =&gt; (active === true ? '10px' : '0')}; padding: ${({ active }) =&gt; (active === true ? '0 10px' : '0')}; opacity: ${({ active }) =&gt; (active === true ? '1' : '0')}; width: ${({ active }) =&gt; (active === true ? '200px' : '0px')};` Browser 左側功能 : 下拉式選單 + 其他 iconDropdown 選單：Profile，Account, Help center, Sign Out. 並排的 KIDs icon, gift icon, bell icon 暫時沒有功能。Dropdown 功能是 hover 的時候就會出現，因此是在 styled component 中處理，沒有特別使用 state 來做。 browse.js >folded1234567891011121314151617181920212223242526272829303132&lt;Header.Group&gt; &lt;Header.Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt; //其他icon &lt;Header.Span&gt; &lt;Header.Text&gt;KIDS&lt;/Header.Text&gt; &lt;i className=&quot;fas fa-gift&quot; &gt;&lt;/i&gt; &lt;i className=&quot;fas fa-bell&quot; &gt;&lt;/i&gt; &lt;/Header.Span&gt;// 點擊頭像 &lt;Header.Profile&gt; &lt;Header.Picture src={user.photoURL} /&gt;// 下拉式選單 &lt;Header.Dropdown&gt; &lt;Header.Group&gt; &lt;Header.Picture src={user.photoURL}/&gt; &lt;Header.Text&gt;{user.displayName}&lt;/Header.Text&gt; &lt;/Header.Group&gt; &lt;Header.Group&gt;//選單 &lt;Header.Span&gt; &lt;Header.Link &gt;Account&lt;/Header.Link&gt; &lt;Header.Link &gt;Help Center&lt;/Header.Link&gt; &lt;Header.Link onClick={() =&gt; firebase.auth().signOut()}&gt;Sign Out&lt;/Header.Link&gt; &lt;/Header.Span&gt; &lt;/Header.Group&gt; &lt;/Header.Dropdown&gt; &lt;/Header.Profile&gt;&lt;/Header.Group&gt; index.js (components > header) >folded1234567891011Header.Profile = function HeaderProfile({ children, ...restProps }){ return &lt;Profile {...restProps}&gt;{children}&lt;/Profile&gt;}Header.Dropdown = function HeaderDropdown({ children, ...restProps }){ return &lt;Dropdown {...restProps}&gt;{children}&lt;/Dropdown&gt;}Header.Picture = function HeaderPicture({ src, ...restProps }){ return &lt;Picture {...restProps} src={`照片位置`}/&gt;} Part 2: 資料處理 提取 firebase 裡的資料使用下面的方法提取 collection 裡的資料。創造一個 state 來儲存需要的資料；只需要在 firebase 改變的時候獲取一次資料，所以使用 useEffect. 最後可以印出獲取的資料驗證是否有取得需要的資料。 use-content (hooks) >folded12345678910111213141516171819202122232425262728293031import { useContext, useEffect, useState } from &quot;react&quot;import { FirebaseContext } from &quot;../context/firebase&quot;function useContent(target) { const { firebase } = useContext(FirebaseContext) const [ content, setContent ] = useState([])//提取 collection 資料的方式 useEffect(() =&gt; { firebase .firestore() .collection(target) .get() .then((snapshot) =&gt; { const allContent = snapshot.docs.map((contentObj) =&gt; ({ ...contentObj.data(), docID : contentObj.id })) setContent(allContent) }) .catch((error) =&gt; { console.error(error) }) }, []) return { [target] : content }}export default useContent 這裡在 Browse.js 中嘗試印出。 Browse.js (pages) >folded123456789101112131415import React from &quot;react&quot;import { BrowseContainer } from &quot;../containers/browse&quot;import { useContent } from &quot;../hooks&quot;function Browse() { const { series } = useContent('series') const { film } = useContent('film') console.log(series) console.log(film) return &lt;BrowseContainer/&gt;}export default Browse Part 3: 電影、電視列表 film and series list 電影列表會模仿 netflix 的樣式. 暫時會分為 series 和 films 兩頁，用戶可以自由切換頁面。每頁會有 4-5 個清單，每個清單的卡片都可以打開查看資訊，會出現照片、關閉 button, play button, add to my list button. 卡片的資料來源是前一個 part 獲得的 slide 資料。 slide 資料的組成： Slide 的元件 (畫面中有好幾條不同類別的 list )用戶可以切換頁面使用 useState 和 useEffect 來控制，在 category 改變的時候就調用該 category 的資料，點擊 film, state 會更新，提取的資料就更換成 film. 調出每一筆資料則是使用 .map() 遍歷 slide 資料。先遍歷被選中的 categroty 底下的資料, 提取每一個類別的分類 (title), 再遍歷每一筆資料 (data), 調出每一個分類下的影片資訊。 brwose.js (containers) >folded12345678910111213141516171819&lt;Card.Group&gt; {slideRows.map((slideItem) =&gt; ( &lt;Card key={`${category}-${slideItem.title.toLowerCase()}`}&gt; &lt;Card.Title&gt;{slideItem.title}&lt;/Card.Title&gt; &lt;Card.Entities&gt; {slideItem.data.map((item) =&gt; (//src 要加上`` &lt;Card.Item key={item.docid} item={item}&gt; &lt;Card.Img src={/images/${category}/${item.genre}/${item.slug}/small.jpg} /&gt; &lt;Card.Meta&gt; &lt;Card.Subtitle&gt;{item.title}&lt;/Card.Subtitle&gt; &lt;Card.Text&gt;{item.description}&lt;/Card.Text&gt; &lt;/Card.Meta&gt; &lt;/Card.Item&gt; ))} &lt;/Card.Entities&gt; &lt;/Card&gt; ))}&lt;/Card.Group&gt; 建立 card component每張卡片點進去會跳出詳細資訊的區塊稱為 “Feature”. Card component 裡會創造 context 以及 state. 每張 card 是一個 item，這設置兩組 state：一組為點擊 card 就更新 state 為被點擊 card 的資料；另一組為點擊 card 後更新 state 為 true，讓卡片彈跳出來。由於有超過一個地方需要這兩個 state 因此使用 context 包起來。 index.js (components > card) >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import React, { useState, useContext, createContext } from &quot;react&quot;import { Container, Group, Title, Item, Entities, Image, Meta, Subtitle, Text, Feature, FeatureTitle, FeatureClose, Maturity, Content,} from &quot;./styles/card&quot;const FeatureContext = createContext()function Card({ children, ...restProps }) { const [showFeature, setShowFeature] = useState(false) const [itemFeature, setitemFeature] = useState(false)//value 的大括號中要再放進大括號 return( &lt;FeatureContext.Provider value={}&gt; &lt;Container {...restProps }&gt;{children}&lt;/Container&gt; &lt;/FeatureContext.Provider&gt; )}Card.Group = function CardGroup({children, ...restProps}){ return &lt;Group {...restProps}&gt;{children}&lt;/Group&gt;}Card.Title = function CardTitle({children, ...restProps}){ return &lt;Title {...restProps}&gt;{children}&lt;/Title&gt;}Card.Subtitle = function CardSubtitle({children, ...restProps}){ return &lt;Subtitle {...restProps}&gt;{children}&lt;/Subtitle&gt;}Card.Text = function CardText({children, ...restProps}){ return &lt;Text {...restProps}&gt;{children}&lt;/Text&gt;}Card.Entities = function CardEntities({children, ...restProps}){ return &lt;Entities {...restProps}&gt;{children}&lt;/Entities&gt;}Card.Meta = function CardMeta({children, ...restProps}){ return &lt;Meta {...restProps}&gt;{children}&lt;/Meta&gt;}Card.Item = function CardItem({item, children, ...restProps}){ const { setitemFeature, setshowFeature } = useContext(FeatureContext) return ( &lt;Item onClick={() =&gt; { setitemFeature(item) //itemFeature 就是整個 item setshowFeature(true) }} {...restProps}&gt;{children}&lt;/Item&gt; )}Card.Image = function CardEntities({...restProps}){ return &lt;Image {...restProps}/&gt;}Card.Feature = function CardFeature({children, category ,...restProps}){ const { showFeature, setShowFeature, itemFeature } = useContext(FeatureContext) return showFeature ? ( &lt;Feature src={`images/${category}/${itemFeature.genre}/${itemFeature.slug}/large.jpg}`}&gt; &lt;Content&gt; &lt;Feature.Title&gt;{itemFeature.title}&lt;/Feature.Title&gt; &lt;Feature.Text&gt;{itemFeature.description}&lt;/Feature.Text&gt; &lt;Feature.Close onClick={()=&gt;setShowFeature(false)} &gt; &lt;i className=&quot;fas fa-times&quot;&gt;&lt;/i&gt; &lt;/Feature.Close&gt; &lt;Group margin=&quot;30px 0&quot; flexDirection=&quot;row&quot; alignItems=&quot;center&quot;&gt; &lt;Maturity rating={itemFeature.maturity}&gt;{itemFeature.Maturity &lt; &quot;12&quot; ? &quot;PG&quot;: itemFeature.Maturity}&lt;/Maturity&gt; &lt;Feature.Text fontWeight=&quot;bold&quot;&gt;{itemFeature.genre.charAt(0).toUpperCase() + itemFeature.genre.slice(1)}&lt;/Feature.Text&gt; &lt;/Group&gt; &lt;/Content&gt; {children} &lt;/Feature&gt; ) : null}export default Card 第 22 行 : 創造 context 第 25 行 : 創造 state ( feature 是否出現 ) 第 26 行 : 創造 state ( feature 的內容為被點擊的卡片的內容 ) 第 29 行 : 用 provider 包起來，之後就可以 consume 第 59 行 : 會傳進 item, item 是 browse.js 中的item 第 60 行 : 用 useContext 傳進需要的參數 第 65 行 : 點擊後，把 itemFeature 改成被點擊的卡片的內容 第 66 行 : 點擊後，把 showFeature 改成 true, 顯示 feature 框框 第 76 行 : Card.Feature 整組是點擊 card 後跳出來的 feature 框框 第 79 行 : 如果 showFeature 為 true 才顯示 feature 框框 第 80 行 : 背景會壓一張照片 第 84 行 : 點擊後，把 showFeature 改成 false, feature 框框收起來 第 90 行 : 在 style 的時候可以根據參數進行處理 第 91 行 : 如果資料的 maturity 小於 12 就顯示 PG, 若非則顯示 資料上的數字 第 92 行 : genre 首字母為大字母 Part 4 : 搜尋 Live Search參考資料Fuse.jssearch box 提供用戶搜尋的功能。這個功能使用 Fuse.js 這個套件完成。 CustomPagination.js1npm install --save fuse.js 搜尋功能會在 browse.js 中完成, 之前已經在 search component 中加入 search 的 state. 使用 useeffect ，在這個 state 改變的時候就會執行設定好的程式碼。 browse.js >folded12const [searchTerm, setSearchTerm] = useState('')&lt;Header.Search searchTerm={searchTerm} setSearchTerm={setSearchTerm} /&gt; browse.js >folded12345678910useEffect(() =&gt; { const fuse = new Fuse(slideRows, { keys: ['data.description', 'data.title', 'data.genre'] }); const results = fuse.search(searchTerm).map(({ item }) =&gt; item); if (slideRows.length &gt; 0 &amp;&amp; searchTerm.length &gt; 3 &amp;&amp; results.length &gt; 0) { setSlideRows(results); } else { setSlideRows(slides[category]); } }, [searchTerm]) 第 4 行 : 設定搜尋條件 第 5 行 : fuse 搜尋功能的寫法 第 7 行 : 設定結果條件 Part 5: 播放器 Player 播放器按鈕會出現在 feature 框框出現，點擊後就會彈出播放器。但資料庫沒有每個卡片的影片，因此這裡僅是示範。最後版本會移除此功能。 播放器按鈕一樣是依賴 state 來操作。這個 state 會在多過一處使用，因此可以使用 useContext 包起來。Video 直接透過 reactDOM 渲染到瀏覽器，不經過 browse container/ 其他 container 渲染。 index.js >folded123456789101112131415161718192021222324252627282930313233343536373839404142import React, { useState, useContext, createContext} from &quot;react&quot;import ReactDOM from &quot;react-dom&quot;import { Container, Overlay, Inner, Button } from &quot;./styles/player&quot;export const PlayerContext = createContext()function Player({ children, ...restProps }) { const [showPlayer, setShowPlayer] = useState(false)//value = {showPlayer, setShowPlayer} return( &lt;PlayerContext.Provider value={}&gt; &lt;Container {...restProps}&gt;{children}&lt;/Container&gt; &lt;/PlayerContext.Provider&gt; )}Player.Video = function PlayerVideo({ ...restProps }) { const { showPlayer, setShowPlayer } = useContext(PlayerContext); return showPlayer ? ReactDOM.createPortal( &lt;Overlay onClick={() =&gt; setShowPlayer(false)}&gt; &lt;Inner&gt; &lt;video id=&quot;netflix-player&quot; controls&gt; &lt;source src=&quot;/videos/bunny.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;/video&gt; &lt;/Inner&gt; &lt;/Overlay&gt;, document.body ) : null;}Player.Button = function PlayerButton({ ...restProps }) { const { showPlayer, setShowPlayer } = useContext(PlayerContext); return &lt;Button onClick={() =&gt; setShowPlayer(!showPlayer)}&gt;Play&lt;/Button&gt;;}export default Player 第 13 行 : 使用 Provider 包起來第 20 行 : consume provieder第 23 行 : 使用 createPortal browse.js (containers) >folded1234567&lt;Card.Feature category={category}&gt; &lt;Player&gt; &lt;Player.Button /&gt; &lt;Player.Video /&gt; &lt;/Player&gt;&lt;/Card.Feature&gt; 導覽頁Netflix Clone : 主頁Netflix Clone : 首頁Netflix Clone : 用戶登入頁Netflix Clone : Browser 頁Netflix Clone : 最後整理","link":"/2021/05/09/0509-netflix-clone-4/"},{"title":"Leetcode 解題記錄 ( 持續更新中 )","text":"將在 Leetcode 上解過的題目寫在這裡做記錄用，語言是使用 python. Array 26. Remove Duplicates from Sorted Array 53. Maximum Subarray 66. Plus One 88. Merge Sorted Array 217. Contains Duplicate 219. Contains Duplicate II 118. Pascal’s Triangle 26. Remove Duplicates from Sorted Array在一個已經排序好的 array 中，移除重複的元素。 Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Input: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4] Explanation: Your function should return length = 5, with the first fiveelements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’tmatter what values are set beyond the returned length. 想法 創造新的 array 把沒有出現過的 element，存到新的 array，再回傳新 array 的長度。但因為題目規定只能操作原本的 array，所以這個方法不可行。 是使用 while，檢查第一個與上一個是否相同，相同就移除。最後回傳 array 的長度。 使用 pointer 兩兩比較，最後返回 pointer 的 index. 程式碼 While 遍歷Runtime: 100 ms(faster than 26.82%) / Memory Usage: 15.8 MB (less than 93.99%) 在 i 小於 array 的長度時，如果 i 的值與 i的前一個值相等，就 pop 掉 i，否則 i 加一，繼續往下比較。遍歷結束後，重複的元素就已經被移除，直接返回 array 的長度就可以了。 12345678910111213# whiledef removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 i = 1 while (i &lt; len(nums)): if nums[i] == nums[i-1]: nums.pop(i) else: i += 1 return len(nums) Two pointerrun time (76 ms) / memory (15.9MB) 這題的想法是，不停把不重複的元素往前排列，最後看 pointer 停在哪一個index 上即表示當下 index 開始就是重複的元素。index 從 0 開始，因此要加上 1， 才會是 array 的長度。 12345678910111213# two pointerdef removeDuplicates(self, nums: List[int]) -&gt; int: if len(nums) == 0: return 0 x = 0 for i in range(0, len(nums)): if nums[x] != nums[i]: x += 1 nums[x] = nums[i] return x + 1 53. Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Input: nums = [-2,1,-3,4,-1,2,1,-5,4]Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. 想法 使用迴圈一個一個相加，看哪一個數值最大，具體操作可以看下面的程式碼。但這個方法運算的時間太長，會超出限定的時間，來一個超大測值就掰掰。 使用 kadane’s algorithm 是比較好的方式。滴滴面试手撕算法题-kadane算法 程式碼123456789101112# Time limit exceeded 的暴力法def maxSubArray(self, nums: List[int]) -&gt; int: max_num = nums[0] for i in range(len(nums)): for j in range(i + 1, len(nums)+1): sub = nums[i:j] total = sum(sub) if total &gt; max_num: max_num = total return max_num kadane’s algorithmruntime : 64 ms, faster than 72.73%memory: 14.9 MB, less than 53.55% 1234567891011# kadane's algorithmdef maxSubArray(nums): ans = nums[0] #global sum sum = 0 #local sum for i in range(len(nums)): sum = max(nums[i] + sum, nums[i]) ans = max(sum, ans) return ans 66. Plus OneGiven a non-empty array of decimal digits representing a non-negative integer, increment one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Input: digits = [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123. Constraints: 1 &lt;= digits.length &lt;= 100 0 &lt;= digits[i] &lt;= 9 想法 將 list 內的 int 轉為 string &gt; 將個別 string 抽取然後 join 起來 &gt; 將 join 起來的string 轉成 int ，再加 1 &gt; 轉回 string &gt; 轉回 list 把最後一個數字加 1 ，會出現三種狀況 不需要進位 ([1,2,4]) 需要進一位 ([1,2,9]) 99 這類會變成 100 的 程式碼 想法 1runtime : 32 ms, faster than 63.10%memory : 14.3 MB, less than 11.54% 1234567# 想法 1def plusOne(self, digits: List[int]) -&gt; List[int]: arr = [str(i) for i in digits] nums = str(int(&quot;&quot;.join(arr)) + 1) return list(nums) 想法 2Runtime: 36 ms, faster than 23.87%Memory Usage: 14.2 MB, less than 73.03% 123# 想法 2 : mapdef plusOne(self, digits: List[int]) -&gt; List[int]: return list(str(int(&quot;&quot;.join(map(str, digits)))+1)) 想法 3Simpler Python solution, faster than 100%Runtime: 32 ms, faster than 63.10%Memory Usage: 14.4 MB, less than 11.54% 12345678def plusOne(self, digits: List[int]) -&gt; List[int]: for i in range(len(digits) - 1, -1, -1): if digits[i] + 1 &lt;= 9 : digits[i] += 1 return digits else: digits[i] = 0 return [1] + [0] * len(digits) 88. Merge Sorted ArrayGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has a size equal to m + n such that it has enough space to hold additional elements from nums2. 想法 把 nums2 塞到 nums1，再 sort 一次 使用三個指針分別指向兩個 list 有數字的結尾，第三個指針指向第一個list 結尾，比較兩個數字，放到第三個指針的位置。 程式碼預設： nums1 一定有足夠的長度塞得下 nums2 nums2 的長度會與 n 相等 1234567def merge(nums1, m, nums2, n) : for i in range(n): nums1.remove(0) nums1.extend(nums2) nums1.sort() return nums1 指針Runtime: 32 ms, faster than 88.41%Memory Usage: 14.1 MB, less than 95.51% 12345678910111213141516def merge(nums1, m, nums2, n) : p = m - 1 q = n - 1 k = m + n -1 while p &gt;= 0 and q &gt;= 0: if nums1[p] &gt; nums2[q]: nums1[k] = nums1[p] p , k = p - 1, k - 1 else: nums1[k] = nums2[q] q , k = q - 1, k - 1 nums1[:q + 1] = nums2[:q + 1] return nums1 167. Two Sum II - Input array is sortedGiven an array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length. The tests are generated such that there is exactly one solution. You may not use the same element twice. Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 想法 兩個指針分別指向 list 的頭與尾，兩兩相加，大於 target 尾指針就往前移動，反之則頭指針往前移。 程式碼 兩個指針Runtime: 68 ms, faster than 28.66%Memory Usage: 14.8 MB, less than 29.47% 1234567891011def twoSum(self, numbers: List[int], target: int) -&gt; List[int]: first = 0 last = len(numbers)-1 while first &lt; last: if numbers[first] + numbers[last] &gt; target: last -= 1 elif numbers[first] + numbers[last] &lt; target: first += 1 else: return[first + 1, last + 1] 217. Contains DuplicateGiven an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Input: nums = [1,1,1,3,3,4,3,2,4,2]Output: true Input: nums = [1,1,1,3,3,4,3,2,4,2]Output: true 想法 兩層 for loop 找有沒有相同的 創新的空 list， 不存在 list 裡的就數字就塞進去，再檢查 先排序，再 for loop 第二個等於第一個的時候 return true 使用內建 map 去除重複的，再檢查兩個 list 的長度是否相同，不相同 return true 程式碼 創造新的 list 123456789101112# time limit exceeddef containsDuplicate(self, nums: List[int]) -&gt; bool: arr = [] for i in nums: if i in arr: return True else: arr.append(i) return False 先排序再檢查第二個Runtime: 124 ms, faster than 36.11%Memory Usage: 19.3 MB, less than 90.31% 123456789101112# 先排序，再檢查def containsDuplicate(self, nums: List[int]) -&gt; bool: nums.sort() for i in range(len(nums) - 1): if nums[i] == nums[i + 1]: print(&quot;true&quot;) return True print(&quot;false&quot;) return False 算兩個的長度Runtime: 120 ms, faster than 58.63%Memory Usage: 20.3 MB, less than 66.17% 123# 使用 setdef containsDuplicate(self, nums: List[int]) -&gt; bool: return len(nums) != len(set(nums)) 219. Contains Duplicate IIGiven an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k. 給一個 list 和 k , 找出重複的數字，這兩個數字的 index 相減要小於 k.( 兩個重複數字的位置距離小於等於 k ) Input: nums = [1,2,3,1,2,3], k = 2Output: false Input: nums = [1,0,1,1], k = 1Output: true 想法 兩層 loop 找重複的，兩個 index 相減 創造新的字典，遍歷 list 不存在的就把數字本身當 key, index 當value 存進去。如果存在字典裡，就用當下數字和 value 相減。 程式碼 兩層 loop 12345678910# time limie exceeddef containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: for i in range(len(nums)): for j in range(i + 1 , len(nums)): if nums[i] == nums[j] and abs(i - j) &lt;= k: return True else: continue return False 字典Runtime: 92 ms, faster than 81.08%Memory Usage: 21.8 MB, less than 54.38% 如果有重複但距離大於 k 就更新字典裡當下元素的 index . 1234567891011def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: dic = {} for index, value in enumerate(nums): if value not in dic: dic[value] = index else: if abs(index - dic[value]) &lt;= k: return True dic[value] = index return False 118. Pascal’s TriangleGiven an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: Input: numRows = 5Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] 每一層的最前和最末端都是 1 ，中間則是上一層的前一個 index 和當下 index 的和。 程式碼是二維的 list， result[i-1][j-1] 的意思是去出 result[i-1] 再取 result[i-1] 的 [j-1]. 12345678910111213def generate(numRows): result = [] for i in range(numRows): result.append([]) for j in range(i + 1): if j in (0, i): result[i].append(1) else: result[i].append(result[i-1][j-1] + result[i-1][j]) print(result)generate(5) 面試常出現題目 13. Roman to Integer 69. Sqrt(x) 70. Climbing Stairs 28. Implement strStr() 14. Longest Common Prefix 13. Roman to Integer Input: s = “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 想法 把條件都存再 dictionary 裡。 有兩種情況：一是只要將數字都加起來，第第二是 4 或 9 之類的數字會以兩個字母代表的數字相減表示。I 後面會接 V / X ； X 會接 L/ C ；C 會接 D / M，這幾個情況屬於第二個情況。 第二個情況三組的共同點是後面字母代表的數字會比前一個大，因此可以用這個來判斷是要相加還是要相減。 判斷方法 使用兩個指針 程式碼Runtime: 44 ms, faster than 81.73%Memory Usage: 14.3 MB, less than 56.57% 1234567891011121314151617def romanToInt(s): dic = {&quot;I&quot; : 1, &quot;V&quot; : 5, &quot;X&quot; : 10, &quot;L&quot; : 50, &quot;C&quot; : 100, &quot;D&quot; : 500,&quot;M&quot; : 1000} result = 0 i = len(s) - 1 while i &gt;= 0: current = dic[s[i]] next = dic[s[i - 1]] if current &gt; next and (i != 0): result += (current - next) i -= 2 else: result += current i -= 1 return result 69. Sqrt(x)Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5. Input: x = 8Output: 2Explanation: The square root of 8 is 2.82842…, and since the decimal part istruncated, 2 is returned. 想法 不能使用內建的方法來找，選擇使用 binary search 會遇到的情況 0 &amp; 1 的平方會是自己 可以被完整根號整除的：4, 9, 16… 無法被整除的就去掉小數，回傳整數：8 回傳 2, 32 回傳 5 設定兩個 pointer ( left &amp; right )，先找出 x 的中位數 (mid) ，mid 的平方如果大於 x 即表示後面的數字都會太大，因此將 right 指標移到 mid；如果小於 x 表示前面的數字太小，將 left 指標移到 mid + 1. 在這裡面不停 loop 直到找到 mid 的平方為 x 為止。遇到無法被整除的狀況最後 left 會等於 right，回傳該值的前一個，所以回傳 left - 1. 程式碼Runtime: 36 ms, faster than 61.05%Memory Usage: 14.3 MB, less than 6.12% 1234567891011121314151617181920def mySqrt(x): if (x &lt; 2): return x left = 1 right = x while left &lt; right: mid = left + (right - left) // 2 if mid * mid == x: print(x) return mid if mid * mid &gt; x: right = mid elif mid * mid &lt;= x: left = mid + 1 return left - 1 70. Climbing Stairs費氏數列：1,1,2,3,5,8,13…（下一個數字會是前面兩個數字的和） You are climbing a staircase. It takes n steps to reach the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 123456Input: n = 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 想法如果把方法都寫出來會發現在爬 2 層梯子的時候總共有 2 種方法，3 層有 3 種方法， 4 層的時候有 5 種方法， 5 層 8 種方法，到這裡會發現，每一層的有的方法數量都是前面的和，這就是費氏數列。 1,1,2,3,5,8,13…（下一個數字會是前面兩個數字的和） 使用 dictionary 將每一層數字的方法數量存起來，最後返回找出 n 的方法數 程式碼Runtime: 32 ms, faster than 50.02%Memory Usage: 14.3 MB, less than 10.71% 12345678def climbStairs(n): dic = {1:1, 2:2, 3:3} for i in range(4, n + 1): dic[i] = dic[i - 1] + dic[i - 2] return(dic[n]) Runtime: 44 ms, faster than 6.40%Memory Usage: 14.3 MB, less than 10.71% 12345678910def climbStairs(self, n: int) -&gt; int: arr = [1,1,2] for i in range(3, n + 1): arr.append(arr[i-1] + arr[i-2]) if n == 1: return 1 else: return arr[-1] 28. Implement strStr()Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Clarification:What should we return when needle is an empty string? This is a great question to ask during an interview.For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Input: haystack = “hello”, needle = “ll”Output: 2 想法 檢查 needle 是否在 hashstack 裡，如果在的話用 find 找出第一次出現的 index 使用兩個 pointer(start,end) 框出範圍，檢查該範圍的字串是否等於 needle 如果等於就返回 start 的 index，不等於就返回 -1. 會在 haystack 裡面尋找 needle，所以 forloop 範圍可以設為 len(haystack) 但因為 loop 到後面幾個（剩餘的字串長度已經少於 needle長度），兩者一定不會相等，因此範圍可以設到 “剩餘的字串長度等於 needle長度” 的那個 index 框出範圍的長度與 needle 的長度要相等，才能比較 程式碼Runtime: 48 ms, faster than 17.58%Memory Usage: 14.6 MB, less than 23.81% 內建 find() 12345678def strStr(self, haystack: str, needle: str) -&gt; int: if not needle: return 0 if needle in haystack: return haystack.find(needle) else: return -1 Runtime: 48 ms, faster than 64.30%Memory Usage: 14.6 MB, less than 77.40 % pointer 12345678910111213def strStr(self, haystack: str, needle: str) -&gt; int: if not needle: return 0 end = len(needle) for start in range(len(haystack) - len(needle) + 1): substring = haystack [ start: end ] if substring == needle: return start else: end += 1 return -1 14. Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string “”. Input: strs = [“flower”,”flow”,”flight”]Output: “fl” 想法 把 list 裡的第一個 item 當成前綴(prefix)，檢查其他的 item 檢查第二個 item 從 “ 0 到 prefix 的長度 “ 的字串是否相等 如果相等就回傳 prefix ，不相等就把 prefix 減少一個字母 反復循環最後 prefix 會減到剩下共有的字母 程式碼Runtime: 32 ms, faster than 80.06%Memory Usage: 14.4 MB, less than 24.46% 1234567891011def longestCommonPrefix(strs): prefix = strs[0] if len(strs) == 0 : return &quot;&quot; for i in range(1, len(strs)): while (strs[i][:len(prefix)] != prefix): prefix = prefix[:len(prefix) -1] return prefix 參考資料Leetcode cookbookLeetCode-GoAlgo expert总结一下面试常考的算法题Huahua’s Tech Road","link":"/2021/06/18/0618-leetcode/"}],"tags":[{"name":"Vannila JS","slug":"Vannila-JS","link":"/tags/Vannila-JS/"},{"name":"學習筆記","slug":"學習筆記","link":"/tags/%E5%AD%B8%E7%BF%92%E7%AD%86%E8%A8%98/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Nuxt","slug":"Nuxt","link":"/categories/Nuxt/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}